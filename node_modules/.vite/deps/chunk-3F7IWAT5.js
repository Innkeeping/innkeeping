import {
  require_events
} from "./chunk-RQK5XDPR.js";
import {
  $u,
  Ah,
  An,
  As,
  Bh,
  Bu,
  Ch,
  Cu,
  Du,
  Eh,
  Es,
  Eu,
  Fu,
  Is,
  Iu,
  Lt,
  Lu,
  Mh,
  Ms,
  Mu,
  Nr,
  Ns,
  Oo,
  Ou,
  Pe,
  Pn,
  Po,
  Pu,
  Rh,
  Ru,
  Sh,
  Sr,
  Ss,
  Su,
  To,
  Tu,
  Uu,
  Vi,
  Vr,
  Wf,
  Wr,
  Xr,
  Xu,
  Yt,
  Ze,
  Zu,
  _h,
  _s,
  _u,
  bh,
  bi,
  bs,
  ch,
  cs,
  decodeJWT,
  dh,
  encodeIss,
  er,
  fs,
  generateKeyPair,
  gh,
  gr,
  gs,
  gu,
  hh,
  init_tslib_es6,
  ju,
  ku,
  lh,
  ls,
  me,
  mh,
  ms,
  mu,
  ns,
  on,
  ph,
  pr,
  qu,
  require_cjs,
  rr,
  signJWT,
  so,
  ss,
  tn,
  toString,
  tslib_es6_exports,
  uh,
  vh,
  wh,
  ws,
  xe,
  xh,
  xo,
  xs,
  xu,
  yh,
  ys,
  zu
} from "./chunk-TO2JMQY6.js";
import {
  A,
  E,
  import_pino,
  k,
  safeJsonParse,
  safeJsonStringify,
  y
} from "./chunk-7JQTN5IQ.js";
import {
  __commonJS,
  __export,
  __reExport,
  __toCommonJS,
  __toESM
} from "./chunk-MSFXBLHD.js";

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto;
    function getSubtleCrypto() {
      const browserCrypto = getBrowerCrypto();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto() && !!getSubtleCrypto();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative;
    function isNode2() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode2;
    function isBrowser() {
      return !isReactNative() && !isNode2();
    }
    exports.isBrowser = isBrowser;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// node_modules/lodash.isequal/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isequal/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1;
    var COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var asyncTag = "[object AsyncFunction]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var nullTag = "[object Null]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var proxyTag = "[object Proxy]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var undefinedTag = "[object Undefined]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n4, iteratee) {
      var index = -1, result = Array(n4);
      while (++index < n4) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data = getMapData(this, key), size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys2, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e2) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e2) {
        }
        try {
          return func + "";
        } catch (e2) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys2(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  }
});

// node_modules/@walletconnect/jsonrpc-http-connection/node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/@walletconnect/jsonrpc-http-connection/node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
    var global2 = typeof self !== "undefined" ? self : exports;
    var __self__ = function() {
      function F3() {
        this.fetch = false;
        this.DOMException = global2.DOMException;
      }
      F3.prototype = global2;
      return new F3();
    }();
    (function(self2) {
      var irrelevant = function(exports2) {
        var support = {
          searchParams: "URLSearchParams" in self2,
          iterable: "Symbol" in self2 && "iterator" in Symbol,
          blob: "FileReader" in self2 && "Blob" in self2 && function() {
            try {
              new Blob();
              return true;
            } catch (e2) {
              return false;
            }
          }(),
          formData: "FormData" in self2,
          arrayBuffer: "ArrayBuffer" in self2
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
            throw new TypeError("Invalid character in header field name");
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers(headers) {
          this.map = {};
          if (headers instanceof Headers) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsText(blob);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i3 = 0; i3 < view.length; i3++) {
            chars[i3] = String.fromCharCode(view[i3]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this._bodyInit = body;
            if (!body) {
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
            this.arrayBuffer = function() {
              if (this._bodyArrayBuffer) {
                return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
              } else {
                return this.blob().then(readBlobAsArrayBuffer);
              }
            };
          }
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal;
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              headers.append(key, value);
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = "statusText" in options ? options.statusText : "OK";
          this.headers = new Headers(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 0, statusText: "" });
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = self2.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch2(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                status: xhr.status,
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              resolve(new Response(body, options));
            };
            xhr.onerror = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.ontimeout = function() {
              reject(new TypeError("Network request failed"));
            };
            xhr.onabort = function() {
              reject(new exports2.DOMException("Aborted", "AbortError"));
            };
            xhr.open(request.method, request.url, true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr && support.blob) {
              xhr.responseType = "blob";
            }
            request.headers.forEach(function(value, name) {
              xhr.setRequestHeader(name, value);
            });
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch2.polyfill = true;
        if (!self2.fetch) {
          self2.fetch = fetch2;
          self2.Headers = Headers;
          self2.Request = Request;
          self2.Response = Response;
        }
        exports2.Headers = Headers;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch2;
        Object.defineProperty(exports2, "__esModule", { value: true });
        return exports2;
      }({});
    })(__self__);
    __self__.fetch.ponyfill = true;
    delete __self__.fetch.polyfill;
    var ctx = __self__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module.exports = exports;
  }
});

// node_modules/@walletconnect/core/dist/index.es.js
var import_events7 = __toESM(require_events());

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());

// node_modules/@walletconnect/events/dist/esm/events.js
var IEvents = class {
};

// node_modules/@walletconnect/heartbeat/dist/index.es.js
var n = class extends IEvents {
  constructor(e2) {
    super();
  }
};
var s = import_time.FIVE_SECONDS;
var r = { pulse: "heartbeat_pulse" };
var i = class _i2 extends n {
  constructor(e2) {
    super(e2), this.events = new import_events.EventEmitter(), this.interval = s, this.interval = (e2 == null ? void 0 : e2.interval) || s;
  }
  static async init(e2) {
    const t = new _i2(e2);
    return await t.init(), t;
  }
  async init() {
    await this.initialize();
  }
  stop() {
    clearInterval(this.intervalRef);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async initialize() {
    this.intervalRef = setInterval(() => this.pulse(), (0, import_time.toMiliseconds)(this.interval));
  }
  pulse() {
    this.events.emit(r.pulse);
  }
};

// node_modules/destr/dist/index.mjs
var suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
var JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
  if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
    warnKeyDropped(key);
    return;
  }
  return value;
}
function warnKeyDropped(key) {
  console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
  if (typeof value !== "string") {
    return value;
  }
  const _value = value.trim();
  if (
    // eslint-disable-next-line unicorn/prefer-at
    value[0] === '"' && value.endsWith('"') && !value.includes("\\")
  ) {
    return _value.slice(1, -1);
  }
  if (_value.length <= 9) {
    const _lval = _value.toLowerCase();
    if (_lval === "true") {
      return true;
    }
    if (_lval === "false") {
      return false;
    }
    if (_lval === "undefined") {
      return void 0;
    }
    if (_lval === "null") {
      return null;
    }
    if (_lval === "nan") {
      return Number.NaN;
    }
    if (_lval === "infinity") {
      return Number.POSITIVE_INFINITY;
    }
    if (_lval === "-infinity") {
      return Number.NEGATIVE_INFINITY;
    }
  }
  if (!JsonSigRx.test(value)) {
    if (options.strict) {
      throw new SyntaxError("[destr] Invalid JSON");
    }
    return value;
  }
  try {
    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
      if (options.strict) {
        throw new Error("[destr] Possible prototype pollution");
      }
      return JSON.parse(value, jsonParseTransform);
    }
    return JSON.parse(value);
  } catch (error) {
    if (options.strict) {
      throw error;
    }
    return value;
  }
}

// node_modules/unstorage/dist/shared/unstorage.d569726e.mjs
function wrapToPromise(value) {
  if (!value || typeof value.then !== "function") {
    return Promise.resolve(value);
  }
  return value;
}
function asyncCall(function_, ...arguments_) {
  try {
    return wrapToPromise(function_(...arguments_));
  } catch (error) {
    return Promise.reject(error);
  }
}
function isPrimitive(value) {
  const type = typeof value;
  return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
  const proto = Object.getPrototypeOf(value);
  return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
  if (isPrimitive(value)) {
    return String(value);
  }
  if (isPureObject(value) || Array.isArray(value)) {
    return JSON.stringify(value);
  }
  if (typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  throw new Error("[unstorage] Cannot stringify value!");
}
function checkBufferSupport() {
  if (typeof Buffer === "undefined") {
    throw new TypeError("[unstorage] Buffer is not supported!");
  }
}
var BASE64_PREFIX = "base64:";
function serializeRaw(value) {
  if (typeof value === "string") {
    return value;
  }
  checkBufferSupport();
  const base64 = Buffer.from(value).toString("base64");
  return BASE64_PREFIX + base64;
}
function deserializeRaw(value) {
  if (typeof value !== "string") {
    return value;
  }
  if (!value.startsWith(BASE64_PREFIX)) {
    return value;
  }
  checkBufferSupport();
  return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
}
function normalizeKey(key) {
  if (!key) {
    return "";
  }
  return key.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
}
function joinKeys(...keys2) {
  return normalizeKey(keys2.join(":"));
}
function normalizeBaseKey(base) {
  base = normalizeKey(base);
  return base ? base + ":" : "";
}

// node_modules/unstorage/dist/index.mjs
function defineDriver(factory) {
  return factory;
}
var DRIVER_NAME = "memory";
var memory = defineDriver(() => {
  const data = /* @__PURE__ */ new Map();
  return {
    name: DRIVER_NAME,
    getInstance: () => data,
    hasItem(key) {
      return data.has(key);
    },
    getItem(key) {
      return data.get(key) ?? null;
    },
    getItemRaw(key) {
      return data.get(key) ?? null;
    },
    setItem(key, value) {
      data.set(key, value);
    },
    setItemRaw(key, value) {
      data.set(key, value);
    },
    removeItem(key) {
      data.delete(key);
    },
    getKeys() {
      return [...data.keys()];
    },
    clear() {
      data.clear();
    },
    dispose() {
      data.clear();
    }
  };
});
function createStorage(options = {}) {
  const context = {
    mounts: { "": options.driver || memory() },
    mountpoints: [""],
    watching: false,
    watchListeners: [],
    unwatch: {}
  };
  const getMount = (key) => {
    for (const base of context.mountpoints) {
      if (key.startsWith(base)) {
        return {
          base,
          relativeKey: key.slice(base.length),
          driver: context.mounts[base]
        };
      }
    }
    return {
      base: "",
      relativeKey: key,
      driver: context.mounts[""]
    };
  };
  const getMounts = (base, includeParent) => {
    return context.mountpoints.filter(
      (mountpoint) => mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)
    ).map((mountpoint) => ({
      relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
      mountpoint,
      driver: context.mounts[mountpoint]
    }));
  };
  const onChange = (event, key) => {
    if (!context.watching) {
      return;
    }
    key = normalizeKey(key);
    for (const listener of context.watchListeners) {
      listener(event, key);
    }
  };
  const startWatch = async () => {
    if (context.watching) {
      return;
    }
    context.watching = true;
    for (const mountpoint in context.mounts) {
      context.unwatch[mountpoint] = await watch(
        context.mounts[mountpoint],
        onChange,
        mountpoint
      );
    }
  };
  const stopWatch = async () => {
    if (!context.watching) {
      return;
    }
    for (const mountpoint in context.unwatch) {
      await context.unwatch[mountpoint]();
    }
    context.unwatch = {};
    context.watching = false;
  };
  const runBatch = (items, commonOptions, cb) => {
    const batches = /* @__PURE__ */ new Map();
    const getBatch = (mount) => {
      let batch = batches.get(mount.base);
      if (!batch) {
        batch = {
          driver: mount.driver,
          base: mount.base,
          items: []
        };
        batches.set(mount.base, batch);
      }
      return batch;
    };
    for (const item of items) {
      const isStringItem = typeof item === "string";
      const key = normalizeKey(isStringItem ? item : item.key);
      const value = isStringItem ? void 0 : item.value;
      const options2 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
      const mount = getMount(key);
      getBatch(mount).items.push({
        key,
        value,
        relativeKey: mount.relativeKey,
        options: options2
      });
    }
    return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
      (r3) => r3.flat()
    );
  };
  const storage = {
    // Item
    hasItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.hasItem, relativeKey, opts);
    },
    getItem(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => destr(value)
      );
    },
    getItems(items, commonOptions) {
      return runBatch(items, commonOptions, (batch) => {
        if (batch.driver.getItems) {
          return asyncCall(
            batch.driver.getItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              options: item.options
            })),
            commonOptions
          ).then(
            (r3) => r3.map((item) => ({
              key: joinKeys(batch.base, item.key),
              value: destr(item.value)
            }))
          );
        }
        return Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.getItem,
              item.relativeKey,
              item.options
            ).then((value) => ({
              key: item.key,
              value: destr(value)
            }));
          })
        );
      });
    },
    getItemRaw(key, opts = {}) {
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.getItemRaw) {
        return asyncCall(driver.getItemRaw, relativeKey, opts);
      }
      return asyncCall(driver.getItem, relativeKey, opts).then(
        (value) => deserializeRaw(value)
      );
    },
    async setItem(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.setItem) {
        return;
      }
      await asyncCall(driver.setItem, relativeKey, stringify(value), opts);
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async setItems(items, commonOptions) {
      await runBatch(items, commonOptions, async (batch) => {
        if (batch.driver.setItems) {
          return asyncCall(
            batch.driver.setItems,
            batch.items.map((item) => ({
              key: item.relativeKey,
              value: stringify(item.value),
              options: item.options
            })),
            commonOptions
          );
        }
        if (!batch.driver.setItem) {
          return;
        }
        await Promise.all(
          batch.items.map((item) => {
            return asyncCall(
              batch.driver.setItem,
              item.relativeKey,
              stringify(item.value),
              item.options
            );
          })
        );
      });
    },
    async setItemRaw(key, value, opts = {}) {
      if (value === void 0) {
        return storage.removeItem(key, opts);
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (driver.setItemRaw) {
        await asyncCall(driver.setItemRaw, relativeKey, value, opts);
      } else if (driver.setItem) {
        await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
      } else {
        return;
      }
      if (!driver.watch) {
        onChange("update", key);
      }
    },
    async removeItem(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { removeMeta: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      if (!driver.removeItem) {
        return;
      }
      await asyncCall(driver.removeItem, relativeKey, opts);
      if (opts.removeMeta || opts.removeMata) {
        await asyncCall(driver.removeItem, relativeKey + "$", opts);
      }
      if (!driver.watch) {
        onChange("remove", key);
      }
    },
    // Meta
    async getMeta(key, opts = {}) {
      if (typeof opts === "boolean") {
        opts = { nativeOnly: opts };
      }
      key = normalizeKey(key);
      const { relativeKey, driver } = getMount(key);
      const meta = /* @__PURE__ */ Object.create(null);
      if (driver.getMeta) {
        Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
      }
      if (!opts.nativeOnly) {
        const value = await asyncCall(
          driver.getItem,
          relativeKey + "$",
          opts
        ).then((value_) => destr(value_));
        if (value && typeof value === "object") {
          if (typeof value.atime === "string") {
            value.atime = new Date(value.atime);
          }
          if (typeof value.mtime === "string") {
            value.mtime = new Date(value.mtime);
          }
          Object.assign(meta, value);
        }
      }
      return meta;
    },
    setMeta(key, value, opts = {}) {
      return this.setItem(key + "$", value, opts);
    },
    removeMeta(key, opts = {}) {
      return this.removeItem(key + "$", opts);
    },
    // Keys
    async getKeys(base, opts = {}) {
      base = normalizeBaseKey(base);
      const mounts = getMounts(base, true);
      let maskedMounts = [];
      const allKeys = [];
      for (const mount of mounts) {
        const rawKeys = await asyncCall(
          mount.driver.getKeys,
          mount.relativeBase,
          opts
        );
        for (const key of rawKeys) {
          const fullKey = mount.mountpoint + normalizeKey(key);
          if (!maskedMounts.some((p3) => fullKey.startsWith(p3))) {
            allKeys.push(fullKey);
          }
        }
        maskedMounts = [
          mount.mountpoint,
          ...maskedMounts.filter((p3) => !p3.startsWith(mount.mountpoint))
        ];
      }
      return base ? allKeys.filter(
        (key) => key.startsWith(base) && key[key.length - 1] !== "$"
      ) : allKeys.filter((key) => key[key.length - 1] !== "$");
    },
    // Utils
    async clear(base, opts = {}) {
      base = normalizeBaseKey(base);
      await Promise.all(
        getMounts(base, false).map(async (m2) => {
          if (m2.driver.clear) {
            return asyncCall(m2.driver.clear, m2.relativeBase, opts);
          }
          if (m2.driver.removeItem) {
            const keys2 = await m2.driver.getKeys(m2.relativeBase || "", opts);
            return Promise.all(
              keys2.map((key) => m2.driver.removeItem(key, opts))
            );
          }
        })
      );
    },
    async dispose() {
      await Promise.all(
        Object.values(context.mounts).map((driver) => dispose(driver))
      );
    },
    async watch(callback) {
      await startWatch();
      context.watchListeners.push(callback);
      return async () => {
        context.watchListeners = context.watchListeners.filter(
          (listener) => listener !== callback
        );
        if (context.watchListeners.length === 0) {
          await stopWatch();
        }
      };
    },
    async unwatch() {
      context.watchListeners = [];
      await stopWatch();
    },
    // Mount
    mount(base, driver) {
      base = normalizeBaseKey(base);
      if (base && context.mounts[base]) {
        throw new Error(`already mounted at ${base}`);
      }
      if (base) {
        context.mountpoints.push(base);
        context.mountpoints.sort((a4, b3) => b3.length - a4.length);
      }
      context.mounts[base] = driver;
      if (context.watching) {
        Promise.resolve(watch(driver, onChange, base)).then((unwatcher) => {
          context.unwatch[base] = unwatcher;
        }).catch(console.error);
      }
      return storage;
    },
    async unmount(base, _dispose = true) {
      base = normalizeBaseKey(base);
      if (!base || !context.mounts[base]) {
        return;
      }
      if (context.watching && base in context.unwatch) {
        context.unwatch[base]();
        delete context.unwatch[base];
      }
      if (_dispose) {
        await dispose(context.mounts[base]);
      }
      context.mountpoints = context.mountpoints.filter((key) => key !== base);
      delete context.mounts[base];
    },
    getMount(key = "") {
      key = normalizeKey(key) + ":";
      const m2 = getMount(key);
      return {
        driver: m2.driver,
        base: m2.base
      };
    },
    getMounts(base = "", opts = {}) {
      base = normalizeKey(base);
      const mounts = getMounts(base, opts.parents);
      return mounts.map((m2) => ({
        driver: m2.driver,
        base: m2.mountpoint
      }));
    },
    // Aliases
    keys: (base, opts = {}) => storage.getKeys(base, opts),
    get: (key, opts = {}) => storage.getItem(key, opts),
    set: (key, value, opts = {}) => storage.setItem(key, value, opts),
    has: (key, opts = {}) => storage.hasItem(key, opts),
    del: (key, opts = {}) => storage.removeItem(key, opts),
    remove: (key, opts = {}) => storage.removeItem(key, opts)
  };
  return storage;
}
function watch(driver, onChange, base) {
  return driver.watch ? driver.watch((event, key) => onChange(event, base + key)) : () => {
  };
}
async function dispose(driver) {
  if (typeof driver.dispose === "function") {
    await asyncCall(driver.dispose);
  }
}

// node_modules/idb-keyval/dist/index.js
function promisifyRequest(request) {
  return new Promise((resolve, reject) => {
    request.oncomplete = request.onsuccess = () => resolve(request.result);
    request.onabort = request.onerror = () => reject(request.error);
  });
}
function createStore(dbName, storeName) {
  const request = indexedDB.open(dbName);
  request.onupgradeneeded = () => request.result.createObjectStore(storeName);
  const dbp = promisifyRequest(request);
  return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
var defaultGetStoreFunc;
function defaultGetStore() {
  if (!defaultGetStoreFunc) {
    defaultGetStoreFunc = createStore("keyval-store", "keyval");
  }
  return defaultGetStoreFunc;
}
function get(key, customStore = defaultGetStore()) {
  return customStore("readonly", (store) => promisifyRequest(store.get(key)));
}
function set(key, value, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.put(value, key);
    return promisifyRequest(store.transaction);
  });
}
function del(key, customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.delete(key);
    return promisifyRequest(store.transaction);
  });
}
function clear(customStore = defaultGetStore()) {
  return customStore("readwrite", (store) => {
    store.clear();
    return promisifyRequest(store.transaction);
  });
}
function eachCursor(store, callback) {
  store.openCursor().onsuccess = function() {
    if (!this.result)
      return;
    callback(this.result);
    this.result.continue();
  };
  return promisifyRequest(store.transaction);
}
function keys(customStore = defaultGetStore()) {
  return customStore("readonly", (store) => {
    if (store.getAllKeys) {
      return promisifyRequest(store.getAllKeys());
    }
    const items = [];
    return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
  });
}

// node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
var x = "idb-keyval";
var z = (i3 = {}) => {
  const t = i3.base && i3.base.length > 0 ? `${i3.base}:` : "", e2 = (s2) => t + s2;
  let n4;
  return i3.dbName && i3.storeName && (n4 = createStore(i3.dbName, i3.storeName)), { name: x, options: i3, async hasItem(s2) {
    return !(typeof await get(e2(s2), n4) > "u");
  }, async getItem(s2) {
    return await get(e2(s2), n4) ?? null;
  }, setItem(s2, a4) {
    return set(e2(s2), a4, n4);
  }, removeItem(s2) {
    return del(e2(s2), n4);
  }, getKeys() {
    return keys(n4);
  }, clear() {
    return clear(n4);
  } };
};
var D = "WALLET_CONNECT_V2_INDEXED_DB";
var E2 = "keyvaluestorage";
var _ = class {
  constructor() {
    this.indexedDb = createStorage({ driver: z({ dbName: D, storeName: E2 }) });
  }
  async getKeys() {
    return this.indexedDb.getKeys();
  }
  async getEntries() {
    return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t) => [t.key, t.value]);
  }
  async getItem(t) {
    const e2 = await this.indexedDb.getItem(t);
    if (e2 !== null) return e2;
  }
  async setItem(t, e2) {
    await this.indexedDb.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    await this.indexedDb.removeItem(t);
  }
};
var l2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var c = { exports: {} };
(function() {
  let i3;
  function t() {
  }
  i3 = t, i3.prototype.getItem = function(e2) {
    return this.hasOwnProperty(e2) ? String(this[e2]) : null;
  }, i3.prototype.setItem = function(e2, n4) {
    this[e2] = String(n4);
  }, i3.prototype.removeItem = function(e2) {
    delete this[e2];
  }, i3.prototype.clear = function() {
    const e2 = this;
    Object.keys(e2).forEach(function(n4) {
      e2[n4] = void 0, delete e2[n4];
    });
  }, i3.prototype.key = function(e2) {
    return e2 = e2 || 0, Object.keys(this)[e2];
  }, i3.prototype.__defineGetter__("length", function() {
    return Object.keys(this).length;
  }), typeof l2 < "u" && l2.localStorage ? c.exports = l2.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t();
})();
function k2(i3) {
  var t;
  return [i3[0], safeJsonParse((t = i3[1]) != null ? t : "")];
}
var K = class {
  constructor() {
    this.localStorage = c.exports;
  }
  async getKeys() {
    return Object.keys(this.localStorage);
  }
  async getEntries() {
    return Object.entries(this.localStorage).map(k2);
  }
  async getItem(t) {
    const e2 = this.localStorage.getItem(t);
    if (e2 !== null) return safeJsonParse(e2);
  }
  async setItem(t, e2) {
    this.localStorage.setItem(t, safeJsonStringify(e2));
  }
  async removeItem(t) {
    this.localStorage.removeItem(t);
  }
};
var N = "wc_storage_version";
var y2 = 1;
var O = async (i3, t, e2) => {
  const n4 = N, s2 = await t.getItem(n4);
  if (s2 && s2 >= y2) {
    e2(t);
    return;
  }
  const a4 = await i3.getKeys();
  if (!a4.length) {
    e2(t);
    return;
  }
  const m2 = [];
  for (; a4.length; ) {
    const r3 = a4.shift();
    if (!r3) continue;
    const o5 = r3.toLowerCase();
    if (o5.includes("wc@") || o5.includes("walletconnect") || o5.includes("wc_") || o5.includes("wallet_connect")) {
      const f3 = await i3.getItem(r3);
      await t.setItem(r3, f3), m2.push(r3);
    }
  }
  await t.setItem(n4, y2), e2(t), j(i3, m2);
};
var j = async (i3, t) => {
  t.length && t.forEach(async (e2) => {
    await i3.removeItem(e2);
  });
};
var h = class {
  constructor() {
    this.initialized = false, this.setInitialized = (e2) => {
      this.storage = e2, this.initialized = true;
    };
    const t = new K();
    this.storage = t;
    try {
      const e2 = new _();
      O(t, e2, this.setInitialized);
    } catch {
      this.initialized = true;
    }
  }
  async getKeys() {
    return await this.initialize(), this.storage.getKeys();
  }
  async getEntries() {
    return await this.initialize(), this.storage.getEntries();
  }
  async getItem(t) {
    return await this.initialize(), this.storage.getItem(t);
  }
  async setItem(t, e2) {
    return await this.initialize(), this.storage.setItem(t, e2);
  }
  async removeItem(t) {
    return await this.initialize(), this.storage.removeItem(t);
  }
  async initialize() {
    this.initialized || await new Promise((t) => {
      const e2 = setInterval(() => {
        this.initialized && (clearInterval(e2), t());
      }, 20);
    });
  }
};

// node_modules/@walletconnect/types/dist/index.es.js
var import_events4 = __toESM(require_events());
var n2 = class extends IEvents {
  constructor(s2) {
    super(), this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var h2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t, this.records = /* @__PURE__ */ new Map();
  }
};
var a2 = class {
  constructor(s2, t) {
    this.logger = s2, this.core = t;
  }
};
var g = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var u = class extends IEvents {
  constructor(s2) {
    super();
  }
};
var p = class {
  constructor(s2, t, e2, f3) {
    this.core = s2, this.logger = t, this.name = e2;
  }
};
var d = class extends IEvents {
  constructor(s2, t) {
    super(), this.relayer = s2, this.logger = t;
  }
};
var x2 = class extends IEvents {
  constructor(s2, t) {
    super(), this.core = s2, this.logger = t;
  }
};
var y3 = class {
  constructor(s2, t, e2) {
    this.core = s2, this.logger = t, this.store = e2;
  }
};
var v = class {
  constructor(s2, t) {
    this.projectId = s2, this.logger = t;
  }
};
var C = class {
  constructor(s2, t, e2) {
    this.core = s2, this.logger = t, this.telemetryEnabled = e2;
  }
};
var S = class {
  constructor(s2) {
    this.opts = s2, this.protocol = "wc", this.version = 2;
  }
};
var M = class {
  constructor(s2) {
    this.client = s2;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_time2 = __toESM(require_cjs());

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var import_events5 = __toESM(require_events());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n3,
  IEvents: () => e,
  IJsonRpcConnection: () => o2,
  IJsonRpcProvider: () => r2,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs2());
__reExport(env_exports, __toESM(require_cjs2()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x4) => x4.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e = class {
};
var o2 = class extends e {
  constructor(c5) {
    super();
  }
};
var n3 = class extends e {
  constructor() {
    super();
  }
};
var r2 = class extends n3 {
  constructor(c5) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/jsonrpc-provider/dist/index.es.js
var o3 = class extends r2 {
  constructor(t) {
    super(t), this.events = new import_events5.EventEmitter(), this.hasRegisteredEventListeners = false, this.connection = this.setConnection(t), this.connection.connected && this.registerEventListeners();
  }
  async connect(t = this.connection) {
    await this.open(t);
  }
  async disconnect() {
    await this.close();
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async request(t, e2) {
    return this.requestStrict(formatJsonRpcRequest(t.method, t.params || [], t.id || getBigIntRpcId().toString()), e2);
  }
  async requestStrict(t, e2) {
    return new Promise(async (i3, s2) => {
      if (!this.connection.connected) try {
        await this.open();
      } catch (n4) {
        s2(n4);
      }
      this.events.on(`${t.id}`, (n4) => {
        isJsonRpcError(n4) ? s2(n4.error) : i3(n4.result);
      });
      try {
        await this.connection.send(t, e2);
      } catch (n4) {
        s2(n4);
      }
    });
  }
  setConnection(t = this.connection) {
    return t;
  }
  onPayload(t) {
    this.events.emit("payload", t), isJsonRpcResponse(t) ? this.events.emit(`${t.id}`, t) : this.events.emit("message", { type: t.method, data: t.params });
  }
  onClose(t) {
    t && t.code === 3e3 && this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${t.code} ${t.reason ? `(${t.reason})` : ""}`)), this.events.emit("disconnect");
  }
  async open(t = this.connection) {
    this.connection === t && this.connection.connected || (this.connection.connected && this.close(), typeof t == "string" && (await this.connection.open(t), t = this.connection), this.connection = this.setConnection(t), await this.connection.open(), this.registerEventListeners(), this.events.emit("connect"));
  }
  async close() {
    await this.connection.close();
  }
  registerEventListeners() {
    this.hasRegisteredEventListeners || (this.connection.on("payload", (t) => this.onPayload(t)), this.connection.on("close", (t) => this.onClose(t)), this.connection.on("error", (t) => this.events.emit("error", t)), this.connection.on("register_error", (t) => this.onClose()), this.hasRegisteredEventListeners = true);
  }
};

// node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
var import_events6 = __toESM(require_events());
var w = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser();
var b = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
var a3 = (c5) => c5.split("?")[0];
var h3 = 10;
var S2 = w();
var f = class {
  constructor(e2) {
    if (this.url = e2, this.events = new import_events6.EventEmitter(), this.registering = false, !isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    this.url = e2;
  }
  get connected() {
    return typeof this.socket < "u";
  }
  get connecting() {
    return this.registering;
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async open(e2 = this.url) {
    await this.register(e2);
  }
  async close() {
    return new Promise((e2, t) => {
      if (typeof this.socket > "u") {
        t(new Error("Connection already closed"));
        return;
      }
      this.socket.onclose = (n4) => {
        this.onClose(n4), e2();
      }, this.socket.close();
    });
  }
  async send(e2) {
    typeof this.socket > "u" && (this.socket = await this.register());
    try {
      this.socket.send(safeJsonStringify(e2));
    } catch (t) {
      this.onError(e2.id, t);
    }
  }
  register(e2 = this.url) {
    if (!isWsUrl(e2)) throw new Error(`Provided URL is not compatible with WebSocket connection: ${e2}`);
    if (this.registering) {
      const t = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= t || this.events.listenerCount("open") >= t) && this.events.setMaxListeners(t + 1), new Promise((n4, o5) => {
        this.events.once("register_error", (s2) => {
          this.resetMaxListeners(), o5(s2);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.socket > "u") return o5(new Error("WebSocket connection is missing or invalid"));
          n4(this.socket);
        });
      });
    }
    return this.url = e2, this.registering = true, new Promise((t, n4) => {
      const o5 = new URLSearchParams(e2).get("origin"), s2 = (0, esm_exports.isReactNative)() ? { headers: { origin: o5 } } : { rejectUnauthorized: !isLocalhostUrl(e2) }, i3 = new S2(e2, [], s2);
      b() ? i3.onerror = (r3) => {
        const l4 = r3;
        n4(this.emitError(l4.error));
      } : i3.on("error", (r3) => {
        n4(this.emitError(r3));
      }), i3.onopen = () => {
        this.onOpen(i3), t(i3);
      };
    });
  }
  onOpen(e2) {
    e2.onmessage = (t) => this.onPayload(t), e2.onclose = (t) => this.onClose(t), this.socket = e2, this.registering = false, this.events.emit("open");
  }
  onClose(e2) {
    this.socket = void 0, this.registering = false, this.events.emit("close", e2);
  }
  onPayload(e2) {
    if (typeof e2.data > "u") return;
    const t = typeof e2.data == "string" ? safeJsonParse(e2.data) : e2.data;
    this.events.emit("payload", t);
  }
  onError(e2, t) {
    const n4 = this.parseError(t), o5 = n4.message || n4.toString(), s2 = formatJsonRpcError(e2, o5);
    this.events.emit("payload", s2);
  }
  parseError(e2, t = this.url) {
    return parseConnectionError(e2, a3(t), "WS");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > h3 && this.events.setMaxListeners(h3);
  }
  emitError(e2) {
    const t = this.parseError(new Error((e2 == null ? void 0 : e2.message) || `WebSocket connection failed for host: ${a3(this.url)}`));
    return this.events.emit("register_error", t), t;
  }
};

// node_modules/@walletconnect/core/dist/index.es.js
var import_lodash = __toESM(require_lodash());
var be = "wc";
var fe = 2;
var ne = "core";
var O2 = `${be}@2:${ne}:`;
var Xe = { name: ne, logger: "error" };
var Ze2 = { database: ":memory:" };
var Qe = "crypto";
var _e = "client_ed25519_seed";
var et = import_time2.ONE_DAY;
var tt = "keychain";
var it = "0.3";
var st = "messages";
var rt = "0.3";
var nt = import_time2.SIX_HOURS;
var ot = "publisher";
var at = "irn";
var ct = "error";
var Ee = "wss://relay.walletconnect.org";
var ht = "relayer";
var w2 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
var lt = "_subscription";
var T = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
var ut = 0.1;
var oe = "2.17.0";
var F = { link_mode: "link_mode", relay: "relay" };
var dt = "0.3";
var gt = "WALLETCONNECT_CLIENT_ID";
var ve = "WALLETCONNECT_LINK_MODE_APPS";
var A2 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
var pt = "subscription";
var yt = "0.3";
var Dt = import_time2.FIVE_SECONDS * 1e3;
var mt = "pairing";
var bt = "0.3";
var j2 = { wc_pairingDelete: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time2.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time2.ONE_DAY, prompt: false, tag: 0 } } };
var q = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
var P = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
var ft = "history";
var _t = "0.3";
var Et = "expirer";
var R = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
var vt = "0.3";
var wt = "verify-api";
var Is2 = "https://verify.walletconnect.com";
var It = "https://verify.walletconnect.org";
var Z = It;
var Tt = `${Z}/v3`;
var Ct = [Is2, It];
var St = "echo";
var Pt = "https://echo.walletconnect.com";
var z2 = { pairing_started: "pairing_started", pairing_uri_validation_success: "pairing_uri_validation_success", pairing_uri_not_expired: "pairing_uri_not_expired", store_new_pairing: "store_new_pairing", subscribing_pairing_topic: "subscribing_pairing_topic", subscribe_pairing_topic_success: "subscribe_pairing_topic_success", existing_pairing: "existing_pairing", pairing_not_expired: "pairing_not_expired", emit_inactive_pairing: "emit_inactive_pairing", emit_session_proposal: "emit_session_proposal", subscribing_to_pairing_topic: "subscribing_to_pairing_topic" };
var M2 = { no_wss_connection: "no_wss_connection", no_internet_connection: "no_internet_connection", malformed_pairing_uri: "malformed_pairing_uri", active_pairing_already_exists: "active_pairing_already_exists", subscribe_pairing_topic_failure: "subscribe_pairing_topic_failure", pairing_expired: "pairing_expired", proposal_expired: "proposal_expired", proposal_listener_not_found: "proposal_listener_not_found" };
var Cs = { session_approve_started: "session_approve_started", proposal_not_expired: "proposal_not_expired", session_namespaces_validation_success: "session_namespaces_validation_success", create_session_topic: "create_session_topic", subscribing_session_topic: "subscribing_session_topic", subscribe_session_topic_success: "subscribe_session_topic_success", publishing_session_approve: "publishing_session_approve", session_approve_publish_success: "session_approve_publish_success", store_session: "store_session", publishing_session_settle: "publishing_session_settle", session_settle_publish_success: "session_settle_publish_success" };
var Ss2 = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", proposal_expired: "proposal_expired", subscribe_session_topic_failure: "subscribe_session_topic_failure", session_approve_publish_failure: "session_approve_publish_failure", session_settle_publish_failure: "session_settle_publish_failure", session_approve_namespace_validation_failure: "session_approve_namespace_validation_failure", proposal_not_found: "proposal_not_found" };
var Ps = { authenticated_session_approve_started: "authenticated_session_approve_started", authenticated_session_not_expired: "authenticated_session_not_expired", chains_caip2_compliant: "chains_caip2_compliant", chains_evm_compliant: "chains_evm_compliant", create_authenticated_session_topic: "create_authenticated_session_topic", cacaos_verified: "cacaos_verified", store_authenticated_session: "store_authenticated_session", subscribing_authenticated_session_topic: "subscribing_authenticated_session_topic", subscribe_authenticated_session_topic_success: "subscribe_authenticated_session_topic_success", publishing_authenticated_session_approve: "publishing_authenticated_session_approve", authenticated_session_approve_publish_success: "authenticated_session_approve_publish_success" };
var Rs = { no_internet_connection: "no_internet_connection", no_wss_connection: "no_wss_connection", missing_session_authenticate_request: "missing_session_authenticate_request", session_authenticate_request_expired: "session_authenticate_request_expired", chains_caip2_compliant_failure: "chains_caip2_compliant_failure", chains_evm_compliant_failure: "chains_evm_compliant_failure", invalid_cacao: "invalid_cacao", subscribe_authenticated_session_topic_failure: "subscribe_authenticated_session_topic_failure", authenticated_session_approve_publish_failure: "authenticated_session_approve_publish_failure", authenticated_session_pending_request_not_found: "authenticated_session_pending_request_not_found" };
var Rt = 0.1;
var xt = "event-client";
var Ot = 86400;
var At = "https://pulse.walletconnect.org/batch";
function xs2(o5, e2) {
  if (o5.length >= 255) throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), s2 = 0; s2 < t.length; s2++) t[s2] = 255;
  for (var i3 = 0; i3 < o5.length; i3++) {
    var r3 = o5.charAt(i3), n4 = r3.charCodeAt(0);
    if (t[n4] !== 255) throw new TypeError(r3 + " is ambiguous");
    t[n4] = i3;
  }
  var a4 = o5.length, c5 = o5.charAt(0), h4 = Math.log(a4) / Math.log(256), d3 = Math.log(256) / Math.log(a4);
  function g3(l4) {
    if (l4 instanceof Uint8Array || (ArrayBuffer.isView(l4) ? l4 = new Uint8Array(l4.buffer, l4.byteOffset, l4.byteLength) : Array.isArray(l4) && (l4 = Uint8Array.from(l4))), !(l4 instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
    if (l4.length === 0) return "";
    for (var p3 = 0, E4 = 0, D3 = 0, f3 = l4.length; D3 !== f3 && l4[D3] === 0; ) D3++, p3++;
    for (var N2 = (f3 - D3) * d3 + 1 >>> 0, C2 = new Uint8Array(N2); D3 !== f3; ) {
      for (var L2 = l4[D3], $2 = 0, x4 = N2 - 1; (L2 !== 0 || $2 < E4) && x4 !== -1; x4--, $2++) L2 += 256 * C2[x4] >>> 0, C2[x4] = L2 % a4 >>> 0, L2 = L2 / a4 >>> 0;
      if (L2 !== 0) throw new Error("Non-zero carry");
      E4 = $2, D3++;
    }
    for (var k3 = N2 - E4; k3 !== N2 && C2[k3] === 0; ) k3++;
    for (var ie = c5.repeat(p3); k3 < N2; ++k3) ie += o5.charAt(C2[k3]);
    return ie;
  }
  function m2(l4) {
    if (typeof l4 != "string") throw new TypeError("Expected String");
    if (l4.length === 0) return new Uint8Array();
    var p3 = 0;
    if (l4[p3] !== " ") {
      for (var E4 = 0, D3 = 0; l4[p3] === c5; ) E4++, p3++;
      for (var f3 = (l4.length - p3) * h4 + 1 >>> 0, N2 = new Uint8Array(f3); l4[p3]; ) {
        var C2 = t[l4.charCodeAt(p3)];
        if (C2 === 255) return;
        for (var L2 = 0, $2 = f3 - 1; (C2 !== 0 || L2 < D3) && $2 !== -1; $2--, L2++) C2 += a4 * N2[$2] >>> 0, N2[$2] = C2 % 256 >>> 0, C2 = C2 / 256 >>> 0;
        if (C2 !== 0) throw new Error("Non-zero carry");
        D3 = L2, p3++;
      }
      if (l4[p3] !== " ") {
        for (var x4 = f3 - D3; x4 !== f3 && N2[x4] === 0; ) x4++;
        for (var k3 = new Uint8Array(E4 + (f3 - x4)), ie = E4; x4 !== f3; ) k3[ie++] = N2[x4++];
        return k3;
      }
    }
  }
  function b3(l4) {
    var p3 = m2(l4);
    if (p3) return p3;
    throw new Error(`Non-${e2} character`);
  }
  return { encode: g3, decodeUnsafe: m2, decode: b3 };
}
var Os = xs2;
var As2 = Os;
var Nt = (o5) => {
  if (o5 instanceof Uint8Array && o5.constructor.name === "Uint8Array") return o5;
  if (o5 instanceof ArrayBuffer) return new Uint8Array(o5);
  if (ArrayBuffer.isView(o5)) return new Uint8Array(o5.buffer, o5.byteOffset, o5.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var Ns2 = (o5) => new TextEncoder().encode(o5);
var Ls = (o5) => new TextDecoder().decode(o5);
var zs = class {
  constructor(e2, t, s2) {
    this.name = e2, this.prefix = t, this.baseEncode = s2;
  }
  encode(e2) {
    if (e2 instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e2)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var ks = class {
  constructor(e2, t, s2) {
    if (this.name = e2, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = s2;
  }
  decode(e2) {
    if (typeof e2 == "string") {
      if (e2.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e2.slice(this.prefix.length));
    } else throw Error("Can only multibase decode strings");
  }
  or(e2) {
    return Lt2(this, e2);
  }
};
var Ms2 = class {
  constructor(e2) {
    this.decoders = e2;
  }
  or(e2) {
    return Lt2(this, e2);
  }
  decode(e2) {
    const t = e2[0], s2 = this.decoders[t];
    if (s2) return s2.decode(e2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var Lt2 = (o5, e2) => new Ms2({ ...o5.decoders || { [o5.prefix]: o5 }, ...e2.decoders || { [e2.prefix]: e2 } });
var $s = class {
  constructor(e2, t, s2, i3) {
    this.name = e2, this.prefix = t, this.baseEncode = s2, this.baseDecode = i3, this.encoder = new zs(e2, t, s2), this.decoder = new ks(e2, t, i3);
  }
  encode(e2) {
    return this.encoder.encode(e2);
  }
  decode(e2) {
    return this.decoder.decode(e2);
  }
};
var ae = ({ name: o5, prefix: e2, encode: t, decode: s2 }) => new $s(o5, e2, t, s2);
var Q = ({ prefix: o5, name: e2, alphabet: t }) => {
  const { encode: s2, decode: i3 } = As2(t, e2);
  return ae({ prefix: o5, name: e2, encode: s2, decode: (r3) => Nt(i3(r3)) });
};
var Fs = (o5, e2, t, s2) => {
  const i3 = {};
  for (let d3 = 0; d3 < e2.length; ++d3) i3[e2[d3]] = d3;
  let r3 = o5.length;
  for (; o5[r3 - 1] === "="; ) --r3;
  const n4 = new Uint8Array(r3 * t / 8 | 0);
  let a4 = 0, c5 = 0, h4 = 0;
  for (let d3 = 0; d3 < r3; ++d3) {
    const g3 = i3[o5[d3]];
    if (g3 === void 0) throw new SyntaxError(`Non-${s2} character`);
    c5 = c5 << t | g3, a4 += t, a4 >= 8 && (a4 -= 8, n4[h4++] = 255 & c5 >> a4);
  }
  if (a4 >= t || 255 & c5 << 8 - a4) throw new SyntaxError("Unexpected end of data");
  return n4;
};
var Us = (o5, e2, t) => {
  const s2 = e2[e2.length - 1] === "=", i3 = (1 << t) - 1;
  let r3 = "", n4 = 0, a4 = 0;
  for (let c5 = 0; c5 < o5.length; ++c5) for (a4 = a4 << 8 | o5[c5], n4 += 8; n4 > t; ) n4 -= t, r3 += e2[i3 & a4 >> n4];
  if (n4 && (r3 += e2[i3 & a4 << t - n4]), s2) for (; r3.length * t & 7; ) r3 += "=";
  return r3;
};
var _2 = ({ name: o5, prefix: e2, bitsPerChar: t, alphabet: s2 }) => ae({ prefix: e2, name: o5, encode(i3) {
  return Us(i3, s2, t);
}, decode(i3) {
  return Fs(i3, s2, t, o5);
} });
var Ks = ae({ prefix: "\0", name: "identity", encode: (o5) => Ls(o5), decode: (o5) => Ns2(o5) });
var Bs = Object.freeze({ __proto__: null, identity: Ks });
var Vs = _2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var js = Object.freeze({ __proto__: null, base2: Vs });
var qs = _2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var Gs = Object.freeze({ __proto__: null, base8: qs });
var Hs = Q({ prefix: "9", name: "base10", alphabet: "0123456789" });
var Ys = Object.freeze({ __proto__: null, base10: Hs });
var Js = _2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Ws = _2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Xs = Object.freeze({ __proto__: null, base16: Js, base16upper: Ws });
var Zs = _2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var Qs = _2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var er2 = _2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var tr = _2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var ir = _2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var sr = _2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var rr2 = _2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var nr = _2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var or = _2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var ar = Object.freeze({ __proto__: null, base32: Zs, base32upper: Qs, base32pad: er2, base32padupper: tr, base32hex: ir, base32hexupper: sr, base32hexpad: rr2, base32hexpadupper: nr, base32z: or });
var cr = Q({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var hr = Q({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var lr = Object.freeze({ __proto__: null, base36: cr, base36upper: hr });
var ur = Q({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var dr = Q({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var gr2 = Object.freeze({ __proto__: null, base58btc: ur, base58flickr: dr });
var pr2 = _2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var yr = _2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Dr = _2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var mr = _2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var br = Object.freeze({ __proto__: null, base64: pr2, base64pad: yr, base64url: Dr, base64urlpad: mr });
var zt = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
var fr = zt.reduce((o5, e2, t) => (o5[t] = e2, o5), []);
var _r = zt.reduce((o5, e2, t) => (o5[e2.codePointAt(0)] = t, o5), []);
function Er(o5) {
  return o5.reduce((e2, t) => (e2 += fr[t], e2), "");
}
function vr(o5) {
  const e2 = [];
  for (const t of o5) {
    const s2 = _r[t.codePointAt(0)];
    if (s2 === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e2.push(s2);
  }
  return new Uint8Array(e2);
}
var wr = ae({ prefix: "🚀", name: "base256emoji", encode: Er, decode: vr });
var Ir = Object.freeze({ __proto__: null, base256emoji: wr });
var Tr = Mt;
var kt = 128;
var Cr = 127;
var Sr2 = ~Cr;
var Pr = Math.pow(2, 31);
function Mt(o5, e2, t) {
  e2 = e2 || [], t = t || 0;
  for (var s2 = t; o5 >= Pr; ) e2[t++] = o5 & 255 | kt, o5 /= 128;
  for (; o5 & Sr2; ) e2[t++] = o5 & 255 | kt, o5 >>>= 7;
  return e2[t] = o5 | 0, Mt.bytes = t - s2 + 1, e2;
}
var Rr = we;
var xr = 128;
var $t = 127;
function we(o5, s2) {
  var t = 0, s2 = s2 || 0, i3 = 0, r3 = s2, n4, a4 = o5.length;
  do {
    if (r3 >= a4) throw we.bytes = 0, new RangeError("Could not decode varint");
    n4 = o5[r3++], t += i3 < 28 ? (n4 & $t) << i3 : (n4 & $t) * Math.pow(2, i3), i3 += 7;
  } while (n4 >= xr);
  return we.bytes = r3 - s2, t;
}
var Or = Math.pow(2, 7);
var Ar = Math.pow(2, 14);
var Nr2 = Math.pow(2, 21);
var Lr = Math.pow(2, 28);
var zr = Math.pow(2, 35);
var kr = Math.pow(2, 42);
var Mr = Math.pow(2, 49);
var $r = Math.pow(2, 56);
var Fr = Math.pow(2, 63);
var Ur = function(o5) {
  return o5 < Or ? 1 : o5 < Ar ? 2 : o5 < Nr2 ? 3 : o5 < Lr ? 4 : o5 < zr ? 5 : o5 < kr ? 6 : o5 < Mr ? 7 : o5 < $r ? 8 : o5 < Fr ? 9 : 10;
};
var Kr = { encode: Tr, decode: Rr, encodingLength: Ur };
var Ft = Kr;
var Ut = (o5, e2, t = 0) => (Ft.encode(o5, e2, t), e2);
var Kt = (o5) => Ft.encodingLength(o5);
var Ie = (o5, e2) => {
  const t = e2.byteLength, s2 = Kt(o5), i3 = s2 + Kt(t), r3 = new Uint8Array(i3 + t);
  return Ut(o5, r3, 0), Ut(t, r3, s2), r3.set(e2, i3), new Br(o5, t, e2, r3);
};
var Br = class {
  constructor(e2, t, s2, i3) {
    this.code = e2, this.size = t, this.digest = s2, this.bytes = i3;
  }
};
var Bt = ({ name: o5, code: e2, encode: t }) => new Vr2(o5, e2, t);
var Vr2 = class {
  constructor(e2, t, s2) {
    this.name = e2, this.code = t, this.encode = s2;
  }
  digest(e2) {
    if (e2 instanceof Uint8Array) {
      const t = this.encode(e2);
      return t instanceof Uint8Array ? Ie(this.code, t) : t.then((s2) => Ie(this.code, s2));
    } else throw Error("Unknown type, must be binary type");
  }
};
var Vt = (o5) => async (e2) => new Uint8Array(await crypto.subtle.digest(o5, e2));
var jr = Bt({ name: "sha2-256", code: 18, encode: Vt("SHA-256") });
var qr = Bt({ name: "sha2-512", code: 19, encode: Vt("SHA-512") });
var Gr = Object.freeze({ __proto__: null, sha256: jr, sha512: qr });
var jt = 0;
var Hr = "identity";
var qt = Nt;
var Yr = (o5) => Ie(jt, qt(o5));
var Jr = { code: jt, name: Hr, encode: qt, digest: Yr };
var Wr2 = Object.freeze({ __proto__: null, identity: Jr });
new TextEncoder(), new TextDecoder();
var Gt = { ...Bs, ...js, ...Gs, ...Ys, ...Xs, ...ar, ...lr, ...gr2, ...br, ...Ir };
({ ...Gr, ...Wr2 });
function Xr2(o5 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(o5) : new Uint8Array(o5);
}
function Ht(o5, e2, t, s2) {
  return { name: o5, prefix: e2, encoder: { name: o5, prefix: e2, encode: t }, decoder: { decode: s2 } };
}
var Yt2 = Ht("utf8", "u", (o5) => "u" + new TextDecoder("utf8").decode(o5), (o5) => new TextEncoder().encode(o5.substring(1)));
var Te = Ht("ascii", "a", (o5) => {
  let e2 = "a";
  for (let t = 0; t < o5.length; t++) e2 += String.fromCharCode(o5[t]);
  return e2;
}, (o5) => {
  o5 = o5.substring(1);
  const e2 = Xr2(o5.length);
  for (let t = 0; t < o5.length; t++) e2[t] = o5.charCodeAt(t);
  return e2;
});
var Zr = { utf8: Yt2, "utf-8": Yt2, hex: Gt.base16, latin1: Te, ascii: Te, binary: Te, ...Gt };
function Qr(o5, e2 = "utf8") {
  const t = Zr[e2];
  if (!t) throw new Error(`Unsupported encoding "${e2}"`);
  return (e2 === "utf8" || e2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(o5, "utf8") : t.decoder.decode(`${t.prefix}${o5}`);
}
var Jt = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.keychain = /* @__PURE__ */ new Map(), this.name = tt, this.version = it, this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      if (!this.initialized) {
        const s2 = await this.getKeyChain();
        typeof s2 < "u" && (this.keychain = s2), this.initialized = true;
      }
    }, this.has = (s2) => (this.isInitialized(), this.keychain.has(s2)), this.set = async (s2, i3) => {
      this.isInitialized(), this.keychain.set(s2, i3), await this.persist();
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.keychain.get(s2);
      if (typeof i3 > "u") {
        const { message: r3 } = xe("NO_MATCHING_KEY", `${this.name}: ${s2}`);
        throw new Error(r3);
      }
      return i3;
    }, this.del = async (s2) => {
      this.isInitialized(), this.keychain.delete(s2), await this.persist();
    }, this.core = e2, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setKeyChain(e2) {
    await this.core.storage.setItem(this.storageKey, cs(e2));
  }
  async getKeyChain() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? ls(e2) : void 0;
  }
  async persist() {
    await this.setKeyChain(this.keychain);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Wt = class {
  constructor(e2, t, s2) {
    this.core = e2, this.logger = t, this.name = Qe, this.randomSessionIdentifier = Bu(), this.initialized = false, this.init = async () => {
      this.initialized || (await this.keychain.init(), this.initialized = true);
    }, this.hasKeys = (i3) => (this.isInitialized(), this.keychain.has(i3)), this.getClientId = async () => {
      this.isInitialized();
      const i3 = await this.getClientSeed(), r3 = generateKeyPair(i3);
      return encodeIss(r3.publicKey);
    }, this.generateKeyPair = () => {
      this.isInitialized();
      const i3 = _u();
      return this.setPrivateKey(i3.publicKey, i3.privateKey);
    }, this.signJWT = async (i3) => {
      this.isInitialized();
      const r3 = await this.getClientSeed(), n4 = generateKeyPair(r3), a4 = this.randomSessionIdentifier, c5 = et;
      return await signJWT(a4, i3, c5, n4);
    }, this.generateSharedKey = (i3, r3, n4) => {
      this.isInitialized();
      const a4 = this.getPrivateKey(i3), c5 = Cu(a4, r3);
      return this.setSymKey(c5, n4);
    }, this.setSymKey = async (i3, r3) => {
      this.isInitialized();
      const n4 = r3 || Ru(i3);
      return await this.keychain.set(n4, i3), n4;
    }, this.deleteKeyPair = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.deleteSymKey = async (i3) => {
      this.isInitialized(), await this.keychain.del(i3);
    }, this.encode = async (i3, r3, n4) => {
      this.isInitialized();
      const a4 = so(n4), c5 = safeJsonStringify(r3);
      if (qu(a4)) return Tu(c5, n4 == null ? void 0 : n4.encoding);
      if (ku(a4)) {
        const m2 = a4.senderPublicKey, b3 = a4.receiverPublicKey;
        i3 = await this.generateSharedKey(m2, b3);
      }
      const h4 = this.getSymKey(i3), { type: d3, senderPublicKey: g3 } = a4;
      return Pu({ type: d3, symKey: h4, message: c5, senderPublicKey: g3, encoding: n4 == null ? void 0 : n4.encoding });
    }, this.decode = async (i3, r3, n4) => {
      this.isInitialized();
      const a4 = Uu(r3, n4);
      if (qu(a4)) {
        const c5 = Fu(r3, n4 == null ? void 0 : n4.encoding);
        return safeJsonParse(c5);
      }
      if (ku(a4)) {
        const c5 = a4.receiverPublicKey, h4 = a4.senderPublicKey;
        i3 = await this.generateSharedKey(c5, h4);
      }
      try {
        const c5 = this.getSymKey(i3), h4 = Du({ symKey: c5, encoded: r3, encoding: n4 == null ? void 0 : n4.encoding });
        return safeJsonParse(h4);
      } catch (c5) {
        this.logger.error(`Failed to decode message from topic: '${i3}', clientId: '${await this.getClientId()}'`), this.logger.error(c5);
      }
    }, this.getPayloadType = (i3, r3 = tn) => {
      const n4 = Wr({ encoded: i3, encoding: r3 });
      return Ze(n4.type);
    }, this.getPayloadSenderPublicKey = (i3, r3 = tn) => {
      const n4 = Wr({ encoded: i3, encoding: r3 });
      return n4.senderPublicKey ? toString(n4.senderPublicKey, Lt) : void 0;
    }, this.core = e2, this.logger = E(t, this.name), this.keychain = s2 || new Jt(this.core, this.logger);
  }
  get context() {
    return y(this.logger);
  }
  async setPrivateKey(e2, t) {
    return await this.keychain.set(e2, t), e2;
  }
  getPrivateKey(e2) {
    return this.keychain.get(e2);
  }
  async getClientSeed() {
    let e2 = "";
    try {
      e2 = this.keychain.get(_e);
    } catch {
      e2 = Bu(), await this.keychain.set(_e, e2);
    }
    return Qr(e2, "base16");
  }
  getSymKey(e2) {
    return this.keychain.get(e2);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var Xt = class extends a2 {
  constructor(e2, t) {
    super(e2, t), this.logger = e2, this.core = t, this.messages = /* @__PURE__ */ new Map(), this.name = st, this.version = rt, this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      if (!this.initialized) {
        this.logger.trace("Initialized");
        try {
          const s2 = await this.getRelayerMessages();
          typeof s2 < "u" && (this.messages = s2), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
        } catch (s2) {
          this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(s2);
        } finally {
          this.initialized = true;
        }
      }
    }, this.set = async (s2, i3) => {
      this.isInitialized();
      const r3 = Ou(i3);
      let n4 = this.messages.get(s2);
      return typeof n4 > "u" && (n4 = {}), typeof n4[r3] < "u" || (n4[r3] = i3, this.messages.set(s2, n4), await this.persist()), r3;
    }, this.get = (s2) => {
      this.isInitialized();
      let i3 = this.messages.get(s2);
      return typeof i3 > "u" && (i3 = {}), i3;
    }, this.has = (s2, i3) => {
      this.isInitialized();
      const r3 = this.get(s2), n4 = Ou(i3);
      return typeof r3[n4] < "u";
    }, this.del = async (s2) => {
      this.isInitialized(), this.messages.delete(s2), await this.persist();
    }, this.logger = E(e2, this.name), this.core = t;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  async setRelayerMessages(e2) {
    await this.core.storage.setItem(this.storageKey, cs(e2));
  }
  async getRelayerMessages() {
    const e2 = await this.core.storage.getItem(this.storageKey);
    return typeof e2 < "u" ? ls(e2) : void 0;
  }
  async persist() {
    await this.setRelayerMessages(this.messages);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var en = class extends g {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.events = new import_events7.EventEmitter(), this.name = ot, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), this.failedPublishTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND), this.needsTransportRestart = false, this.publish = async (s2, i3, r3) => {
      var n4;
      this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: s2, message: i3, opts: r3 } });
      const a4 = (r3 == null ? void 0 : r3.ttl) || nt, c5 = zu(r3), h4 = (r3 == null ? void 0 : r3.prompt) || false, d3 = (r3 == null ? void 0 : r3.tag) || 0, g3 = (r3 == null ? void 0 : r3.id) || getBigIntRpcId().toString(), m2 = { topic: s2, message: i3, opts: { ttl: a4, relay: c5, prompt: h4, tag: d3, id: g3, attestation: r3 == null ? void 0 : r3.attestation } }, b3 = `Failed to publish payload, please try again. id:${g3} tag:${d3}`, l4 = Date.now();
      let p3, E4 = 1;
      try {
        for (; p3 === void 0; ) {
          if (Date.now() - l4 > this.publishTimeout) throw new Error(b3);
          this.logger.trace({ id: g3, attempts: E4 }, `publisher.publish - attempt ${E4}`), p3 = await await ms(this.rpcPublish(s2, i3, a4, c5, h4, d3, g3, r3 == null ? void 0 : r3.attestation).catch((D3) => this.logger.warn(D3)), this.publishTimeout, b3), E4++, p3 || await new Promise((D3) => setTimeout(D3, this.failedPublishTimeout));
        }
        this.relayer.events.emit(w2.publish, m2), this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { id: g3, topic: s2, message: i3, opts: r3 } });
      } catch (D3) {
        if (this.logger.debug("Failed to Publish Payload"), this.logger.error(D3), (n4 = r3 == null ? void 0 : r3.internal) != null && n4.throwOnFailedPublish) throw D3;
        this.queue.set(g3, m2);
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.relayer = e2, this.logger = E(t, this.name), this.registerEventListeners();
  }
  get context() {
    return y(this.logger);
  }
  rpcPublish(e2, t, s2, i3, r3, n4, a4, c5) {
    var h4, d3, g3, m2;
    const b3 = { method: ju(i3.protocol).publish, params: { topic: e2, message: t, ttl: s2, prompt: r3, tag: n4, attestation: c5 }, id: a4 };
    return Pe((h4 = b3.params) == null ? void 0 : h4.prompt) && ((d3 = b3.params) == null || delete d3.prompt), Pe((g3 = b3.params) == null ? void 0 : g3.tag) && ((m2 = b3.params) == null || delete m2.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: b3 }), this.relayer.request(b3);
  }
  removeRequestFromQueue(e2) {
    this.queue.delete(e2);
  }
  checkQueue() {
    this.queue.forEach(async (e2) => {
      const { topic: t, message: s2, opts: i3 } = e2;
      await this.publish(t, s2, i3);
    });
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, () => {
      if (this.needsTransportRestart) {
        this.needsTransportRestart = false, this.relayer.events.emit(w2.connection_stalled);
        return;
      }
      this.checkQueue();
    }), this.relayer.on(w2.message_ack, (e2) => {
      this.removeRequestFromQueue(e2.id.toString());
    });
  }
};
var tn2 = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map(), this.set = (e2, t) => {
      const s2 = this.get(e2);
      this.exists(e2, t) || this.map.set(e2, [...s2, t]);
    }, this.get = (e2) => this.map.get(e2) || [], this.exists = (e2, t) => this.get(e2).includes(t), this.delete = (e2, t) => {
      if (typeof t > "u") {
        this.map.delete(e2);
        return;
      }
      if (!this.map.has(e2)) return;
      const s2 = this.get(e2);
      if (!this.exists(e2, t)) return;
      const i3 = s2.filter((r3) => r3 !== t);
      if (!i3.length) {
        this.map.delete(e2);
        return;
      }
      this.map.set(e2, i3);
    }, this.clear = () => {
      this.map.clear();
    };
  }
  get topics() {
    return Array.from(this.map.keys());
  }
};
var sn = Object.defineProperty;
var rn = Object.defineProperties;
var nn = Object.getOwnPropertyDescriptors;
var Zt = Object.getOwnPropertySymbols;
var on2 = Object.prototype.hasOwnProperty;
var an = Object.prototype.propertyIsEnumerable;
var Qt = (o5, e2, t) => e2 in o5 ? sn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var ee = (o5, e2) => {
  for (var t in e2 || (e2 = {})) on2.call(e2, t) && Qt(o5, t, e2[t]);
  if (Zt) for (var t of Zt(e2)) an.call(e2, t) && Qt(o5, t, e2[t]);
  return o5;
};
var Ce = (o5, e2) => rn(o5, nn(e2));
var ei = class extends d {
  constructor(e2, t) {
    super(e2, t), this.relayer = e2, this.logger = t, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new tn2(), this.events = new import_events7.EventEmitter(), this.name = pt, this.version = yt, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O2, this.subscribeTimeout = (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.pendingBatchMessages = [], this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId(), await this.restore()), this.initialized = true;
    }, this.subscribe = async (s2, i3) => {
      this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } });
      try {
        const r3 = zu(i3), n4 = { topic: s2, relay: r3, transportType: i3 == null ? void 0 : i3.transportType };
        this.pending.set(s2, n4);
        const a4 = await this.rpcSubscribe(s2, r3, i3 == null ? void 0 : i3.transportType);
        return typeof a4 == "string" && (this.onSubscribe(a4, n4), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: s2, opts: i3 } })), a4;
      } catch (r3) {
        throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(r3), r3;
      }
    }, this.unsubscribe = async (s2, i3) => {
      await this.restartToComplete(), this.isInitialized(), typeof (i3 == null ? void 0 : i3.id) < "u" ? await this.unsubscribeById(s2, i3.id, i3) : await this.unsubscribeByTopic(s2, i3);
    }, this.isSubscribed = async (s2) => {
      if (this.topics.includes(s2)) return true;
      const i3 = `${this.pendingSubscriptionWatchLabel}_${s2}`;
      return await new Promise((r3, n4) => {
        const a4 = new import_time2.Watch();
        a4.start(i3);
        const c5 = setInterval(() => {
          !this.pending.has(s2) && this.topics.includes(s2) && (clearInterval(c5), a4.stop(i3), r3(true)), a4.elapsed(i3) >= Dt && (clearInterval(c5), a4.stop(i3), n4(new Error("Subscription resolution timeout")));
        }, this.pollingInterval);
      }).catch(() => false);
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.start = async () => {
      await this.onConnect();
    }, this.stop = async () => {
      await this.onDisconnect();
    }, this.restart = async () => {
      this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
    }, this.relayer = e2, this.logger = E(t, this.name), this.clientId = "";
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.subscriptions.size;
  }
  get ids() {
    return Array.from(this.subscriptions.keys());
  }
  get values() {
    return Array.from(this.subscriptions.values());
  }
  get topics() {
    return this.topicMap.topics;
  }
  hasSubscription(e2, t) {
    let s2 = false;
    try {
      s2 = this.getSubscription(e2).topic === t;
    } catch {
    }
    return s2;
  }
  onEnable() {
    this.cached = [], this.initialized = true;
  }
  onDisable() {
    this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
  }
  async unsubscribeByTopic(e2, t) {
    const s2 = this.topicMap.get(e2);
    await Promise.all(s2.map(async (i3) => await this.unsubscribeById(e2, i3, t)));
  }
  async unsubscribeById(e2, t, s2) {
    this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: s2 } });
    try {
      const i3 = zu(s2);
      await this.rpcUnsubscribe(e2, t, i3);
      const r3 = er("USER_DISCONNECTED", `${this.name}, ${e2}`);
      await this.onUnsubscribe(e2, t, r3), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e2, id: t, opts: s2 } });
    } catch (i3) {
      throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(i3), i3;
    }
  }
  async rpcSubscribe(e2, t, s2 = F.relay) {
    s2 === F.relay && await this.restartToComplete();
    const i3 = { method: ju(t.protocol).subscribe, params: { topic: e2 } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 });
    try {
      const r3 = Ou(e2 + this.clientId);
      return s2 === F.link_mode ? (setTimeout(() => {
        (this.relayer.connected || this.relayer.connecting) && this.relayer.request(i3).catch((n4) => this.logger.warn(n4));
      }, (0, import_time2.toMiliseconds)(import_time2.ONE_SECOND)), r3) : await await ms(this.relayer.request(i3).catch((n4) => this.logger.warn(n4)), this.subscribeTimeout) ? r3 : null;
    } catch {
      this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(w2.connection_stalled);
    }
    return null;
  }
  async rpcBatchSubscribe(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, s2 = { method: ju(t.protocol).batchSubscribe, params: { topics: e2.map((i3) => i3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    try {
      return await await ms(this.relayer.request(s2).catch((i3) => this.logger.warn(i3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w2.connection_stalled);
    }
  }
  async rpcBatchFetchMessages(e2) {
    if (!e2.length) return;
    const t = e2[0].relay, s2 = { method: ju(t.protocol).batchFetchMessages, params: { topics: e2.map((r3) => r3.topic) } };
    this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s2 });
    let i3;
    try {
      i3 = await await ms(this.relayer.request(s2).catch((r3) => this.logger.warn(r3)), this.subscribeTimeout);
    } catch {
      this.relayer.events.emit(w2.connection_stalled);
    }
    return i3;
  }
  rpcUnsubscribe(e2, t, s2) {
    const i3 = { method: ju(s2.protocol).unsubscribe, params: { topic: e2, id: t } };
    return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i3 }), this.relayer.request(i3);
  }
  onSubscribe(e2, t) {
    this.setSubscription(e2, Ce(ee({}, t), { id: e2 })), this.pending.delete(t.topic);
  }
  onBatchSubscribe(e2) {
    e2.length && e2.forEach((t) => {
      this.setSubscription(t.id, ee({}, t)), this.pending.delete(t.topic);
    });
  }
  async onUnsubscribe(e2, t, s2) {
    this.events.removeAllListeners(t), this.hasSubscription(t, e2) && this.deleteSubscription(t, s2), await this.relayer.messages.del(e2);
  }
  async setRelayerSubscriptions(e2) {
    await this.relayer.core.storage.setItem(this.storageKey, e2);
  }
  async getRelayerSubscriptions() {
    return await this.relayer.core.storage.getItem(this.storageKey);
  }
  setSubscription(e2, t) {
    this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e2, subscription: t }), this.addSubscription(e2, t);
  }
  addSubscription(e2, t) {
    this.subscriptions.set(e2, ee({}, t)), this.topicMap.set(t.topic, e2), this.events.emit(A2.created, t);
  }
  getSubscription(e2) {
    this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e2 });
    const t = this.subscriptions.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(s2);
    }
    return t;
  }
  deleteSubscription(e2, t) {
    this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e2, reason: t });
    const s2 = this.getSubscription(e2);
    this.subscriptions.delete(e2), this.topicMap.delete(s2.topic, e2), this.events.emit(A2.deleted, Ce(ee({}, s2), { reason: t }));
  }
  async persist() {
    await this.setRelayerSubscriptions(this.values), this.events.emit(A2.sync);
  }
  async reset() {
    if (this.cached.length) {
      const e2 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
      for (let t = 0; t < e2; t++) {
        const s2 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
        await this.batchFetchMessages(s2), await this.batchSubscribe(s2);
      }
    }
    this.events.emit(A2.resubscribed);
  }
  async restore() {
    try {
      const e2 = await this.getRelayerSubscriptions();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.subscriptions.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e2);
    }
  }
  async batchSubscribe(e2) {
    if (!e2.length) return;
    const t = await this.rpcBatchSubscribe(e2);
    Nr(t) && this.onBatchSubscribe(t.map((s2, i3) => Ce(ee({}, e2[i3]), { id: s2 })));
  }
  async batchFetchMessages(e2) {
    if (!e2.length) return;
    this.logger.trace(`Fetching batch messages for ${e2.length} subscriptions`);
    const t = await this.rpcBatchFetchMessages(e2);
    t && t.messages && (this.pendingBatchMessages = this.pendingBatchMessages.concat(t.messages));
  }
  async onConnect() {
    await this.restart(), this.onEnable();
  }
  onDisconnect() {
    this.onDisable();
  }
  async checkPending() {
    if (!this.initialized || !this.relayer.connected) return;
    const e2 = [];
    this.pending.forEach((t) => {
      e2.push(t);
    }), await this.batchSubscribe(e2), this.pendingBatchMessages.length && (await this.relayer.handleBatchMessageEvents(this.pendingBatchMessages), this.pendingBatchMessages = []);
  }
  registerEventListeners() {
    this.relayer.core.heartbeat.on(r.pulse, async () => {
      await this.checkPending();
    }), this.events.on(A2.created, async (e2) => {
      const t = A2.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    }), this.events.on(A2.deleted, async (e2) => {
      const t = A2.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), await this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async restartToComplete() {
    !this.relayer.connected && !this.relayer.connecting && await this.relayer.transportOpen(), this.restartInProgress && await new Promise((e2) => {
      const t = setInterval(() => {
        this.restartInProgress || (clearInterval(t), e2());
      }, this.pollingInterval);
    });
  }
};
var cn = Object.defineProperty;
var ti = Object.getOwnPropertySymbols;
var hn = Object.prototype.hasOwnProperty;
var ln = Object.prototype.propertyIsEnumerable;
var ii = (o5, e2, t) => e2 in o5 ? cn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var un = (o5, e2) => {
  for (var t in e2 || (e2 = {})) hn.call(e2, t) && ii(o5, t, e2[t]);
  if (ti) for (var t of ti(e2)) ln.call(e2, t) && ii(o5, t, e2[t]);
  return o5;
};
var si = class extends u {
  constructor(e2) {
    super(e2), this.protocol = "wc", this.version = 2, this.events = new import_events7.EventEmitter(), this.name = ht, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "stalled", "interrupted"], this.hasExperiencedNetworkDisruption = false, this.requestsInFlight = /* @__PURE__ */ new Map(), this.heartBeatTimeout = (0, import_time2.toMiliseconds)(import_time2.THIRTY_SECONDS + import_time2.ONE_SECOND), this.request = async (t) => {
      var s2, i3;
      this.logger.debug("Publishing Request Payload");
      const r3 = t.id || getBigIntRpcId().toString();
      await this.toEstablishConnection();
      try {
        const n4 = this.provider.request(t);
        this.requestsInFlight.set(r3, { promise: n4, request: t }), this.logger.trace({ id: r3, method: t.method, topic: (s2 = t.params) == null ? void 0 : s2.topic }, "relayer.request - attempt to publish...");
        const a4 = await new Promise(async (c5, h4) => {
          const d3 = () => {
            h4(new Error(`relayer.request - publish interrupted, id: ${r3}`));
          };
          this.provider.on(T.disconnect, d3);
          const g3 = await n4;
          this.provider.off(T.disconnect, d3), c5(g3);
        });
        return this.logger.trace({ id: r3, method: t.method, topic: (i3 = t.params) == null ? void 0 : i3.topic }, "relayer.request - published"), a4;
      } catch (n4) {
        throw this.logger.debug(`Failed to Publish Request: ${r3}`), n4;
      } finally {
        this.requestsInFlight.delete(r3);
      }
    }, this.resetPingTimeout = () => {
      if (bi()) try {
        clearTimeout(this.pingTimeout), this.pingTimeout = setTimeout(() => {
          var t, s2, i3;
          (i3 = (s2 = (t = this.provider) == null ? void 0 : t.connection) == null ? void 0 : s2.socket) == null || i3.terminate();
        }, this.heartBeatTimeout);
      } catch (t) {
        this.logger.warn(t);
      }
    }, this.onPayloadHandler = (t) => {
      this.onProviderPayload(t), this.resetPingTimeout();
    }, this.onConnectHandler = () => {
      this.logger.trace("relayer connected"), this.startPingTimeout(), this.events.emit(w2.connect);
    }, this.onDisconnectHandler = () => {
      this.logger.trace("relayer disconnected"), this.onProviderDisconnect();
    }, this.onProviderErrorHandler = (t) => {
      this.logger.error(t), this.events.emit(w2.error, t), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
    }, this.registerProviderListeners = () => {
      this.provider.on(T.payload, this.onPayloadHandler), this.provider.on(T.connect, this.onConnectHandler), this.provider.on(T.disconnect, this.onDisconnectHandler), this.provider.on(T.error, this.onProviderErrorHandler);
    }, this.core = e2.core, this.logger = typeof e2.logger < "u" && typeof e2.logger != "string" ? E(e2.logger, this.name) : (0, import_pino.default)(k({ level: e2.logger || ct })), this.messages = new Xt(this.logger, e2.core), this.subscriber = new ei(this, this.logger), this.publisher = new en(this, this.logger), this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ee, this.projectId = e2.projectId, this.bundleId = ns(), this.provider = {};
  }
  async init() {
    if (this.logger.trace("Initialized"), this.registerEventListeners(), await Promise.all([this.messages.init(), this.subscriber.init()]), this.initialized = true, this.subscriber.cached.length > 0) try {
      await this.transportOpen();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  get context() {
    return y(this.logger);
  }
  get connected() {
    var e2, t, s2;
    return ((s2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 1;
  }
  get connecting() {
    var e2, t, s2;
    return ((s2 = (t = (e2 = this.provider) == null ? void 0 : e2.connection) == null ? void 0 : t.socket) == null ? void 0 : s2.readyState) === 0;
  }
  async publish(e2, t, s2) {
    this.isInitialized(), await this.publisher.publish(e2, t, s2), await this.recordMessageEvent({ topic: e2, message: t, publishedAt: Date.now(), transportType: F.relay });
  }
  async subscribe(e2, t) {
    var s2;
    this.isInitialized(), (t == null ? void 0 : t.transportType) === "relay" && await this.toEstablishConnection();
    let i3 = ((s2 = this.subscriber.topicMap.get(e2)) == null ? void 0 : s2[0]) || "", r3;
    const n4 = (a4) => {
      a4.topic === e2 && (this.subscriber.off(A2.created, n4), r3());
    };
    return await Promise.all([new Promise((a4) => {
      r3 = a4, this.subscriber.on(A2.created, n4);
    }), new Promise(async (a4) => {
      i3 = await this.subscriber.subscribe(e2, t) || i3, a4();
    })]), i3;
  }
  async unsubscribe(e2, t) {
    this.isInitialized(), await this.subscriber.unsubscribe(e2, t);
  }
  on(e2, t) {
    this.events.on(e2, t);
  }
  once(e2, t) {
    this.events.once(e2, t);
  }
  off(e2, t) {
    this.events.off(e2, t);
  }
  removeListener(e2, t) {
    this.events.removeListener(e2, t);
  }
  async transportDisconnect() {
    if (!this.hasExperiencedNetworkDisruption && this.connected && this.requestsInFlight.size > 0) try {
      await Promise.all(Array.from(this.requestsInFlight.values()).map((e2) => e2.promise));
    } catch (e2) {
      this.logger.warn(e2);
    }
    this.hasExperiencedNetworkDisruption || this.connected ? await ms(this.provider.disconnect(), 2e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.onProviderDisconnect();
  }
  async transportClose() {
    this.transportExplicitlyClosed = true, await this.transportDisconnect();
  }
  async transportOpen(e2) {
    await this.confirmOnlineStateOrThrow(), e2 && e2 !== this.relayUrl && (this.relayUrl = e2, await this.transportDisconnect()), await this.createProvider(), this.connectionAttemptInProgress = true, this.transportExplicitlyClosed = false;
    try {
      await new Promise(async (t, s2) => {
        const i3 = () => {
          this.provider.off(T.disconnect, i3), s2(new Error("Connection interrupted while trying to subscribe"));
        };
        this.provider.on(T.disconnect, i3), await ms(this.provider.connect(), (0, import_time2.toMiliseconds)(import_time2.ONE_MINUTE), `Socket stalled when trying to connect to ${this.relayUrl}`).catch((r3) => {
          s2(r3);
        }).finally(() => {
          clearTimeout(this.reconnectTimeout), this.reconnectTimeout = void 0;
        }), this.subscriber.start().catch((r3) => {
          this.logger.error(r3), this.onDisconnectHandler();
        }), this.hasExperiencedNetworkDisruption = false, t();
      });
    } catch (t) {
      this.logger.error(t);
      const s2 = t;
      if (this.hasExperiencedNetworkDisruption = true, !this.isConnectionStalled(s2.message)) throw t;
    } finally {
      this.connectionAttemptInProgress = false;
    }
  }
  async restartTransport(e2) {
    this.connectionAttemptInProgress || (this.relayUrl = e2 || this.relayUrl, await this.confirmOnlineStateOrThrow(), await this.transportClose(), await this.transportOpen());
  }
  async confirmOnlineStateOrThrow() {
    if (!await Bh()) throw new Error("No internet connection detected. Please restart your network and try again.");
  }
  async handleBatchMessageEvents(e2) {
    if ((e2 == null ? void 0 : e2.length) === 0) {
      this.logger.trace("Batch message events is empty. Ignoring...");
      return;
    }
    const t = e2.sort((s2, i3) => s2.publishedAt - i3.publishedAt);
    this.logger.trace(`Batch of ${t.length} message events sorted`);
    for (const s2 of t) try {
      await this.onMessageEvent(s2);
    } catch (i3) {
      this.logger.warn(i3);
    }
    this.logger.trace(`Batch of ${t.length} message events processed`);
  }
  async onLinkMessageEvent(e2, t) {
    const { topic: s2 } = e2;
    if (!t.sessionExists) {
      const i3 = ws(import_time2.FIVE_MINUTES), r3 = { topic: s2, expiry: i3, relay: { protocol: "irn" }, active: false };
      await this.core.pairing.pairings.set(s2, r3);
    }
    this.events.emit(w2.message, e2), await this.recordMessageEvent(e2);
  }
  startPingTimeout() {
    var e2, t, s2, i3, r3;
    if (bi()) try {
      (t = (e2 = this.provider) == null ? void 0 : e2.connection) != null && t.socket && ((r3 = (i3 = (s2 = this.provider) == null ? void 0 : s2.connection) == null ? void 0 : i3.socket) == null || r3.once("ping", () => {
        this.resetPingTimeout();
      })), this.resetPingTimeout();
    } catch (n4) {
      this.logger.warn(n4);
    }
  }
  isConnectionStalled(e2) {
    return this.staleConnectionErrors.some((t) => e2.includes(t));
  }
  async createProvider() {
    this.provider.connection && this.unregisterProviderListeners();
    const e2 = await this.core.crypto.signJWT(this.relayUrl);
    this.provider = new o3(new f(ss({ sdkVersion: oe, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e2, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
  }
  async recordMessageEvent(e2) {
    const { topic: t, message: s2 } = e2;
    await this.messages.set(t, s2);
  }
  async shouldIgnoreMessageEvent(e2) {
    const { topic: t, message: s2 } = e2;
    if (!s2 || s2.length === 0) return this.logger.debug(`Ignoring invalid/empty message: ${s2}`), true;
    if (!await this.subscriber.isSubscribed(t)) return this.logger.debug(`Ignoring message for non-subscribed topic ${t}`), true;
    const i3 = this.messages.has(t, s2);
    return i3 && this.logger.debug(`Ignoring duplicate message: ${s2}`), i3;
  }
  async onProviderPayload(e2) {
    if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e2 }), isJsonRpcRequest(e2)) {
      if (!e2.method.endsWith(lt)) return;
      const t = e2.params, { topic: s2, message: i3, publishedAt: r3, attestation: n4 } = t.data, a4 = { topic: s2, message: i3, publishedAt: r3, transportType: F.relay, attestation: n4 };
      this.logger.debug("Emitting Relayer Payload"), this.logger.trace(un({ type: "event", event: t.id }, a4)), this.events.emit(t.id, a4), await this.acknowledgePayload(e2), await this.onMessageEvent(a4);
    } else isJsonRpcResponse(e2) && this.events.emit(w2.message_ack, e2);
  }
  async onMessageEvent(e2) {
    await this.shouldIgnoreMessageEvent(e2) || (this.events.emit(w2.message, e2), await this.recordMessageEvent(e2));
  }
  async acknowledgePayload(e2) {
    const t = formatJsonRpcResult(e2.id, true);
    await this.provider.connection.send(t);
  }
  unregisterProviderListeners() {
    this.provider.off(T.payload, this.onPayloadHandler), this.provider.off(T.connect, this.onConnectHandler), this.provider.off(T.disconnect, this.onDisconnectHandler), this.provider.off(T.error, this.onProviderErrorHandler), clearTimeout(this.pingTimeout);
  }
  async registerEventListeners() {
    let e2 = await Bh();
    Ch(async (t) => {
      e2 !== t && (e2 = t, t ? await this.restartTransport().catch((s2) => this.logger.error(s2)) : (this.hasExperiencedNetworkDisruption = true, await this.transportDisconnect(), this.transportExplicitlyClosed = false));
    });
  }
  async onProviderDisconnect() {
    await this.subscriber.stop(), this.requestsInFlight.clear(), clearTimeout(this.pingTimeout), this.events.emit(w2.disconnect), this.connectionAttemptInProgress = false, !this.transportExplicitlyClosed && (this.reconnectTimeout || (this.reconnectTimeout = setTimeout(async () => {
      await this.transportOpen().catch((e2) => this.logger.error(e2));
    }, (0, import_time2.toMiliseconds)(ut))));
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  async toEstablishConnection() {
    await this.confirmOnlineStateOrThrow(), !this.connected && (this.connectionAttemptInProgress && await new Promise((e2) => {
      const t = setInterval(() => {
        this.connected && (clearInterval(t), e2());
      }, this.connectionStatusPollingInterval);
    }), await this.transportOpen());
  }
};
var dn = Object.defineProperty;
var ri = Object.getOwnPropertySymbols;
var gn = Object.prototype.hasOwnProperty;
var pn = Object.prototype.propertyIsEnumerable;
var ni = (o5, e2, t) => e2 in o5 ? dn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var oi = (o5, e2) => {
  for (var t in e2 || (e2 = {})) gn.call(e2, t) && ni(o5, t, e2[t]);
  if (ri) for (var t of ri(e2)) pn.call(e2, t) && ni(o5, t, e2[t]);
  return o5;
};
var ai = class extends p {
  constructor(e2, t, s2, i3 = O2, r3 = void 0) {
    super(e2, t, s2, i3), this.core = e2, this.logger = t, this.name = s2, this.map = /* @__PURE__ */ new Map(), this.version = dt, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.recentlyDeleted = [], this.recentlyDeletedLimit = 200, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((n4) => {
        this.getKey && n4 !== null && !Pe(n4) ? this.map.set(this.getKey(n4), n4) : lh(n4) ? this.map.set(n4.id, n4) : dh(n4) && this.map.set(n4.topic, n4);
      }), this.cached = [], this.initialized = true);
    }, this.set = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) ? await this.update(n4, a4) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: n4, value: a4 }), this.map.set(n4, a4), await this.persist());
    }, this.get = (n4) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: n4 }), this.getData(n4)), this.getAll = (n4) => (this.isInitialized(), n4 ? this.values.filter((a4) => Object.keys(n4).every((c5) => (0, import_lodash.default)(a4[c5], n4[c5]))) : this.values), this.update = async (n4, a4) => {
      this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: n4, update: a4 });
      const c5 = oi(oi({}, this.getData(n4)), a4);
      this.map.set(n4, c5), await this.persist();
    }, this.delete = async (n4, a4) => {
      this.isInitialized(), this.map.has(n4) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: n4, reason: a4 }), this.map.delete(n4), this.addToRecentlyDeleted(n4), await this.persist());
    }, this.logger = E(t, this.name), this.storagePrefix = i3, this.getKey = r3;
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.map.size;
  }
  get keys() {
    return Array.from(this.map.keys());
  }
  get values() {
    return Array.from(this.map.values());
  }
  addToRecentlyDeleted(e2) {
    this.recentlyDeleted.push(e2), this.recentlyDeleted.length >= this.recentlyDeletedLimit && this.recentlyDeleted.splice(0, this.recentlyDeletedLimit / 2);
  }
  async setDataStore(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getDataStore() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getData(e2) {
    const t = this.map.get(e2);
    if (!t) {
      if (this.recentlyDeleted.includes(e2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${this.name}: ${e2}`);
        throw this.logger.error(i3), new Error(i3);
      }
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.error(s2), new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setDataStore(this.values);
  }
  async restore() {
    try {
      const e2 = await this.getDataStore();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.map.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var ci = class {
  constructor(e2, t) {
    this.core = e2, this.logger = t, this.name = mt, this.version = bt, this.events = new import_events7.default(), this.initialized = false, this.storagePrefix = O2, this.ignoredPayloadTypes = [pr], this.registeredMethods = [], this.init = async () => {
      this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
    }, this.register = ({ methods: s2 }) => {
      this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...s2])];
    }, this.create = async (s2) => {
      this.isInitialized();
      const i3 = Bu(), r3 = await this.core.crypto.setSymKey(i3), n4 = ws(import_time2.FIVE_MINUTES), a4 = { protocol: at }, c5 = { topic: r3, expiry: n4, relay: a4, active: false, methods: s2 == null ? void 0 : s2.methods }, h4 = $u({ protocol: this.core.protocol, version: this.core.version, topic: r3, symKey: i3, relay: a4, expiryTimestamp: n4, methods: s2 == null ? void 0 : s2.methods });
      return this.events.emit(q.create, c5), this.core.expirer.set(r3, n4), await this.pairings.set(r3, c5), await this.core.relayer.subscribe(r3, { transportType: s2 == null ? void 0 : s2.transportType }), { topic: r3, uri: h4 };
    }, this.pair = async (s2) => {
      this.isInitialized();
      const i3 = this.core.eventClient.createEvent({ properties: { topic: s2 == null ? void 0 : s2.uri, trace: [z2.pairing_started] } });
      this.isValidPair(s2, i3);
      const { topic: r3, symKey: n4, relay: a4, expiryTimestamp: c5, methods: h4 } = Xu(s2.uri);
      i3.props.properties.topic = r3, i3.addTrace(z2.pairing_uri_validation_success), i3.addTrace(z2.pairing_uri_not_expired);
      let d3;
      if (this.pairings.keys.includes(r3)) {
        if (d3 = this.pairings.get(r3), i3.addTrace(z2.existing_pairing), d3.active) throw i3.setError(M2.active_pairing_already_exists), new Error(`Pairing already exists: ${r3}. Please try again with a new connection URI.`);
        i3.addTrace(z2.pairing_not_expired);
      }
      const g3 = c5 || ws(import_time2.FIVE_MINUTES), m2 = { topic: r3, relay: a4, expiry: g3, active: false, methods: h4 };
      this.core.expirer.set(r3, g3), await this.pairings.set(r3, m2), i3.addTrace(z2.store_new_pairing), s2.activatePairing && await this.activate({ topic: r3 }), this.events.emit(q.create, m2), i3.addTrace(z2.emit_inactive_pairing), this.core.crypto.keychain.has(r3) || await this.core.crypto.setSymKey(n4, r3), i3.addTrace(z2.subscribing_pairing_topic);
      try {
        await this.core.relayer.confirmOnlineStateOrThrow();
      } catch {
        i3.setError(M2.no_internet_connection);
      }
      try {
        await this.core.relayer.subscribe(r3, { relay: a4 });
      } catch (b3) {
        throw i3.setError(M2.subscribe_pairing_topic_failure), b3;
      }
      return i3.addTrace(z2.subscribe_pairing_topic_success), m2;
    }, this.activate = async ({ topic: s2 }) => {
      this.isInitialized();
      const i3 = ws(import_time2.THIRTY_DAYS);
      this.core.expirer.set(s2, i3), await this.pairings.update(s2, { active: true, expiry: i3 });
    }, this.ping = async (s2) => {
      this.isInitialized(), await this.isValidPing(s2);
      const { topic: i3 } = s2;
      if (this.pairings.keys.includes(i3)) {
        const r3 = await this.sendRequest(i3, "wc_pairingPing", {}), { done: n4, resolve: a4, reject: c5 } = gs();
        this.events.once(Ms("pairing_ping", r3), ({ error: h4 }) => {
          h4 ? c5(h4) : a4();
        }), await n4();
      }
    }, this.updateExpiry = async ({ topic: s2, expiry: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { expiry: i3 });
    }, this.updateMetadata = async ({ topic: s2, metadata: i3 }) => {
      this.isInitialized(), await this.pairings.update(s2, { peerMetadata: i3 });
    }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (s2) => {
      this.isInitialized(), await this.isValidDisconnect(s2);
      const { topic: i3 } = s2;
      this.pairings.keys.includes(i3) && (await this.sendRequest(i3, "wc_pairingDelete", er("USER_DISCONNECTED")), await this.deletePairing(i3));
    }, this.formatUriFromPairing = (s2) => {
      this.isInitialized();
      const { topic: i3, relay: r3, expiry: n4, methods: a4 } = s2, c5 = this.core.crypto.keychain.get(i3);
      return $u({ protocol: this.core.protocol, version: this.core.version, topic: i3, symKey: c5, relay: r3, expiryTimestamp: n4, methods: a4 });
    }, this.sendRequest = async (s2, i3, r3) => {
      const n4 = formatJsonRpcRequest(i3, r3), a4 = await this.core.crypto.encode(s2, n4), c5 = j2[i3].req;
      return this.core.history.set(s2, n4), this.core.relayer.publish(s2, a4, c5), n4.id;
    }, this.sendResult = async (s2, i3, r3) => {
      const n4 = formatJsonRpcResult(s2, r3), a4 = await this.core.crypto.encode(i3, n4), c5 = await this.core.history.get(i3, s2), h4 = j2[c5.request.method].res;
      await this.core.relayer.publish(i3, a4, h4), await this.core.history.resolve(n4);
    }, this.sendError = async (s2, i3, r3) => {
      const n4 = formatJsonRpcError(s2, r3), a4 = await this.core.crypto.encode(i3, n4), c5 = await this.core.history.get(i3, s2), h4 = j2[c5.request.method] ? j2[c5.request.method].res : j2.unregistered_method.res;
      await this.core.relayer.publish(i3, a4, h4), await this.core.history.resolve(n4);
    }, this.deletePairing = async (s2, i3) => {
      await this.core.relayer.unsubscribe(s2), await Promise.all([this.pairings.delete(s2, er("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(s2), i3 ? Promise.resolve() : this.core.expirer.del(s2)]);
    }, this.cleanup = async () => {
      const s2 = this.pairings.getAll().filter((i3) => xs(i3.expiry));
      await Promise.all(s2.map((i3) => this.deletePairing(i3.topic)));
    }, this.onRelayEventRequest = (s2) => {
      const { topic: i3, payload: r3 } = s2;
      switch (r3.method) {
        case "wc_pairingPing":
          return this.onPairingPingRequest(i3, r3);
        case "wc_pairingDelete":
          return this.onPairingDeleteRequest(i3, r3);
        default:
          return this.onUnknownRpcMethodRequest(i3, r3);
      }
    }, this.onRelayEventResponse = async (s2) => {
      const { topic: i3, payload: r3 } = s2, n4 = (await this.core.history.get(i3, r3.id)).request.method;
      switch (n4) {
        case "wc_pairingPing":
          return this.onPairingPingResponse(i3, r3);
        default:
          return this.onUnknownRpcMethodResponse(n4);
      }
    }, this.onPairingPingRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidPing({ topic: s2 }), await this.sendResult(r3, s2, true), this.events.emit(q.ping, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onPairingPingResponse = (s2, i3) => {
      const { id: r3 } = i3;
      setTimeout(() => {
        isJsonRpcResult(i3) ? this.events.emit(Ms("pairing_ping", r3), {}) : isJsonRpcError(i3) && this.events.emit(Ms("pairing_ping", r3), { error: i3.error });
      }, 500);
    }, this.onPairingDeleteRequest = async (s2, i3) => {
      const { id: r3 } = i3;
      try {
        this.isValidDisconnect({ topic: s2 }), await this.deletePairing(s2), this.events.emit(q.delete, { id: r3, topic: s2 });
      } catch (n4) {
        await this.sendError(r3, s2, n4), this.logger.error(n4);
      }
    }, this.onUnknownRpcMethodRequest = async (s2, i3) => {
      const { id: r3, method: n4 } = i3;
      try {
        if (this.registeredMethods.includes(n4)) return;
        const a4 = er("WC_METHOD_UNSUPPORTED", n4);
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      } catch (a4) {
        await this.sendError(r3, s2, a4), this.logger.error(a4);
      }
    }, this.onUnknownRpcMethodResponse = (s2) => {
      this.registeredMethods.includes(s2) || this.logger.error(er("WC_METHOD_UNSUPPORTED", s2));
    }, this.isValidPair = (s2, i3) => {
      var r3;
      if (!Ah(s2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `pair() params: ${s2}`);
        throw i3.setError(M2.malformed_pairing_uri), new Error(a4);
      }
      if (!ch(s2.uri)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `pair() uri: ${s2.uri}`);
        throw i3.setError(M2.malformed_pairing_uri), new Error(a4);
      }
      const n4 = Xu(s2 == null ? void 0 : s2.uri);
      if (!((r3 = n4 == null ? void 0 : n4.relay) != null && r3.protocol)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", "pair() uri#relay-protocol");
        throw i3.setError(M2.malformed_pairing_uri), new Error(a4);
      }
      if (!(n4 != null && n4.symKey)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", "pair() uri#symKey");
        throw i3.setError(M2.malformed_pairing_uri), new Error(a4);
      }
      if (n4 != null && n4.expiryTimestamp && (0, import_time2.toMiliseconds)(n4 == null ? void 0 : n4.expiryTimestamp) < Date.now()) {
        i3.setError(M2.pairing_expired);
        const { message: a4 } = xe("EXPIRED", "pair() URI has expired. Please try again with a new connection URI.");
        throw new Error(a4);
      }
    }, this.isValidPing = async (s2) => {
      if (!Ah(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `ping() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidDisconnect = async (s2) => {
      if (!Ah(s2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `disconnect() params: ${s2}`);
        throw new Error(r3);
      }
      const { topic: i3 } = s2;
      await this.isValidPairingTopic(i3);
    }, this.isValidPairingTopic = async (s2) => {
      if (!Yt(s2, false)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${s2}`);
        throw new Error(i3);
      }
      if (!this.pairings.keys.includes(s2)) {
        const { message: i3 } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${s2}`);
        throw new Error(i3);
      }
      if (xs(this.pairings.get(s2).expiry)) {
        await this.deletePairing(s2);
        const { message: i3 } = xe("EXPIRED", `pairing topic: ${s2}`);
        throw new Error(i3);
      }
    }, this.core = e2, this.logger = E(t, this.name), this.pairings = new ai(this.core, this.logger, this.name, this.storagePrefix);
  }
  get context() {
    return y(this.logger);
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
  registerRelayerEvents() {
    this.core.relayer.on(w2.message, async (e2) => {
      const { topic: t, message: s2, transportType: i3 } = e2;
      if (!this.pairings.keys.includes(t) || i3 === F.link_mode || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(s2))) return;
      const r3 = await this.core.crypto.decode(t, s2);
      try {
        isJsonRpcRequest(r3) ? (this.core.history.set(t, r3), this.onRelayEventRequest({ topic: t, payload: r3 })) : isJsonRpcResponse(r3) && (await this.core.history.resolve(r3), await this.onRelayEventResponse({ topic: t, payload: r3 }), this.core.history.delete(t, r3.id));
      } catch (n4) {
        this.logger.error(n4);
      }
    });
  }
  registerExpirerEvents() {
    this.core.expirer.on(R.expired, async (e2) => {
      const { topic: t } = ys(e2.target);
      t && this.pairings.keys.includes(t) && (await this.deletePairing(t, true), this.events.emit(q.expire, { topic: t }));
    });
  }
};
var hi = class extends h2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.records = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = ft, this.version = _t, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.records.set(s2.id, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.set = (s2, i3, r3) => {
      if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: s2, request: i3, chainId: r3 }), this.records.has(i3.id)) return;
      const n4 = { id: i3.id, topic: s2, request: { method: i3.method, params: i3.params || null }, chainId: r3, expiry: ws(import_time2.THIRTY_DAYS) };
      this.records.set(n4.id, n4), this.persist(), this.events.emit(P.created, n4);
    }, this.resolve = async (s2) => {
      if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: s2 }), !this.records.has(s2.id)) return;
      const i3 = await this.getRecord(s2.id);
      typeof i3.response > "u" && (i3.response = isJsonRpcError(s2) ? { error: s2.error } : { result: s2.result }, this.records.set(i3.id, i3), this.persist(), this.events.emit(P.updated, i3));
    }, this.get = async (s2, i3) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: s2, id: i3 }), await this.getRecord(i3)), this.delete = (s2, i3) => {
      this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: i3 }), this.values.forEach((r3) => {
        if (r3.topic === s2) {
          if (typeof i3 < "u" && r3.id !== i3) return;
          this.records.delete(r3.id), this.events.emit(P.deleted, r3);
        }
      }), this.persist();
    }, this.exists = async (s2, i3) => (this.isInitialized(), this.records.has(i3) ? (await this.getRecord(i3)).topic === s2 : false), this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get size() {
    return this.records.size;
  }
  get keys() {
    return Array.from(this.records.keys());
  }
  get values() {
    return Array.from(this.records.values());
  }
  get pending() {
    const e2 = [];
    return this.values.forEach((t) => {
      if (typeof t.response < "u") return;
      const s2 = { topic: t.topic, request: formatJsonRpcRequest(t.request.method, t.request.params, t.id), chainId: t.chainId };
      return e2.push(s2);
    }), e2;
  }
  async setJsonRpcRecords(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getJsonRpcRecords() {
    return await this.core.storage.getItem(this.storageKey);
  }
  getRecord(e2) {
    this.isInitialized();
    const t = this.records.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw new Error(s2);
    }
    return t;
  }
  async persist() {
    await this.setJsonRpcRecords(this.values), this.events.emit(P.sync);
  }
  async restore() {
    try {
      const e2 = await this.getJsonRpcRecords();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.records.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e2);
    }
  }
  registerEventListeners() {
    this.events.on(P.created, (e2) => {
      const t = P.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(P.updated, (e2) => {
      const t = P.updated;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.events.on(P.deleted, (e2) => {
      const t = P.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, record: e2 });
    }), this.core.heartbeat.on(r.pulse, () => {
      this.cleanup();
    });
  }
  cleanup() {
    try {
      this.isInitialized();
      let e2 = false;
      this.records.forEach((t) => {
        (0, import_time2.toMiliseconds)(t.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${t.id}`), this.records.delete(t.id), this.events.emit(P.deleted, t, false), e2 = true);
      }), e2 && this.persist();
    } catch (e2) {
      this.logger.warn(e2);
    }
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var li = class extends x2 {
  constructor(e2, t) {
    super(e2, t), this.core = e2, this.logger = t, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events7.EventEmitter(), this.name = Et, this.version = vt, this.cached = [], this.initialized = false, this.storagePrefix = O2, this.init = async () => {
      this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((s2) => this.expirations.set(s2.target, s2)), this.cached = [], this.registerEventListeners(), this.initialized = true);
    }, this.has = (s2) => {
      try {
        const i3 = this.formatTarget(s2);
        return typeof this.getExpiration(i3) < "u";
      } catch {
        return false;
      }
    }, this.set = (s2, i3) => {
      this.isInitialized();
      const r3 = this.formatTarget(s2), n4 = { target: r3, expiry: i3 };
      this.expirations.set(r3, n4), this.checkExpiry(r3, n4), this.events.emit(R.created, { target: r3, expiration: n4 });
    }, this.get = (s2) => {
      this.isInitialized();
      const i3 = this.formatTarget(s2);
      return this.getExpiration(i3);
    }, this.del = (s2) => {
      if (this.isInitialized(), this.has(s2)) {
        const i3 = this.formatTarget(s2), r3 = this.getExpiration(i3);
        this.expirations.delete(i3), this.events.emit(R.deleted, { target: i3, expiration: r3 });
      }
    }, this.on = (s2, i3) => {
      this.events.on(s2, i3);
    }, this.once = (s2, i3) => {
      this.events.once(s2, i3);
    }, this.off = (s2, i3) => {
      this.events.off(s2, i3);
    }, this.removeListener = (s2, i3) => {
      this.events.removeListener(s2, i3);
    }, this.logger = E(t, this.name);
  }
  get context() {
    return y(this.logger);
  }
  get storageKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
  }
  get length() {
    return this.expirations.size;
  }
  get keys() {
    return Array.from(this.expirations.keys());
  }
  get values() {
    return Array.from(this.expirations.values());
  }
  formatTarget(e2) {
    if (typeof e2 == "string") return As(e2);
    if (typeof e2 == "number") return bs(e2);
    const { message: t } = xe("UNKNOWN_TYPE", `Target type: ${typeof e2}`);
    throw new Error(t);
  }
  async setExpirations(e2) {
    await this.core.storage.setItem(this.storageKey, e2);
  }
  async getExpirations() {
    return await this.core.storage.getItem(this.storageKey);
  }
  async persist() {
    await this.setExpirations(this.values), this.events.emit(R.sync);
  }
  async restore() {
    try {
      const e2 = await this.getExpirations();
      if (typeof e2 > "u" || !e2.length) return;
      if (this.expirations.size) {
        const { message: t } = xe("RESTORE_WILL_OVERRIDE", this.name);
        throw this.logger.error(t), new Error(t);
      }
      this.cached = e2, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
    } catch (e2) {
      this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e2);
    }
  }
  getExpiration(e2) {
    const t = this.expirations.get(e2);
    if (!t) {
      const { message: s2 } = xe("NO_MATCHING_KEY", `${this.name}: ${e2}`);
      throw this.logger.warn(s2), new Error(s2);
    }
    return t;
  }
  checkExpiry(e2, t) {
    const { expiry: s2 } = t;
    (0, import_time2.toMiliseconds)(s2) - Date.now() <= 0 && this.expire(e2, t);
  }
  expire(e2, t) {
    this.expirations.delete(e2), this.events.emit(R.expired, { target: e2, expiration: t });
  }
  checkExpirations() {
    this.core.relayer.connected && this.expirations.forEach((e2, t) => this.checkExpiry(t, e2));
  }
  registerEventListeners() {
    this.core.heartbeat.on(r.pulse, () => this.checkExpirations()), this.events.on(R.created, (e2) => {
      const t = R.created;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(R.expired, (e2) => {
      const t = R.expired;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    }), this.events.on(R.deleted, (e2) => {
      const t = R.deleted;
      this.logger.info(`Emitting ${t}`), this.logger.debug({ type: "event", event: t, data: e2 }), this.persist();
    });
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: e2 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(e2);
    }
  }
};
var y5 = {};
Object.defineProperty(y5, "__esModule", { value: true }), y5.getLocalStorage = y5.getLocalStorageOrThrow = y5.getCrypto = y5.getCryptoOrThrow = y5.getLocation = y5.getLocationOrThrow = y5.getNavigator = y5.getNavigatorOrThrow = ui = y5.getDocument = y5.getDocumentOrThrow = y5.getFromWindowOrThrow = y5.getFromWindow = void 0;
function U2(o5) {
  let e2;
  return typeof window < "u" && typeof window[o5] < "u" && (e2 = window[o5]), e2;
}
y5.getFromWindow = U2;
function G(o5) {
  const e2 = U2(o5);
  if (!e2) throw new Error(`${o5} is not defined in Window`);
  return e2;
}
y5.getFromWindowOrThrow = G;
function yn() {
  return G("document");
}
y5.getDocumentOrThrow = yn;
function Dn() {
  return U2("document");
}
var ui = y5.getDocument = Dn;
function mn() {
  return G("navigator");
}
y5.getNavigatorOrThrow = mn;
function bn() {
  return U2("navigator");
}
y5.getNavigator = bn;
function fn() {
  return G("location");
}
y5.getLocationOrThrow = fn;
function _n() {
  return U2("location");
}
y5.getLocation = _n;
function En() {
  return G("crypto");
}
y5.getCryptoOrThrow = En;
function vn() {
  return U2("crypto");
}
y5.getCrypto = vn;
function wn() {
  return G("localStorage");
}
y5.getLocalStorageOrThrow = wn;
function In() {
  return U2("localStorage");
}
y5.getLocalStorage = In;
var di = class extends y3 {
  constructor(e2, t, s2) {
    super(e2, t, s2), this.core = e2, this.logger = t, this.store = s2, this.name = wt, this.verifyUrlV3 = Tt, this.storagePrefix = O2, this.version = fe, this.init = async () => {
      var i3;
      this.isDevEnv || (this.publicKey = await this.store.getItem(this.storeKey), this.publicKey && (0, import_time2.toMiliseconds)((i3 = this.publicKey) == null ? void 0 : i3.expiresAt) < Date.now() && (this.logger.debug("verify v2 public key expired"), await this.removePublicKey()));
    }, this.register = async (i3) => {
      if (!gr() || this.isDevEnv) return;
      const r3 = window.location.origin, { id: n4, decryptedId: a4 } = i3, c5 = `${this.verifyUrlV3}/attestation?projectId=${this.core.projectId}&origin=${r3}&id=${n4}&decryptedId=${a4}`;
      try {
        const h4 = ui(), d3 = this.startAbortTimer(import_time2.ONE_SECOND * 5), g3 = await new Promise((m2, b3) => {
          const l4 = () => {
            window.removeEventListener("message", E4), h4.body.removeChild(p3), b3("attestation aborted");
          };
          this.abortController.signal.addEventListener("abort", l4);
          const p3 = h4.createElement("iframe");
          p3.src = c5, p3.style.display = "none", p3.addEventListener("error", l4, { signal: this.abortController.signal });
          const E4 = (D3) => {
            if (D3.data && typeof D3.data == "string") try {
              const f3 = JSON.parse(D3.data);
              if (f3.type === "verify_attestation") {
                if (decodeJWT(f3.attestation).payload.id !== n4) return;
                clearInterval(d3), h4.body.removeChild(p3), this.abortController.signal.removeEventListener("abort", l4), window.removeEventListener("message", E4), m2(f3.attestation === null ? "" : f3.attestation);
              }
            } catch (f3) {
              this.logger.warn(f3);
            }
          };
          h4.body.appendChild(p3), window.addEventListener("message", E4, { signal: this.abortController.signal });
        });
        return this.logger.debug("jwt attestation", g3), g3;
      } catch (h4) {
        this.logger.warn(h4);
      }
      return "";
    }, this.resolve = async (i3) => {
      if (this.isDevEnv) return "";
      const { attestationId: r3, hash: n4, encryptedId: a4 } = i3;
      if (r3 === "") {
        this.logger.debug("resolve: attestationId is empty, skipping");
        return;
      }
      if (r3) {
        if (decodeJWT(r3).payload.id !== a4) return;
        const h4 = await this.isValidJwtAttestation(r3);
        if (h4) {
          if (!h4.isVerified) {
            this.logger.warn("resolve: jwt attestation: origin url not verified");
            return;
          }
          return h4;
        }
      }
      if (!n4) return;
      const c5 = this.getVerifyUrl(i3 == null ? void 0 : i3.verifyUrl);
      return this.fetchAttestation(n4, c5);
    }, this.fetchAttestation = async (i3, r3) => {
      this.logger.debug(`resolving attestation: ${i3} from url: ${r3}`);
      const n4 = this.startAbortTimer(import_time2.ONE_SECOND * 5), a4 = await fetch(`${r3}/attestation/${i3}?v2Supported=true`, { signal: this.abortController.signal });
      return clearTimeout(n4), a4.status === 200 ? await a4.json() : void 0;
    }, this.getVerifyUrl = (i3) => {
      let r3 = i3 || Z;
      return Ct.includes(r3) || (this.logger.info(`verify url: ${r3}, not included in trusted list, assigning default: ${Z}`), r3 = Z), r3;
    }, this.fetchPublicKey = async () => {
      try {
        this.logger.debug(`fetching public key from: ${this.verifyUrlV3}`);
        const i3 = this.startAbortTimer(import_time2.FIVE_SECONDS), r3 = await fetch(`${this.verifyUrlV3}/public-key`, { signal: this.abortController.signal });
        return clearTimeout(i3), await r3.json();
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.persistPublicKey = async (i3) => {
      this.logger.debug("persisting public key to local storage", i3), await this.store.setItem(this.storeKey, i3), this.publicKey = i3;
    }, this.removePublicKey = async () => {
      this.logger.debug("removing verify v2 public key from storage"), await this.store.removeItem(this.storeKey), this.publicKey = void 0;
    }, this.isValidJwtAttestation = async (i3) => {
      const r3 = await this.getPublicKey();
      try {
        if (r3) return this.validateAttestation(i3, r3);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
      const n4 = await this.fetchAndPersistPublicKey();
      try {
        if (n4) return this.validateAttestation(i3, n4);
      } catch (a4) {
        this.logger.error(a4), this.logger.warn("error validating attestation");
      }
    }, this.getPublicKey = async () => this.publicKey ? this.publicKey : await this.fetchAndPersistPublicKey(), this.fetchAndPersistPublicKey = async () => {
      if (this.fetchPromise) return await this.fetchPromise, this.publicKey;
      this.fetchPromise = new Promise(async (r3) => {
        const n4 = await this.fetchPublicKey();
        n4 && (await this.persistPublicKey(n4), r3(n4));
      });
      const i3 = await this.fetchPromise;
      return this.fetchPromise = void 0, i3;
    }, this.validateAttestation = (i3, r3) => {
      const n4 = Lu(i3, r3.publicKey), a4 = { hasExpired: (0, import_time2.toMiliseconds)(n4.exp) < Date.now(), payload: n4 };
      if (a4.hasExpired) throw this.logger.warn("resolve: jwt attestation expired"), new Error("JWT attestation expired");
      return { origin: a4.payload.origin, isScam: a4.payload.isScam, isVerified: a4.payload.isVerified };
    }, this.logger = E(t, this.name), this.abortController = new AbortController(), this.isDevEnv = _s(), this.init();
  }
  get storeKey() {
    return this.storagePrefix + this.version + this.core.customStoragePrefix + "//verify:public:key";
  }
  get context() {
    return y(this.logger);
  }
  startAbortTimer(e2) {
    return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time2.toMiliseconds)(e2));
  }
};
var gi = class extends v {
  constructor(e2, t) {
    super(e2, t), this.projectId = e2, this.logger = t, this.context = St, this.registerDeviceToken = async (s2) => {
      const { clientId: i3, token: r3, notificationType: n4, enableEncrypted: a4 = false } = s2, c5 = `${Pt}/${this.projectId}/clients`;
      await fetch(c5, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ client_id: i3, type: n4, token: r3, always_raw: a4 }) });
    }, this.logger = E(t, this.context);
  }
};
var Tn = Object.defineProperty;
var pi = Object.getOwnPropertySymbols;
var Cn = Object.prototype.hasOwnProperty;
var Sn = Object.prototype.propertyIsEnumerable;
var yi = (o5, e2, t) => e2 in o5 ? Tn(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var te = (o5, e2) => {
  for (var t in e2 || (e2 = {})) Cn.call(e2, t) && yi(o5, t, e2[t]);
  if (pi) for (var t of pi(e2)) Sn.call(e2, t) && yi(o5, t, e2[t]);
  return o5;
};
var Di = class extends C {
  constructor(e2, t, s2 = true) {
    super(e2, t, s2), this.core = e2, this.logger = t, this.context = xt, this.storagePrefix = O2, this.storageVersion = Rt, this.events = /* @__PURE__ */ new Map(), this.shouldPersist = false, this.init = async () => {
      if (!_s()) try {
        const i3 = { eventId: Ns(), timestamp: Date.now(), domain: this.getAppDomain(), props: { event: "INIT", type: "", properties: { client_id: await this.core.crypto.getClientId(), user_agent: Pn(this.core.relayer.protocol, this.core.relayer.version, oe) } } };
        await this.sendEvent([i3]);
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.createEvent = (i3) => {
      const { event: r3 = "ERROR", type: n4 = "", properties: { topic: a4, trace: c5 } } = i3, h4 = Ns(), d3 = this.core.projectId || "", g3 = Date.now(), m2 = te({ eventId: h4, timestamp: g3, props: { event: r3, type: n4, properties: { topic: a4, trace: c5 } }, bundleId: d3, domain: this.getAppDomain() }, this.setMethods(h4));
      return this.telemetryEnabled && (this.events.set(h4, m2), this.shouldPersist = true), m2;
    }, this.getEvent = (i3) => {
      const { eventId: r3, topic: n4 } = i3;
      if (r3) return this.events.get(r3);
      const a4 = Array.from(this.events.values()).find((c5) => c5.props.properties.topic === n4);
      if (a4) return te(te({}, a4), this.setMethods(a4.eventId));
    }, this.deleteEvent = (i3) => {
      const { eventId: r3 } = i3;
      this.events.delete(r3), this.shouldPersist = true;
    }, this.setEventListeners = () => {
      this.core.heartbeat.on(r.pulse, async () => {
        this.shouldPersist && await this.persist(), this.events.forEach((i3) => {
          (0, import_time2.fromMiliseconds)(Date.now()) - (0, import_time2.fromMiliseconds)(i3.timestamp) > Ot && (this.events.delete(i3.eventId), this.shouldPersist = true);
        });
      });
    }, this.setMethods = (i3) => ({ addTrace: (r3) => this.addTrace(i3, r3), setError: (r3) => this.setError(i3, r3) }), this.addTrace = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.properties.trace.push(r3), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.setError = (i3, r3) => {
      const n4 = this.events.get(i3);
      n4 && (n4.props.type = r3, n4.timestamp = Date.now(), this.events.set(i3, n4), this.shouldPersist = true);
    }, this.persist = async () => {
      await this.core.storage.setItem(this.storageKey, Array.from(this.events.values())), this.shouldPersist = false;
    }, this.restore = async () => {
      try {
        const i3 = await this.core.storage.getItem(this.storageKey) || [];
        if (!i3.length) return;
        i3.forEach((r3) => {
          this.events.set(r3.eventId, te(te({}, r3), this.setMethods(r3.eventId)));
        });
      } catch (i3) {
        this.logger.warn(i3);
      }
    }, this.submit = async () => {
      if (!this.telemetryEnabled || this.events.size === 0) return;
      const i3 = [];
      for (const [r3, n4] of this.events) n4.props.type && i3.push(n4);
      if (i3.length !== 0) try {
        if ((await this.sendEvent(i3)).ok) for (const r3 of i3) this.events.delete(r3.eventId), this.shouldPersist = true;
      } catch (r3) {
        this.logger.warn(r3);
      }
    }, this.sendEvent = async (i3) => {
      const r3 = this.getAppDomain() ? "" : "&sp=desktop";
      return await fetch(`${At}?projectId=${this.core.projectId}&st=events_sdk&sv=js-${oe}${r3}`, { method: "POST", body: JSON.stringify(i3) });
    }, this.getAppDomain = () => fs().url, this.logger = E(t, this.context), this.telemetryEnabled = s2, s2 ? this.restore().then(async () => {
      await this.submit(), this.setEventListeners();
    }) : this.persist();
  }
  get storageKey() {
    return this.storagePrefix + this.storageVersion + this.core.customStoragePrefix + "//" + this.context;
  }
};
var Pn2 = Object.defineProperty;
var mi = Object.getOwnPropertySymbols;
var Rn = Object.prototype.hasOwnProperty;
var xn = Object.prototype.propertyIsEnumerable;
var bi2 = (o5, e2, t) => e2 in o5 ? Pn2(o5, e2, { enumerable: true, configurable: true, writable: true, value: t }) : o5[e2] = t;
var fi = (o5, e2) => {
  for (var t in e2 || (e2 = {})) Rn.call(e2, t) && bi2(o5, t, e2[t]);
  if (mi) for (var t of mi(e2)) xn.call(e2, t) && bi2(o5, t, e2[t]);
  return o5;
};
var ce = class _ce extends n2 {
  constructor(e2) {
    var t;
    super(e2), this.protocol = be, this.version = fe, this.name = ne, this.events = new import_events7.EventEmitter(), this.initialized = false, this.on = (n4, a4) => this.events.on(n4, a4), this.once = (n4, a4) => this.events.once(n4, a4), this.off = (n4, a4) => this.events.off(n4, a4), this.removeListener = (n4, a4) => this.events.removeListener(n4, a4), this.dispatchEnvelope = ({ topic: n4, message: a4, sessionExists: c5 }) => {
      if (!n4 || !a4) return;
      const h4 = { topic: n4, message: a4, publishedAt: Date.now(), transportType: F.link_mode };
      this.relayer.onLinkMessageEvent(h4, { sessionExists: c5 });
    }, this.projectId = e2 == null ? void 0 : e2.projectId, this.relayUrl = (e2 == null ? void 0 : e2.relayUrl) || Ee, this.customStoragePrefix = e2 != null && e2.customStoragePrefix ? `:${e2.customStoragePrefix}` : "";
    const s2 = k({ level: typeof (e2 == null ? void 0 : e2.logger) == "string" && e2.logger ? e2.logger : Xe.logger }), { logger: i3, chunkLoggerController: r3 } = A({ opts: s2, maxSizeInBytes: e2 == null ? void 0 : e2.maxLogBlobSizeInBytes, loggerOverride: e2 == null ? void 0 : e2.logger });
    this.logChunkController = r3, (t = this.logChunkController) != null && t.downloadLogsBlobInBrowser && (window.downloadLogsBlobInBrowser = async () => {
      var n4, a4;
      (n4 = this.logChunkController) != null && n4.downloadLogsBlobInBrowser && ((a4 = this.logChunkController) == null || a4.downloadLogsBlobInBrowser({ clientId: await this.crypto.getClientId() }));
    }), this.logger = E(i3, this.name), this.heartbeat = new i(), this.crypto = new Wt(this, this.logger, e2 == null ? void 0 : e2.keychain), this.history = new hi(this, this.logger), this.expirer = new li(this, this.logger), this.storage = e2 != null && e2.storage ? e2.storage : new h(fi(fi({}, Ze2), e2 == null ? void 0 : e2.storageOptions)), this.relayer = new si({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new ci(this, this.logger), this.verify = new di(this, this.logger, this.storage), this.echoClient = new gi(this.projectId || "", this.logger), this.linkModeSupportedApps = [], this.eventClient = new Di(this, this.logger, e2 == null ? void 0 : e2.telemetryEnabled);
  }
  static async init(e2) {
    const t = new _ce(e2);
    await t.initialize();
    const s2 = await t.crypto.getClientId();
    return await t.storage.setItem(gt, s2), t;
  }
  get context() {
    return y(this.logger);
  }
  async start() {
    this.initialized || await this.initialize();
  }
  async getLogsBlob() {
    var e2;
    return (e2 = this.logChunkController) == null ? void 0 : e2.logsToBlob({ clientId: await this.crypto.getClientId() });
  }
  async addLinkModeSupportedApp(e2) {
    this.linkModeSupportedApps.includes(e2) || (this.linkModeSupportedApps.push(e2), await this.storage.setItem(ve, this.linkModeSupportedApps));
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.eventClient.init(), this.linkModeSupportedApps = await this.storage.getItem(ve) || [], this.initialized = true, this.logger.info("Core Initialization Success");
    } catch (e2) {
      throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e2), this.logger.error(e2.message), e2;
    }
  }
};
var On = ce;

// node_modules/@walletconnect/sign-client/dist/index.es.js
var import_events8 = __toESM(require_events());
var import_time3 = __toESM(require_cjs());
var be2 = "wc";
var Ce2 = 2;
var Le = "client";
var ye = `${be2}@${Ce2}:${Le}:`;
var we2 = { name: Le, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.org" };
var xe2 = "WALLETCONNECT_DEEPLINK_CHOICE";
var st2 = "proposal";
var it2 = "Proposal expired";
var rt2 = "session";
var z3 = import_time3.SEVEN_DAYS;
var nt2 = "engine";
var v2 = { wc_sessionPropose: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1101 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1120 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1121 } }, wc_sessionSettle: { req: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time3.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1114 }, res: { ttl: import_time3.ONE_DAY, prompt: false, tag: 1115 } }, wc_sessionAuthenticate: { req: { ttl: import_time3.ONE_HOUR, prompt: true, tag: 1116 }, res: { ttl: import_time3.ONE_HOUR, prompt: false, tag: 1117 }, reject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1118 }, autoReject: { ttl: import_time3.FIVE_MINUTES, prompt: false, tag: 1119 } } };
var me2 = { min: import_time3.FIVE_MINUTES, max: import_time3.SEVEN_DAYS };
var x3 = { idle: "IDLE", active: "ACTIVE" };
var ot2 = "request";
var at2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest", "wc_sessionAuthenticate"];
var ct2 = "wc";
var lt2 = "auth";
var pt2 = "authKeys";
var ht2 = "pairingTopics";
var dt2 = "requests";
var oe2 = `${ct2}@${1.5}:${lt2}:`;
var ae2 = `${oe2}:PUB_KEY`;
var ys2 = Object.defineProperty;
var ws2 = Object.defineProperties;
var ms2 = Object.getOwnPropertyDescriptors;
var ut2 = Object.getOwnPropertySymbols;
var _s2 = Object.prototype.hasOwnProperty;
var Es2 = Object.prototype.propertyIsEnumerable;
var gt2 = (q2, o5, e2) => o5 in q2 ? ys2(q2, o5, { enumerable: true, configurable: true, writable: true, value: e2 }) : q2[o5] = e2;
var I2 = (q2, o5) => {
  for (var e2 in o5 || (o5 = {})) _s2.call(o5, e2) && gt2(q2, e2, o5[e2]);
  if (ut2) for (var e2 of ut2(o5)) Es2.call(o5, e2) && gt2(q2, e2, o5[e2]);
  return q2;
};
var D2 = (q2, o5) => ws2(q2, ms2(o5));
var Rs2 = class extends M {
  constructor(o5) {
    super(o5), this.name = nt2, this.events = new import_events8.default(), this.initialized = false, this.requestQueue = { state: x3.idle, queue: [] }, this.sessionRequestQueue = { state: x3.idle, queue: [] }, this.requestQueueDelay = import_time3.ONE_SECOND, this.expectedPairingMethodMap = /* @__PURE__ */ new Map(), this.recentlyDeletedMap = /* @__PURE__ */ new Map(), this.recentlyDeletedLimit = 200, this.relayMessageCache = [], this.init = async () => {
      this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), await this.registerLinkModeListeners(), this.client.core.pairing.register({ methods: Object.keys(v2) }), this.initialized = true, setTimeout(() => {
        this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay)));
    }, this.connect = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      const t = D2(I2({}, e2), { requiredNamespaces: e2.requiredNamespaces || {}, optionalNamespaces: e2.optionalNamespaces || {} });
      await this.isValidConnect(t);
      const { pairingTopic: s2, requiredNamespaces: i3, optionalNamespaces: r3, sessionProperties: n4, relays: a4 } = t;
      let c5 = s2, h4, p3 = false;
      try {
        c5 && (p3 = this.client.core.pairing.pairings.get(c5).active);
      } catch (E4) {
        throw this.client.logger.error(`connect() -> pairing.get(${c5}) failed`), E4;
      }
      if (!c5 || !p3) {
        const { topic: E4, uri: S3 } = await this.client.core.pairing.create();
        c5 = E4, h4 = S3;
      }
      if (!c5) {
        const { message: E4 } = xe("NO_MATCHING_KEY", `connect() pairing topic: ${c5}`);
        throw new Error(E4);
      }
      const d3 = await this.client.core.crypto.generateKeyPair(), l4 = v2.wc_sessionPropose.req.ttl || import_time3.FIVE_MINUTES, w4 = ws(l4), m2 = I2({ requiredNamespaces: i3, optionalNamespaces: r3, relays: a4 ?? [{ protocol: at }], proposer: { publicKey: d3, metadata: this.client.metadata }, expiryTimestamp: w4, pairingTopic: c5 }, n4 && { sessionProperties: n4 }), { reject: y6, resolve: _3, done: R2 } = gs(l4, it2);
      this.events.once(Ms("session_connect"), async ({ error: E4, session: S3 }) => {
        if (E4) y6(E4);
        else if (S3) {
          S3.self.publicKey = d3;
          const M3 = D2(I2({}, S3), { pairingTopic: m2.pairingTopic, requiredNamespaces: m2.requiredNamespaces, optionalNamespaces: m2.optionalNamespaces, transportType: F.relay });
          await this.client.session.set(S3.topic, M3), await this.setExpiry(S3.topic, S3.expiry), c5 && await this.client.core.pairing.updateMetadata({ topic: c5, metadata: S3.peer.metadata }), this.cleanupDuplicatePairings(M3), _3(M3);
        }
      });
      const V = await this.sendRequest({ topic: c5, method: "wc_sessionPropose", params: m2, throwOnFailedPublish: true });
      return await this.setProposal(V, I2({ id: V }, m2)), { uri: h4, approval: R2 };
    }, this.pair = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        return await this.client.core.pairing.pair(e2);
      } catch (t) {
        throw this.client.logger.error("pair() failed"), t;
      }
    }, this.approve = async (e2) => {
      var t, s2, i3;
      const r3 = this.client.core.eventClient.createEvent({ properties: { topic: (t = e2 == null ? void 0 : e2.id) == null ? void 0 : t.toString(), trace: [Cs.session_approve_started] } });
      try {
        this.isInitialized(), await this.confirmOnlineStateOrThrow();
      } catch (N2) {
        throw r3.setError(Ss2.no_internet_connection), N2;
      }
      try {
        await this.isValidProposalId(e2 == null ? void 0 : e2.id);
      } catch (N2) {
        throw this.client.logger.error(`approve() -> proposal.get(${e2 == null ? void 0 : e2.id}) failed`), r3.setError(Ss2.proposal_not_found), N2;
      }
      try {
        await this.isValidApprove(e2);
      } catch (N2) {
        throw this.client.logger.error("approve() -> isValidApprove() failed"), r3.setError(Ss2.session_approve_namespace_validation_failure), N2;
      }
      const { id: n4, relayProtocol: a4, namespaces: c5, sessionProperties: h4, sessionConfig: p3 } = e2, d3 = this.client.proposal.get(n4);
      this.client.core.eventClient.deleteEvent({ eventId: r3.eventId });
      const { pairingTopic: l4, proposer: w4, requiredNamespaces: m2, optionalNamespaces: y6 } = d3;
      let _3 = (s2 = this.client.core.eventClient) == null ? void 0 : s2.getEvent({ topic: l4 });
      _3 || (_3 = (i3 = this.client.core.eventClient) == null ? void 0 : i3.createEvent({ type: Cs.session_approve_started, properties: { topic: l4, trace: [Cs.session_approve_started, Cs.session_namespaces_validation_success] } }));
      const R2 = await this.client.core.crypto.generateKeyPair(), V = w4.publicKey, E4 = await this.client.core.crypto.generateSharedKey(R2, V), S3 = I2(I2({ relay: { protocol: a4 ?? "irn" }, namespaces: c5, controller: { publicKey: R2, metadata: this.client.metadata }, expiry: ws(z3) }, h4 && { sessionProperties: h4 }), p3 && { sessionConfig: p3 }), M3 = F.relay;
      _3.addTrace(Cs.subscribing_session_topic);
      try {
        await this.client.core.relayer.subscribe(E4, { transportType: M3 });
      } catch (N2) {
        throw _3.setError(Ss2.subscribe_session_topic_failure), N2;
      }
      _3.addTrace(Cs.subscribe_session_topic_success);
      const W = D2(I2({}, S3), { topic: E4, requiredNamespaces: m2, optionalNamespaces: y6, pairingTopic: l4, acknowledged: false, self: S3.controller, peer: { publicKey: w4.publicKey, metadata: w4.metadata }, controller: R2, transportType: F.relay });
      await this.client.session.set(E4, W), _3.addTrace(Cs.store_session);
      try {
        _3.addTrace(Cs.publishing_session_settle), await this.sendRequest({ topic: E4, method: "wc_sessionSettle", params: S3, throwOnFailedPublish: true }).catch((N2) => {
          throw _3 == null ? void 0 : _3.setError(Ss2.session_settle_publish_failure), N2;
        }), _3.addTrace(Cs.session_settle_publish_success), _3.addTrace(Cs.publishing_session_approve), await this.sendResult({ id: n4, topic: l4, result: { relay: { protocol: a4 ?? "irn" }, responderPublicKey: R2 }, throwOnFailedPublish: true }).catch((N2) => {
          throw _3 == null ? void 0 : _3.setError(Ss2.session_approve_publish_failure), N2;
        }), _3.addTrace(Cs.session_approve_publish_success);
      } catch (N2) {
        throw this.client.logger.error(N2), this.client.session.delete(E4, er("USER_DISCONNECTED")), await this.client.core.relayer.unsubscribe(E4), N2;
      }
      return this.client.core.eventClient.deleteEvent({ eventId: _3.eventId }), await this.client.core.pairing.updateMetadata({ topic: l4, metadata: w4.metadata }), await this.client.proposal.delete(n4, er("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: l4 }), await this.setExpiry(E4, ws(z3)), { topic: E4, acknowledged: () => Promise.resolve(this.client.session.get(E4)) };
    }, this.reject = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidReject(e2);
      } catch (r3) {
        throw this.client.logger.error("reject() -> isValidReject() failed"), r3;
      }
      const { id: t, reason: s2 } = e2;
      let i3;
      try {
        i3 = this.client.proposal.get(t).pairingTopic;
      } catch (r3) {
        throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`), r3;
      }
      i3 && (await this.sendError({ id: t, topic: i3, error: s2, rpcOpts: v2.wc_sessionPropose.reject }), await this.client.proposal.delete(t, er("USER_DISCONNECTED")));
    }, this.update = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidUpdate(e2);
      } catch (p3) {
        throw this.client.logger.error("update() -> isValidUpdate() failed"), p3;
      }
      const { topic: t, namespaces: s2 } = e2, { done: i3, resolve: r3, reject: n4 } = gs(), a4 = payloadId(), c5 = getBigIntRpcId().toString(), h4 = this.client.session.get(t).namespaces;
      return this.events.once(Ms("session_update", a4), ({ error: p3 }) => {
        p3 ? n4(p3) : r3();
      }), await this.client.session.update(t, { namespaces: s2 }), await this.sendRequest({ topic: t, method: "wc_sessionUpdate", params: { namespaces: s2 }, throwOnFailedPublish: true, clientRpcId: a4, relayRpcId: c5 }).catch((p3) => {
        this.client.logger.error(p3), this.client.session.update(t, { namespaces: h4 }), n4(p3);
      }), { acknowledged: i3 };
    }, this.extend = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidExtend(e2);
      } catch (a4) {
        throw this.client.logger.error("extend() -> isValidExtend() failed"), a4;
      }
      const { topic: t } = e2, s2 = payloadId(), { done: i3, resolve: r3, reject: n4 } = gs();
      return this.events.once(Ms("session_extend", s2), ({ error: a4 }) => {
        a4 ? n4(a4) : r3();
      }), await this.setExpiry(t, ws(z3)), this.sendRequest({ topic: t, method: "wc_sessionExtend", params: {}, clientRpcId: s2, throwOnFailedPublish: true }).catch((a4) => {
        n4(a4);
      }), { acknowledged: i3 };
    }, this.request = async (e2) => {
      this.isInitialized();
      try {
        await this.isValidRequest(e2);
      } catch (w4) {
        throw this.client.logger.error("request() -> isValidRequest() failed"), w4;
      }
      const { chainId: t, request: s2, topic: i3, expiry: r3 = v2.wc_sessionRequest.req.ttl } = e2, n4 = this.client.session.get(i3);
      (n4 == null ? void 0 : n4.transportType) === F.relay && await this.confirmOnlineStateOrThrow();
      const a4 = payloadId(), c5 = getBigIntRpcId().toString(), { done: h4, resolve: p3, reject: d3 } = gs(r3, "Request expired. Please try again.");
      this.events.once(Ms("session_request", a4), ({ error: w4, result: m2 }) => {
        w4 ? d3(w4) : p3(m2);
      });
      const l4 = this.getAppLinkIfEnabled(n4.peer.metadata, n4.transportType);
      return l4 ? (await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i3, method: "wc_sessionRequest", params: { request: D2(I2({}, s2), { expiryTimestamp: ws(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true, appLink: l4 }).catch((w4) => d3(w4)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a4 }), await h4()) : await Promise.all([new Promise(async (w4) => {
        await this.sendRequest({ clientRpcId: a4, relayRpcId: c5, topic: i3, method: "wc_sessionRequest", params: { request: D2(I2({}, s2), { expiryTimestamp: ws(r3) }), chainId: t }, expiry: r3, throwOnFailedPublish: true }).catch((m2) => d3(m2)), this.client.events.emit("session_request_sent", { topic: i3, request: s2, chainId: t, id: a4 }), w4();
      }), new Promise(async (w4) => {
        var m2;
        if (!((m2 = n4.sessionConfig) != null && m2.disableDeepLink)) {
          const y6 = await Ss(this.client.core.storage, xe2);
          await Es({ id: a4, topic: i3, wcDeepLink: y6 });
        }
        w4();
      }), h4()]).then((w4) => w4[2]);
    }, this.respond = async (e2) => {
      this.isInitialized(), await this.isValidRespond(e2);
      const { topic: t, response: s2 } = e2, { id: i3 } = s2, r3 = this.client.session.get(t);
      r3.transportType === F.relay && await this.confirmOnlineStateOrThrow();
      const n4 = this.getAppLinkIfEnabled(r3.peer.metadata, r3.transportType);
      isJsonRpcResult(s2) ? await this.sendResult({ id: i3, topic: t, result: s2.result, throwOnFailedPublish: true, appLink: n4 }) : isJsonRpcError(s2) && await this.sendError({ id: i3, topic: t, error: s2.error, appLink: n4 }), this.cleanupAfterResponse(e2);
    }, this.ping = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow();
      try {
        await this.isValidPing(e2);
      } catch (s2) {
        throw this.client.logger.error("ping() -> isValidPing() failed"), s2;
      }
      const { topic: t } = e2;
      if (this.client.session.keys.includes(t)) {
        const s2 = payloadId(), i3 = getBigIntRpcId().toString(), { done: r3, resolve: n4, reject: a4 } = gs();
        this.events.once(Ms("session_ping", s2), ({ error: c5 }) => {
          c5 ? a4(c5) : n4();
        }), await Promise.all([this.sendRequest({ topic: t, method: "wc_sessionPing", params: {}, throwOnFailedPublish: true, clientRpcId: s2, relayRpcId: i3 }), r3()]);
      } else this.client.core.pairing.pairings.keys.includes(t) && await this.client.core.pairing.ping({ topic: t });
    }, this.emit = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidEmit(e2);
      const { topic: t, event: s2, chainId: i3 } = e2, r3 = getBigIntRpcId().toString();
      await this.sendRequest({ topic: t, method: "wc_sessionEvent", params: { event: s2, chainId: i3 }, throwOnFailedPublish: true, relayRpcId: r3 });
    }, this.disconnect = async (e2) => {
      this.isInitialized(), await this.confirmOnlineStateOrThrow(), await this.isValidDisconnect(e2);
      const { topic: t } = e2;
      if (this.client.session.keys.includes(t)) await this.sendRequest({ topic: t, method: "wc_sessionDelete", params: er("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession({ topic: t, emitEvent: false });
      else if (this.client.core.pairing.pairings.keys.includes(t)) await this.client.core.pairing.disconnect({ topic: t });
      else {
        const { message: s2 } = xe("MISMATCHED_TOPIC", `Session or pairing topic not found: ${t}`);
        throw new Error(s2);
      }
    }, this.find = (e2) => (this.isInitialized(), this.client.session.getAll().filter((t) => hh(t, e2))), this.getPendingSessionRequests = () => this.client.pendingRequest.getAll(), this.authenticate = async (e2, t) => {
      var s2;
      this.isInitialized(), this.isValidAuthenticate(e2);
      const i3 = t && this.client.core.linkModeSupportedApps.includes(t) && ((s2 = this.client.metadata.redirect) == null ? void 0 : s2.linkMode), r3 = i3 ? F.link_mode : F.relay;
      r3 === F.relay && await this.confirmOnlineStateOrThrow();
      const { chains: n4, statement: a4 = "", uri: c5, domain: h4, nonce: p3, type: d3, exp: l4, nbf: w4, methods: m2 = [], expiry: y6 } = e2, _3 = [...e2.resources || []], { topic: R2, uri: V } = await this.client.core.pairing.create({ methods: ["wc_sessionAuthenticate"], transportType: r3 });
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: R2, uri: V } });
      const E4 = await this.client.core.crypto.generateKeyPair(), S3 = Ru(E4);
      if (await Promise.all([this.client.auth.authKeys.set(ae2, { responseTopic: S3, publicKey: E4 }), this.client.auth.pairingTopics.set(S3, { topic: S3, pairingTopic: R2 })]), await this.client.core.relayer.subscribe(S3, { transportType: r3 }), this.client.logger.info(`sending request to new pairing topic: ${R2}`), m2.length > 0) {
        const { namespace: O4 } = An(n4[0]);
        let T3 = xu(O4, "request", m2);
        Vr(_3) && (T3 = Mu(T3, _3.pop())), _3.push(T3);
      }
      const M3 = y6 && y6 > v2.wc_sessionAuthenticate.req.ttl ? y6 : v2.wc_sessionAuthenticate.req.ttl, W = { authPayload: { type: d3 ?? "caip122", chains: n4, statement: a4, aud: c5, domain: h4, version: "1", nonce: p3, iat: (/* @__PURE__ */ new Date()).toISOString(), exp: l4, nbf: w4, resources: _3 }, requester: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: ws(M3) }, N2 = { eip155: { chains: n4, methods: [.../* @__PURE__ */ new Set(["personal_sign", ...m2])], events: ["chainChanged", "accountsChanged"] } }, De = { requiredNamespaces: {}, optionalNamespaces: N2, relays: [{ protocol: "irn" }], pairingTopic: R2, proposer: { publicKey: E4, metadata: this.client.metadata }, expiryTimestamp: ws(v2.wc_sessionPropose.req.ttl) }, { done: wt2, resolve: Ve, reject: Ee2 } = gs(M3, "Request expired"), ce2 = async ({ error: O4, session: T3 }) => {
        if (this.events.off(Ms("session_request", G2), Re2), O4) Ee2(O4);
        else if (T3) {
          T3.self.publicKey = E4, await this.client.session.set(T3.topic, T3), await this.setExpiry(T3.topic, T3.expiry), R2 && await this.client.core.pairing.updateMetadata({ topic: R2, metadata: T3.peer.metadata });
          const le2 = this.client.session.get(T3.topic);
          await this.deleteProposal(Z2), Ve({ session: le2 });
        }
      }, Re2 = async (O4) => {
        var T3, le2, Me;
        if (await this.deletePendingAuthRequest(G2, { message: "fulfilled", code: 0 }), O4.error) {
          const te2 = er("WC_METHOD_UNSUPPORTED", "wc_sessionAuthenticate");
          return O4.error.code === te2.code ? void 0 : (this.events.off(Ms("session_connect"), ce2), Ee2(O4.error.message));
        }
        await this.deleteProposal(Z2), this.events.off(Ms("session_connect"), ce2);
        const { cacaos: ke, responder: j4 } = O4.result, Ie2 = [], $e = [];
        for (const te2 of ke) {
          await mu({ cacao: te2, projectId: this.client.core.projectId }) || (this.client.logger.error(te2, "Signature verification failed"), Ee2(er("SESSION_SETTLEMENT_FAILED", "Signature verification failed")));
          const { p: fe2 } = te2, ve2 = Vr(fe2.resources), Ke = [gu(fe2.iss)], mt2 = Vi(fe2.iss);
          if (ve2) {
            const qe = Eu(ve2), _t2 = Su(ve2);
            Ie2.push(...qe), Ke.push(..._t2);
          }
          for (const qe of Ke) $e.push(`${qe}:${mt2}`);
        }
        const ee2 = await this.client.core.crypto.generateSharedKey(E4, j4.publicKey);
        let pe;
        Ie2.length > 0 && (pe = { topic: ee2, acknowledged: true, self: { publicKey: E4, metadata: this.client.metadata }, peer: j4, controller: j4.publicKey, expiry: ws(z3), requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: R2, namespaces: uh([...new Set(Ie2)], [...new Set($e)]), transportType: r3 }, await this.client.core.relayer.subscribe(ee2, { transportType: r3 }), await this.client.session.set(ee2, pe), R2 && await this.client.core.pairing.updateMetadata({ topic: R2, metadata: j4.metadata }), pe = this.client.session.get(ee2)), (T3 = this.client.metadata.redirect) != null && T3.linkMode && (le2 = j4.metadata.redirect) != null && le2.linkMode && (Me = j4.metadata.redirect) != null && Me.universal && t && (this.client.core.addLinkModeSupportedApp(j4.metadata.redirect.universal), this.client.session.update(ee2, { transportType: F.link_mode })), Ve({ auths: ke, session: pe });
      }, G2 = payloadId(), Z2 = payloadId();
      this.events.once(Ms("session_connect"), ce2), this.events.once(Ms("session_request", G2), Re2);
      let Se;
      try {
        if (i3) {
          const O4 = formatJsonRpcRequest("wc_sessionAuthenticate", W, G2);
          this.client.core.history.set(R2, O4);
          const T3 = await this.client.core.crypto.encode("", O4, { type: Sr, encoding: Iu });
          Se = Zu(t, R2, T3);
        } else await Promise.all([this.sendRequest({ topic: R2, method: "wc_sessionAuthenticate", params: W, expiry: e2.expiry, throwOnFailedPublish: true, clientRpcId: G2 }), this.sendRequest({ topic: R2, method: "wc_sessionPropose", params: De, expiry: v2.wc_sessionPropose.req.ttl, throwOnFailedPublish: true, clientRpcId: Z2 })]);
      } catch (O4) {
        throw this.events.off(Ms("session_connect"), ce2), this.events.off(Ms("session_request", G2), Re2), O4;
      }
      return await this.setProposal(Z2, I2({ id: Z2 }, De)), await this.setAuthRequest(G2, { request: D2(I2({}, W), { verifyContext: {} }), pairingTopic: R2, transportType: r3 }), { uri: Se ?? V, response: wt2 };
    }, this.approveSessionAuthenticate = async (e2) => {
      const { id: t, auths: s2 } = e2, i3 = this.client.core.eventClient.createEvent({ properties: { topic: t.toString(), trace: [Ps.authenticated_session_approve_started] } });
      try {
        this.isInitialized();
      } catch (y6) {
        throw i3.setError(Rs.no_internet_connection), y6;
      }
      const r3 = this.getPendingAuthRequest(t);
      if (!r3) throw i3.setError(Rs.authenticated_session_pending_request_not_found), new Error(`Could not find pending auth request with id ${t}`);
      const n4 = r3.transportType || F.relay;
      n4 === F.relay && await this.confirmOnlineStateOrThrow();
      const a4 = r3.requester.publicKey, c5 = await this.client.core.crypto.generateKeyPair(), h4 = Ru(a4), p3 = { type: pr, receiverPublicKey: a4, senderPublicKey: c5 }, d3 = [], l4 = [];
      for (const y6 of s2) {
        if (!await mu({ cacao: y6, projectId: this.client.core.projectId })) {
          i3.setError(Rs.invalid_cacao);
          const S3 = er("SESSION_SETTLEMENT_FAILED", "Signature verification failed");
          throw await this.sendError({ id: t, topic: h4, error: S3, encodeOpts: p3 }), new Error(S3.message);
        }
        i3.addTrace(Ps.cacaos_verified);
        const { p: _3 } = y6, R2 = Vr(_3.resources), V = [gu(_3.iss)], E4 = Vi(_3.iss);
        if (R2) {
          const S3 = Eu(R2), M3 = Su(R2);
          d3.push(...S3), V.push(...M3);
        }
        for (const S3 of V) l4.push(`${S3}:${E4}`);
      }
      const w4 = await this.client.core.crypto.generateSharedKey(c5, a4);
      i3.addTrace(Ps.create_authenticated_session_topic);
      let m2;
      if ((d3 == null ? void 0 : d3.length) > 0) {
        m2 = { topic: w4, acknowledged: true, self: { publicKey: c5, metadata: this.client.metadata }, peer: { publicKey: a4, metadata: r3.requester.metadata }, controller: a4, expiry: ws(z3), authentication: s2, requiredNamespaces: {}, optionalNamespaces: {}, relay: { protocol: "irn" }, pairingTopic: r3.pairingTopic, namespaces: uh([...new Set(d3)], [...new Set(l4)]), transportType: n4 }, i3.addTrace(Ps.subscribing_authenticated_session_topic);
        try {
          await this.client.core.relayer.subscribe(w4, { transportType: n4 });
        } catch (y6) {
          throw i3.setError(Rs.subscribe_authenticated_session_topic_failure), y6;
        }
        i3.addTrace(Ps.subscribe_authenticated_session_topic_success), await this.client.session.set(w4, m2), i3.addTrace(Ps.store_authenticated_session), await this.client.core.pairing.updateMetadata({ topic: r3.pairingTopic, metadata: r3.requester.metadata });
      }
      i3.addTrace(Ps.publishing_authenticated_session_approve);
      try {
        await this.sendResult({ topic: h4, id: t, result: { cacaos: s2, responder: { publicKey: c5, metadata: this.client.metadata } }, encodeOpts: p3, throwOnFailedPublish: true, appLink: this.getAppLinkIfEnabled(r3.requester.metadata, n4) });
      } catch (y6) {
        throw i3.setError(Rs.authenticated_session_approve_publish_failure), y6;
      }
      return await this.client.auth.requests.delete(t, { message: "fulfilled", code: 0 }), await this.client.core.pairing.activate({ topic: r3.pairingTopic }), this.client.core.eventClient.deleteEvent({ eventId: i3.eventId }), { session: m2 };
    }, this.rejectSessionAuthenticate = async (e2) => {
      this.isInitialized();
      const { id: t, reason: s2 } = e2, i3 = this.getPendingAuthRequest(t);
      if (!i3) throw new Error(`Could not find pending auth request with id ${t}`);
      i3.transportType === F.relay && await this.confirmOnlineStateOrThrow();
      const r3 = i3.requester.publicKey, n4 = await this.client.core.crypto.generateKeyPair(), a4 = Ru(r3), c5 = { type: pr, receiverPublicKey: r3, senderPublicKey: n4 };
      await this.sendError({ id: t, topic: a4, error: s2, encodeOpts: c5, rpcOpts: v2.wc_sessionAuthenticate.reject, appLink: this.getAppLinkIfEnabled(i3.requester.metadata, i3.transportType) }), await this.client.auth.requests.delete(t, { message: "rejected", code: 0 }), await this.client.proposal.delete(t, er("USER_DISCONNECTED"));
    }, this.formatAuthMessage = (e2) => {
      this.isInitialized();
      const { request: t, iss: s2 } = e2;
      return Wf(t, s2);
    }, this.processRelayMessageCache = () => {
      setTimeout(async () => {
        if (this.relayMessageCache.length !== 0) for (; this.relayMessageCache.length > 0; ) try {
          const e2 = this.relayMessageCache.shift();
          e2 && await this.onRelayMessage(e2);
        } catch (e2) {
          this.client.logger.error(e2);
        }
      }, 50);
    }, this.cleanupDuplicatePairings = async (e2) => {
      if (e2.pairingTopic) try {
        const t = this.client.core.pairing.pairings.get(e2.pairingTopic), s2 = this.client.core.pairing.pairings.getAll().filter((i3) => {
          var r3, n4;
          return ((r3 = i3.peerMetadata) == null ? void 0 : r3.url) && ((n4 = i3.peerMetadata) == null ? void 0 : n4.url) === e2.peer.metadata.url && i3.topic && i3.topic !== t.topic;
        });
        if (s2.length === 0) return;
        this.client.logger.info(`Cleaning up ${s2.length} duplicate pairing(s)`), await Promise.all(s2.map((i3) => this.client.core.pairing.disconnect({ topic: i3.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.deleteSession = async (e2) => {
      var t;
      const { topic: s2, expirerHasDeleted: i3 = false, emitEvent: r3 = true, id: n4 = 0 } = e2, { self: a4 } = this.client.session.get(s2);
      await this.client.core.relayer.unsubscribe(s2), await this.client.session.delete(s2, er("USER_DISCONNECTED")), this.addToRecentlyDeleted(s2, "session"), this.client.core.crypto.keychain.has(a4.publicKey) && await this.client.core.crypto.deleteKeyPair(a4.publicKey), this.client.core.crypto.keychain.has(s2) && await this.client.core.crypto.deleteSymKey(s2), i3 || this.client.core.expirer.del(s2), this.client.core.storage.removeItem(xe2).catch((c5) => this.client.logger.warn(c5)), this.getPendingSessionRequests().forEach((c5) => {
        c5.topic === s2 && this.deletePendingSessionRequest(c5.id, er("USER_DISCONNECTED"));
      }), s2 === ((t = this.sessionRequestQueue.queue[0]) == null ? void 0 : t.topic) && (this.sessionRequestQueue.state = x3.idle), r3 && this.client.events.emit("session_delete", { id: n4, topic: s2 });
    }, this.deleteProposal = async (e2, t) => {
      if (t) try {
        const s2 = this.client.proposal.get(e2), i3 = this.client.core.eventClient.getEvent({ topic: s2.pairingTopic });
        i3 == null ? void 0 : i3.setError(Ss2.proposal_expired);
      } catch {
      }
      await Promise.all([this.client.proposal.delete(e2, er("USER_DISCONNECTED")), t ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.addToRecentlyDeleted(e2, "proposal");
    }, this.deletePendingSessionRequest = async (e2, t, s2 = false) => {
      await Promise.all([this.client.pendingRequest.delete(e2, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e2)]), this.addToRecentlyDeleted(e2, "request"), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i3) => i3.id !== e2), s2 && (this.sessionRequestQueue.state = x3.idle, this.client.events.emit("session_request_expire", { id: e2 }));
    }, this.deletePendingAuthRequest = async (e2, t, s2 = false) => {
      await Promise.all([this.client.auth.requests.delete(e2, t), s2 ? Promise.resolve() : this.client.core.expirer.del(e2)]);
    }, this.setExpiry = async (e2, t) => {
      this.client.session.keys.includes(e2) && (this.client.core.expirer.set(e2, t), await this.client.session.update(e2, { expiry: t }));
    }, this.setProposal = async (e2, t) => {
      this.client.core.expirer.set(e2, ws(v2.wc_sessionPropose.req.ttl)), await this.client.proposal.set(e2, t);
    }, this.setAuthRequest = async (e2, t) => {
      const { request: s2, pairingTopic: i3, transportType: r3 = F.relay } = t;
      this.client.core.expirer.set(e2, s2.expiryTimestamp), await this.client.auth.requests.set(e2, { authPayload: s2.authPayload, requester: s2.requester, expiryTimestamp: s2.expiryTimestamp, id: e2, pairingTopic: i3, verifyContext: s2.verifyContext, transportType: r3 });
    }, this.setPendingSessionRequest = async (e2) => {
      const { id: t, topic: s2, params: i3, verifyContext: r3 } = e2, n4 = i3.request.expiryTimestamp || ws(v2.wc_sessionRequest.req.ttl);
      this.client.core.expirer.set(t, n4), await this.client.pendingRequest.set(t, { id: t, topic: s2, params: i3, verifyContext: r3 });
    }, this.sendRequest = async (e2) => {
      const { topic: t, method: s2, params: i3, expiry: r3, relayRpcId: n4, clientRpcId: a4, throwOnFailedPublish: c5, appLink: h4 } = e2, p3 = formatJsonRpcRequest(s2, i3, a4);
      let d3;
      const l4 = !!h4;
      try {
        const y6 = l4 ? Iu : tn;
        d3 = await this.client.core.crypto.encode(t, p3, { encoding: y6 });
      } catch (y6) {
        throw await this.cleanup(), this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`), y6;
      }
      let w4;
      if (at2.includes(s2)) {
        const y6 = Ou(JSON.stringify(p3)), _3 = Ou(d3);
        w4 = await this.client.core.verify.register({ id: _3, decryptedId: y6 });
      }
      const m2 = v2[s2].req;
      if (m2.attestation = w4, r3 && (m2.ttl = r3), n4 && (m2.id = n4), this.client.core.history.set(t, p3), l4) {
        const y6 = Zu(h4, t, d3);
        await global.Linking.openURL(y6, this.client.name);
      } else {
        const y6 = v2[s2].req;
        r3 && (y6.ttl = r3), n4 && (y6.id = n4), c5 ? (y6.internal = D2(I2({}, y6.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t, d3, y6)) : this.client.core.relayer.publish(t, d3, y6).catch((_3) => this.client.logger.error(_3));
      }
      return p3.id;
    }, this.sendResult = async (e2) => {
      const { id: t, topic: s2, result: i3, throwOnFailedPublish: r3, encodeOpts: n4, appLink: a4 } = e2, c5 = formatJsonRpcResult(t, i3);
      let h4;
      const p3 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p3 ? Iu : tn;
        h4 = await this.client.core.crypto.encode(s2, c5, D2(I2({}, n4 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d3;
      try {
        d3 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendResult() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p3) {
        const l4 = Zu(a4, s2, h4);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = v2[d3.request.method].res;
        r3 ? (l4.internal = D2(I2({}, l4.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s2, h4, l4)) : this.client.core.relayer.publish(s2, h4, l4).catch((w4) => this.client.logger.error(w4));
      }
      await this.client.core.history.resolve(c5);
    }, this.sendError = async (e2) => {
      const { id: t, topic: s2, error: i3, encodeOpts: r3, rpcOpts: n4, appLink: a4 } = e2, c5 = formatJsonRpcError(t, i3);
      let h4;
      const p3 = a4 && typeof (global == null ? void 0 : global.Linking) < "u";
      try {
        const l4 = p3 ? Iu : tn;
        h4 = await this.client.core.crypto.encode(s2, c5, D2(I2({}, r3 || {}), { encoding: l4 }));
      } catch (l4) {
        throw await this.cleanup(), this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s2} failed`), l4;
      }
      let d3;
      try {
        d3 = await this.client.core.history.get(s2, t);
      } catch (l4) {
        throw this.client.logger.error(`sendError() -> history.get(${s2}, ${t}) failed`), l4;
      }
      if (p3) {
        const l4 = Zu(a4, s2, h4);
        await global.Linking.openURL(l4, this.client.name);
      } else {
        const l4 = n4 || v2[d3.request.method].res;
        this.client.core.relayer.publish(s2, h4, l4);
      }
      await this.client.core.history.resolve(c5);
    }, this.cleanup = async () => {
      const e2 = [], t = [];
      this.client.session.getAll().forEach((s2) => {
        let i3 = false;
        xs(s2.expiry) && (i3 = true), this.client.core.crypto.keychain.has(s2.topic) || (i3 = true), i3 && e2.push(s2.topic);
      }), this.client.proposal.getAll().forEach((s2) => {
        xs(s2.expiryTimestamp) && t.push(s2.id);
      }), await Promise.all([...e2.map((s2) => this.deleteSession({ topic: s2 })), ...t.map((s2) => this.deleteProposal(s2))]);
    }, this.onRelayEventRequest = async (e2) => {
      this.requestQueue.queue.push(e2), await this.processRequestsQueue();
    }, this.processRequestsQueue = async () => {
      if (this.requestQueue.state === x3.active) {
        this.client.logger.info("Request queue already active, skipping...");
        return;
      }
      for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
        this.requestQueue.state = x3.active;
        const e2 = this.requestQueue.queue.shift();
        if (e2) try {
          await this.processRequest(e2);
        } catch (t) {
          this.client.logger.warn(t);
        }
      }
      this.requestQueue.state = x3.idle;
    }, this.processRequest = async (e2) => {
      const { topic: t, payload: s2, attestation: i3, transportType: r3, encryptedId: n4 } = e2, a4 = s2.method;
      if (!this.shouldIgnorePairingRequest({ topic: t, requestMethod: a4 })) switch (a4) {
        case "wc_sessionPropose":
          return await this.onSessionProposeRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4 });
        case "wc_sessionSettle":
          return await this.onSessionSettleRequest(t, s2);
        case "wc_sessionUpdate":
          return await this.onSessionUpdateRequest(t, s2);
        case "wc_sessionExtend":
          return await this.onSessionExtendRequest(t, s2);
        case "wc_sessionPing":
          return await this.onSessionPingRequest(t, s2);
        case "wc_sessionDelete":
          return await this.onSessionDeleteRequest(t, s2);
        case "wc_sessionRequest":
          return await this.onSessionRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        case "wc_sessionEvent":
          return await this.onSessionEventRequest(t, s2);
        case "wc_sessionAuthenticate":
          return await this.onSessionAuthenticateRequest({ topic: t, payload: s2, attestation: i3, encryptedId: n4, transportType: r3 });
        default:
          return this.client.logger.info(`Unsupported request method ${a4}`);
      }
    }, this.onRelayEventResponse = async (e2) => {
      const { topic: t, payload: s2, transportType: i3 } = e2, r3 = (await this.client.core.history.get(t, s2.id)).request.method;
      switch (r3) {
        case "wc_sessionPropose":
          return this.onSessionProposeResponse(t, s2, i3);
        case "wc_sessionSettle":
          return this.onSessionSettleResponse(t, s2);
        case "wc_sessionUpdate":
          return this.onSessionUpdateResponse(t, s2);
        case "wc_sessionExtend":
          return this.onSessionExtendResponse(t, s2);
        case "wc_sessionPing":
          return this.onSessionPingResponse(t, s2);
        case "wc_sessionRequest":
          return this.onSessionRequestResponse(t, s2);
        case "wc_sessionAuthenticate":
          return this.onSessionAuthenticateResponse(t, s2);
        default:
          return this.client.logger.info(`Unsupported response method ${r3}`);
      }
    }, this.onRelayEventUnknownPayload = (e2) => {
      const { topic: t } = e2, { message: s2 } = xe("MISSING_OR_INVALID", `Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);
      throw new Error(s2);
    }, this.shouldIgnorePairingRequest = (e2) => {
      const { topic: t, requestMethod: s2 } = e2, i3 = this.expectedPairingMethodMap.get(t);
      return !i3 || i3.includes(s2) ? false : !!(i3.includes("wc_sessionAuthenticate") && this.client.events.listenerCount("session_authenticate") > 0);
    }, this.onSessionProposeRequest = async (e2) => {
      const { topic: t, payload: s2, attestation: i3, encryptedId: r3 } = e2, { params: n4, id: a4 } = s2;
      try {
        const c5 = this.client.core.eventClient.getEvent({ topic: t });
        this.isValidConnect(I2({}, s2.params));
        const h4 = n4.expiryTimestamp || ws(v2.wc_sessionPropose.req.ttl), p3 = I2({ id: a4, pairingTopic: t, expiryTimestamp: h4 }, n4);
        await this.setProposal(a4, p3);
        const d3 = await this.getVerifyContext({ attestationId: i3, hash: Ou(JSON.stringify(s2)), encryptedId: r3, metadata: p3.proposer.metadata });
        this.client.events.listenerCount("session_proposal") === 0 && (console.warn("No listener for session_proposal event"), c5 == null ? void 0 : c5.setError(M2.proposal_listener_not_found)), c5 == null ? void 0 : c5.addTrace(z2.emit_session_proposal), this.client.events.emit("session_proposal", { id: a4, params: p3, verifyContext: d3 });
      } catch (c5) {
        await this.sendError({ id: a4, topic: t, error: c5, rpcOpts: v2.wc_sessionPropose.autoReject }), this.client.logger.error(c5);
      }
    }, this.onSessionProposeResponse = async (e2, t, s2) => {
      const { id: i3 } = t;
      if (isJsonRpcResult(t)) {
        const { result: r3 } = t;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: r3 });
        const n4 = this.client.proposal.get(i3);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n4 });
        const a4 = n4.proposer.publicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: a4 });
        const c5 = r3.responderPublicKey;
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: c5 });
        const h4 = await this.client.core.crypto.generateSharedKey(a4, c5);
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: h4 });
        const p3 = await this.client.core.relayer.subscribe(h4, { transportType: s2 });
        this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p3 }), await this.client.core.pairing.activate({ topic: e2 });
      } else if (isJsonRpcError(t)) {
        await this.client.proposal.delete(i3, er("USER_DISCONNECTED"));
        const r3 = Ms("session_connect");
        if (this.events.listenerCount(r3) === 0) throw new Error(`emitting ${r3} without any listeners, 954`);
        this.events.emit(Ms("session_connect"), { error: t.error });
      }
    }, this.onSessionSettleRequest = async (e2, t) => {
      const { id: s2, params: i3 } = t;
      try {
        this.isValidSessionSettleRequest(i3);
        const { relay: r3, controller: n4, expiry: a4, namespaces: c5, sessionProperties: h4, sessionConfig: p3 } = t.params, d3 = D2(I2(I2({ topic: e2, relay: r3, expiry: a4, namespaces: c5, acknowledged: true, pairingTopic: "", requiredNamespaces: {}, optionalNamespaces: {}, controller: n4.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: n4.publicKey, metadata: n4.metadata } }, h4 && { sessionProperties: h4 }), p3 && { sessionConfig: p3 }), { transportType: F.relay }), l4 = Ms("session_connect");
        if (this.events.listenerCount(l4) === 0) throw new Error(`emitting ${l4} without any listeners 997`);
        this.events.emit(Ms("session_connect"), { session: d3 }), await this.sendResult({ id: t.id, topic: e2, result: true, throwOnFailedPublish: true });
      } catch (r3) {
        await this.sendError({ id: s2, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionSettleResponse = async (e2, t) => {
      const { id: s2 } = t;
      isJsonRpcResult(t) ? (await this.client.session.update(e2, { acknowledged: true }), this.events.emit(Ms("session_approve", s2), {})) : isJsonRpcError(t) && (await this.client.session.delete(e2, er("USER_DISCONNECTED")), this.events.emit(Ms("session_approve", s2), { error: t.error }));
    }, this.onSessionUpdateRequest = async (e2, t) => {
      const { params: s2, id: i3 } = t;
      try {
        const r3 = `${e2}_session_update`, n4 = Rh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, i3)) {
          this.client.logger.info(`Discarding out of sync request - ${i3}`), this.sendError({ id: i3, topic: e2, error: er("INVALID_UPDATE_REQUEST") });
          return;
        }
        this.isValidUpdate(I2({ topic: e2 }, s2));
        try {
          Rh.set(r3, i3), await this.client.session.update(e2, { namespaces: s2.namespaces }), await this.sendResult({ id: i3, topic: e2, result: true, throwOnFailedPublish: true });
        } catch (a4) {
          throw Rh.delete(r3), a4;
        }
        this.client.events.emit("session_update", { id: i3, topic: e2, params: s2 });
      } catch (r3) {
        await this.sendError({ id: i3, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.isRequestOutOfSync = (e2, t) => parseInt(t.toString().slice(0, -3)) <= parseInt(e2.toString().slice(0, -3)), this.onSessionUpdateResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_update", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms("session_update", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms("session_update", s2), { error: t.error });
    }, this.onSessionExtendRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidExtend({ topic: e2 }), await this.setExpiry(e2, ws(z3)), await this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_extend", { id: s2, topic: e2 });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e2, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionExtendResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_extend", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms("session_extend", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms("session_extend", s2), { error: t.error });
    }, this.onSessionPingRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidPing({ topic: e2 }), await this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.client.events.emit("session_ping", { id: s2, topic: e2 });
      } catch (i3) {
        await this.sendError({ id: s2, topic: e2, error: i3 }), this.client.logger.error(i3);
      }
    }, this.onSessionPingResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_ping", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      setTimeout(() => {
        isJsonRpcResult(t) ? this.events.emit(Ms("session_ping", s2), {}) : isJsonRpcError(t) && this.events.emit(Ms("session_ping", s2), { error: t.error });
      }, 500);
    }, this.onSessionDeleteRequest = async (e2, t) => {
      const { id: s2 } = t;
      try {
        this.isValidDisconnect({ topic: e2, reason: t.params }), Promise.all([new Promise((i3) => {
          this.client.core.relayer.once(w2.publish, async () => {
            i3(await this.deleteSession({ topic: e2, id: s2 }));
          });
        }), this.sendResult({ id: s2, topic: e2, result: true, throwOnFailedPublish: true }), this.cleanupPendingSentRequestsForTopic({ topic: e2, error: er("USER_DISCONNECTED") })]).catch((i3) => this.client.logger.error(i3));
      } catch (i3) {
        this.client.logger.error(i3);
      }
    }, this.onSessionRequest = async (e2) => {
      var t, s2, i3;
      const { topic: r3, payload: n4, attestation: a4, encryptedId: c5, transportType: h4 } = e2, { id: p3, params: d3 } = n4;
      try {
        await this.isValidRequest(I2({ topic: r3 }, d3));
        const l4 = this.client.session.get(r3), w4 = await this.getVerifyContext({ attestationId: a4, hash: Ou(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", d3, p3))), encryptedId: c5, metadata: l4.peer.metadata, transportType: h4 }), m2 = { id: p3, topic: r3, params: d3, verifyContext: w4 };
        await this.setPendingSessionRequest(m2), h4 === F.link_mode && (t = l4.peer.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp((s2 = l4.peer.metadata.redirect) == null ? void 0 : s2.universal), (i3 = this.client.signConfig) != null && i3.disableRequestQueue ? this.emitSessionRequest(m2) : (this.addSessionRequestToSessionRequestQueue(m2), this.processSessionRequestQueue());
      } catch (l4) {
        await this.sendError({ id: p3, topic: r3, error: l4 }), this.client.logger.error(l4);
      }
    }, this.onSessionRequestResponse = (e2, t) => {
      const { id: s2 } = t, i3 = Ms("session_request", s2);
      if (this.events.listenerCount(i3) === 0) throw new Error(`emitting ${i3} without any listeners`);
      isJsonRpcResult(t) ? this.events.emit(Ms("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Ms("session_request", s2), { error: t.error });
    }, this.onSessionEventRequest = async (e2, t) => {
      const { id: s2, params: i3 } = t;
      try {
        const r3 = `${e2}_session_event_${i3.event.name}`, n4 = Rh.get(r3);
        if (n4 && this.isRequestOutOfSync(n4, s2)) {
          this.client.logger.info(`Discarding out of sync request - ${s2}`);
          return;
        }
        this.isValidEmit(I2({ topic: e2 }, i3)), this.client.events.emit("session_event", { id: s2, topic: e2, params: i3 }), Rh.set(r3, s2);
      } catch (r3) {
        await this.sendError({ id: s2, topic: e2, error: r3 }), this.client.logger.error(r3);
      }
    }, this.onSessionAuthenticateResponse = (e2, t) => {
      const { id: s2 } = t;
      this.client.logger.trace({ type: "method", method: "onSessionAuthenticateResponse", topic: e2, payload: t }), isJsonRpcResult(t) ? this.events.emit(Ms("session_request", s2), { result: t.result }) : isJsonRpcError(t) && this.events.emit(Ms("session_request", s2), { error: t.error });
    }, this.onSessionAuthenticateRequest = async (e2) => {
      var t;
      const { topic: s2, payload: i3, attestation: r3, encryptedId: n4, transportType: a4 } = e2;
      try {
        const { requester: c5, authPayload: h4, expiryTimestamp: p3 } = i3.params, d3 = await this.getVerifyContext({ attestationId: r3, hash: Ou(JSON.stringify(i3)), encryptedId: n4, metadata: c5.metadata, transportType: a4 }), l4 = { requester: c5, pairingTopic: s2, id: i3.id, authPayload: h4, verifyContext: d3, expiryTimestamp: p3 };
        await this.setAuthRequest(i3.id, { request: l4, pairingTopic: s2, transportType: a4 }), a4 === F.link_mode && (t = c5.metadata.redirect) != null && t.universal && this.client.core.addLinkModeSupportedApp(c5.metadata.redirect.universal), this.client.events.emit("session_authenticate", { topic: s2, params: i3.params, id: i3.id, verifyContext: d3 });
      } catch (c5) {
        this.client.logger.error(c5);
        const h4 = i3.params.requester.publicKey, p3 = await this.client.core.crypto.generateKeyPair(), d3 = this.getAppLinkIfEnabled(i3.params.requester.metadata, a4), l4 = { type: pr, receiverPublicKey: h4, senderPublicKey: p3 };
        await this.sendError({ id: i3.id, topic: s2, error: c5, encodeOpts: l4, rpcOpts: v2.wc_sessionAuthenticate.autoReject, appLink: d3 });
      }
    }, this.addSessionRequestToSessionRequestQueue = (e2) => {
      this.sessionRequestQueue.queue.push(e2);
    }, this.cleanupAfterResponse = (e2) => {
      this.deletePendingSessionRequest(e2.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
        this.sessionRequestQueue.state = x3.idle, this.processSessionRequestQueue();
      }, (0, import_time3.toMiliseconds)(this.requestQueueDelay));
    }, this.cleanupPendingSentRequestsForTopic = ({ topic: e2, error: t }) => {
      const s2 = this.client.core.history.pending;
      s2.length > 0 && s2.filter((i3) => i3.topic === e2 && i3.request.method === "wc_sessionRequest").forEach((i3) => {
        const r3 = i3.request.id, n4 = Ms("session_request", r3);
        if (this.events.listenerCount(n4) === 0) throw new Error(`emitting ${n4} without any listeners`);
        this.events.emit(Ms("session_request", i3.request.id), { error: t });
      });
    }, this.processSessionRequestQueue = () => {
      if (this.sessionRequestQueue.state === x3.active) {
        this.client.logger.info("session request queue is already active.");
        return;
      }
      const e2 = this.sessionRequestQueue.queue[0];
      if (!e2) {
        this.client.logger.info("session request queue is empty.");
        return;
      }
      try {
        this.sessionRequestQueue.state = x3.active, this.emitSessionRequest(e2);
      } catch (t) {
        this.client.logger.error(t);
      }
    }, this.emitSessionRequest = (e2) => {
      this.client.events.emit("session_request", e2);
    }, this.onPairingCreated = (e2) => {
      if (e2.methods && this.expectedPairingMethodMap.set(e2.topic, e2.methods), e2.active) return;
      const t = this.client.proposal.getAll().find((s2) => s2.pairingTopic === e2.topic);
      t && this.onSessionProposeRequest({ topic: e2.topic, payload: formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: t.requiredNamespaces, optionalNamespaces: t.optionalNamespaces, relays: t.relays, proposer: t.proposer, sessionProperties: t.sessionProperties }, t.id) });
    }, this.isValidConnect = async (e2) => {
      if (!Ah(e2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e2)}`);
        throw new Error(a4);
      }
      const { pairingTopic: t, requiredNamespaces: s2, optionalNamespaces: i3, sessionProperties: r3, relays: n4 } = e2;
      if (Pe(t) || await this.isValidPairingTopic(t), !gh(n4, true)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `connect() relays: ${n4}`);
        throw new Error(a4);
      }
      !Pe(s2) && Xr(s2) !== 0 && this.validateNamespaces(s2, "requiredNamespaces"), !Pe(i3) && Xr(i3) !== 0 && this.validateNamespaces(i3, "optionalNamespaces"), Pe(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.validateNamespaces = (e2, t) => {
      const s2 = vh(e2, "connect()", t);
      if (s2) throw new Error(s2.message);
    }, this.isValidApprove = async (e2) => {
      if (!Ah(e2)) throw new Error(xe("MISSING_OR_INVALID", `approve() params: ${e2}`).message);
      const { id: t, namespaces: s2, relayProtocol: i3, sessionProperties: r3 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidProposalId(t);
      const n4 = this.client.proposal.get(t), a4 = Oo(s2, "approve()");
      if (a4) throw new Error(a4.message);
      const c5 = To(n4.requiredNamespaces, s2, "approve()");
      if (c5) throw new Error(c5.message);
      if (!Yt(i3, true)) {
        const { message: h4 } = xe("MISSING_OR_INVALID", `approve() relayProtocol: ${i3}`);
        throw new Error(h4);
      }
      Pe(r3) || this.validateSessionProps(r3, "sessionProperties");
    }, this.isValidReject = async (e2) => {
      if (!Ah(e2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() params: ${e2}`);
        throw new Error(i3);
      }
      const { id: t, reason: s2 } = e2;
      if (this.checkRecentlyDeleted(t), await this.isValidProposalId(t), !bh(s2)) {
        const { message: i3 } = xe("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(s2)}`);
        throw new Error(i3);
      }
    }, this.isValidSessionSettleRequest = (e2) => {
      if (!Ah(e2)) {
        const { message: c5 } = xe("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e2}`);
        throw new Error(c5);
      }
      const { relay: t, controller: s2, namespaces: i3, expiry: r3 } = e2;
      if (!Po(t)) {
        const { message: c5 } = xe("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
        throw new Error(c5);
      }
      const n4 = ph(s2, "onSessionSettleRequest()");
      if (n4) throw new Error(n4.message);
      const a4 = Oo(i3, "onSessionSettleRequest()");
      if (a4) throw new Error(a4.message);
      if (xs(r3)) {
        const { message: c5 } = xe("EXPIRED", "onSessionSettleRequest()");
        throw new Error(c5);
      }
    }, this.isValidUpdate = async (e2) => {
      if (!Ah(e2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `update() params: ${e2}`);
        throw new Error(a4);
      }
      const { topic: t, namespaces: s2 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const i3 = this.client.session.get(t), r3 = Oo(s2, "update()");
      if (r3) throw new Error(r3.message);
      const n4 = To(i3.requiredNamespaces, s2, "update()");
      if (n4) throw new Error(n4.message);
    }, this.isValidExtend = async (e2) => {
      if (!Ah(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `extend() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
    }, this.isValidRequest = async (e2) => {
      if (!Ah(e2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() params: ${e2}`);
        throw new Error(a4);
      }
      const { topic: t, request: s2, chainId: i3, expiry: r3 } = e2;
      this.checkRecentlyDeleted(t), await this.isValidSessionTopic(t);
      const { namespaces: n4 } = this.client.session.get(t);
      if (!Mh(n4, i3)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() chainId: ${i3}`);
        throw new Error(a4);
      }
      if (!yh(s2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() ${JSON.stringify(s2)}`);
        throw new Error(a4);
      }
      if (!Eh(n4, i3, s2.method)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() method: ${s2.method}`);
        throw new Error(a4);
      }
      if (r3 && !_h(r3, me2)) {
        const { message: a4 } = xe("MISSING_OR_INVALID", `request() expiry: ${r3}. Expiry must be a number (in seconds) between ${me2.min} and ${me2.max}`);
        throw new Error(a4);
      }
    }, this.isValidRespond = async (e2) => {
      var t;
      if (!Ah(e2)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() params: ${e2}`);
        throw new Error(r3);
      }
      const { topic: s2, response: i3 } = e2;
      try {
        await this.isValidSessionTopic(s2);
      } catch (r3) {
        throw (t = e2 == null ? void 0 : e2.response) != null && t.id && this.cleanupAfterResponse(e2), r3;
      }
      if (!wh(i3)) {
        const { message: r3 } = xe("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(i3)}`);
        throw new Error(r3);
      }
    }, this.isValidPing = async (e2) => {
      if (!Ah(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `ping() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidEmit = async (e2) => {
      if (!Ah(e2)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() params: ${e2}`);
        throw new Error(n4);
      }
      const { topic: t, event: s2, chainId: i3 } = e2;
      await this.isValidSessionTopic(t);
      const { namespaces: r3 } = this.client.session.get(t);
      if (!Mh(r3, i3)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() chainId: ${i3}`);
        throw new Error(n4);
      }
      if (!xh(s2)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
      if (!Sh(r3, i3, s2.name)) {
        const { message: n4 } = xe("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(s2)}`);
        throw new Error(n4);
      }
    }, this.isValidDisconnect = async (e2) => {
      if (!Ah(e2)) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `disconnect() params: ${e2}`);
        throw new Error(s2);
      }
      const { topic: t } = e2;
      await this.isValidSessionOrPairingTopic(t);
    }, this.isValidAuthenticate = (e2) => {
      const { chains: t, uri: s2, domain: i3, nonce: r3 } = e2;
      if (!Array.isArray(t) || t.length === 0) throw new Error("chains is required and must be a non-empty array");
      if (!Yt(s2, false)) throw new Error("uri is required parameter");
      if (!Yt(i3, false)) throw new Error("domain is required parameter");
      if (!Yt(r3, false)) throw new Error("nonce is required parameter");
      if ([...new Set(t.map((a4) => An(a4).namespace))].length > 1) throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");
      const { namespace: n4 } = An(t[0]);
      if (n4 !== "eip155") throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.");
    }, this.getVerifyContext = async (e2) => {
      const { attestationId: t, hash: s2, encryptedId: i3, metadata: r3, transportType: n4 } = e2, a4 = { verified: { verifyUrl: r3.verifyUrl || Z, validation: "UNKNOWN", origin: r3.url || "" } };
      try {
        if (n4 === F.link_mode) {
          const h4 = this.getAppLinkIfEnabled(r3, n4);
          return a4.verified.validation = h4 && new URL(h4).origin === new URL(r3.url).origin ? "VALID" : "INVALID", a4;
        }
        const c5 = await this.client.core.verify.resolve({ attestationId: t, hash: s2, encryptedId: i3, verifyUrl: r3.verifyUrl });
        c5 && (a4.verified.origin = c5.origin, a4.verified.isScam = c5.isScam, a4.verified.validation = c5.origin === new URL(r3.url).origin ? "VALID" : "INVALID");
      } catch (c5) {
        this.client.logger.warn(c5);
      }
      return this.client.logger.debug(`Verify context: ${JSON.stringify(a4)}`), a4;
    }, this.validateSessionProps = (e2, t) => {
      Object.values(e2).forEach((s2) => {
        if (!Yt(s2, false)) {
          const { message: i3 } = xe("MISSING_OR_INVALID", `${t} must be in Record<string, string> format. Received: ${JSON.stringify(s2)}`);
          throw new Error(i3);
        }
      });
    }, this.getPendingAuthRequest = (e2) => {
      const t = this.client.auth.requests.get(e2);
      return typeof t == "object" ? t : void 0;
    }, this.addToRecentlyDeleted = (e2, t) => {
      if (this.recentlyDeletedMap.set(e2, t), this.recentlyDeletedMap.size >= this.recentlyDeletedLimit) {
        let s2 = 0;
        const i3 = this.recentlyDeletedLimit / 2;
        for (const r3 of this.recentlyDeletedMap.keys()) {
          if (s2++ >= i3) break;
          this.recentlyDeletedMap.delete(r3);
        }
      }
    }, this.checkRecentlyDeleted = (e2) => {
      const t = this.recentlyDeletedMap.get(e2);
      if (t) {
        const { message: s2 } = xe("MISSING_OR_INVALID", `Record was recently deleted - ${t}: ${e2}`);
        throw new Error(s2);
      }
    }, this.isLinkModeEnabled = (e2, t) => {
      var s2, i3, r3, n4, a4, c5, h4, p3, d3;
      return !e2 || t !== F.link_mode ? false : ((i3 = (s2 = this.client.metadata) == null ? void 0 : s2.redirect) == null ? void 0 : i3.linkMode) === true && ((n4 = (r3 = this.client.metadata) == null ? void 0 : r3.redirect) == null ? void 0 : n4.universal) !== void 0 && ((c5 = (a4 = this.client.metadata) == null ? void 0 : a4.redirect) == null ? void 0 : c5.universal) !== "" && ((h4 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : h4.universal) !== void 0 && ((p3 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : p3.universal) !== "" && ((d3 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : d3.linkMode) === true && this.client.core.linkModeSupportedApps.includes(e2.redirect.universal) && typeof (global == null ? void 0 : global.Linking) < "u";
    }, this.getAppLinkIfEnabled = (e2, t) => {
      var s2;
      return this.isLinkModeEnabled(e2, t) ? (s2 = e2 == null ? void 0 : e2.redirect) == null ? void 0 : s2.universal : void 0;
    }, this.handleLinkModeMessage = ({ url: e2 }) => {
      if (!e2 || !e2.includes("wc_ev") || !e2.includes("topic")) return;
      const t = Is(e2, "topic") || "", s2 = decodeURIComponent(Is(e2, "wc_ev") || ""), i3 = this.client.session.keys.includes(t);
      i3 && this.client.session.update(t, { transportType: F.link_mode }), this.client.core.dispatchEnvelope({ topic: t, message: s2, sessionExists: i3 });
    }, this.registerLinkModeListeners = async () => {
      var e2;
      if (_s() || rr() && (e2 = this.client.metadata.redirect) != null && e2.linkMode) {
        const t = global == null ? void 0 : global.Linking;
        if (typeof t < "u") {
          t.addEventListener("url", this.handleLinkModeMessage, this.client.name);
          const s2 = await t.getInitialURL();
          s2 && setTimeout(() => {
            this.handleLinkModeMessage({ url: s2 });
          }, 50);
        }
      }
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: o5 } = xe("NOT_INITIALIZED", this.name);
      throw new Error(o5);
    }
  }
  async confirmOnlineStateOrThrow() {
    await this.client.core.relayer.confirmOnlineStateOrThrow();
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(w2.message, (o5) => {
      !this.initialized || this.relayMessageCache.length > 0 ? this.relayMessageCache.push(o5) : this.onRelayMessage(o5);
    });
  }
  async onRelayMessage(o5) {
    const { topic: e2, message: t, attestation: s2, transportType: i3 } = o5, { publicKey: r3 } = this.client.auth.authKeys.keys.includes(ae2) ? this.client.auth.authKeys.get(ae2) : { responseTopic: void 0, publicKey: void 0 }, n4 = await this.client.core.crypto.decode(e2, t, { receiverPublicKey: r3, encoding: i3 === F.link_mode ? Iu : tn });
    try {
      isJsonRpcRequest(n4) ? (this.client.core.history.set(e2, n4), this.onRelayEventRequest({ topic: e2, payload: n4, attestation: s2, transportType: i3, encryptedId: Ou(t) })) : isJsonRpcResponse(n4) ? (await this.client.core.history.resolve(n4), await this.onRelayEventResponse({ topic: e2, payload: n4, transportType: i3 }), this.client.core.history.delete(e2, n4.id)) : this.onRelayEventUnknownPayload({ topic: e2, payload: n4, transportType: i3 });
    } catch (a4) {
      this.client.logger.error(a4);
    }
  }
  registerExpirerEvents() {
    this.client.core.expirer.on(R.expired, async (o5) => {
      const { topic: e2, id: t } = ys(o5.target);
      if (t && this.client.pendingRequest.keys.includes(t)) return await this.deletePendingSessionRequest(t, xe("EXPIRED"), true);
      if (t && this.client.auth.requests.keys.includes(t)) return await this.deletePendingAuthRequest(t, xe("EXPIRED"), true);
      e2 ? this.client.session.keys.includes(e2) && (await this.deleteSession({ topic: e2, expirerHasDeleted: true }), this.client.events.emit("session_expire", { topic: e2 })) : t && (await this.deleteProposal(t, true), this.client.events.emit("proposal_expire", { id: t }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(q.create, (o5) => this.onPairingCreated(o5)), this.client.core.pairing.events.on(q.delete, (o5) => {
      this.addToRecentlyDeleted(o5.topic, "pairing");
    });
  }
  isValidPairingTopic(o5) {
    if (!Yt(o5, false)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `pairing topic should be a string: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.core.pairing.pairings.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `pairing topic doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (xs(this.client.core.pairing.pairings.get(o5).expiry)) {
      const { message: e2 } = xe("EXPIRED", `pairing topic: ${o5}`);
      throw new Error(e2);
    }
  }
  async isValidSessionTopic(o5) {
    if (!Yt(o5, false)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session topic should be a string: ${o5}`);
      throw new Error(e2);
    }
    if (this.checkRecentlyDeleted(o5), !this.client.session.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `session topic doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (xs(this.client.session.get(o5).expiry)) {
      await this.deleteSession({ topic: o5 });
      const { message: e2 } = xe("EXPIRED", `session topic: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.core.crypto.keychain.has(o5)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session topic does not exist in keychain: ${o5}`);
      throw await this.deleteSession({ topic: o5 }), new Error(e2);
    }
  }
  async isValidSessionOrPairingTopic(o5) {
    if (this.checkRecentlyDeleted(o5), this.client.session.keys.includes(o5)) await this.isValidSessionTopic(o5);
    else if (this.client.core.pairing.pairings.keys.includes(o5)) this.isValidPairingTopic(o5);
    else if (Yt(o5, false)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${o5}`);
      throw new Error(e2);
    } else {
      const { message: e2 } = xe("MISSING_OR_INVALID", `session or pairing topic should be a string: ${o5}`);
      throw new Error(e2);
    }
  }
  async isValidProposalId(o5) {
    if (!mh(o5)) {
      const { message: e2 } = xe("MISSING_OR_INVALID", `proposal id should be a number: ${o5}`);
      throw new Error(e2);
    }
    if (!this.client.proposal.keys.includes(o5)) {
      const { message: e2 } = xe("NO_MATCHING_KEY", `proposal id doesn't exist: ${o5}`);
      throw new Error(e2);
    }
    if (xs(this.client.proposal.get(o5).expiryTimestamp)) {
      await this.deleteProposal(o5);
      const { message: e2 } = xe("EXPIRED", `proposal id: ${o5}`);
      throw new Error(e2);
    }
  }
};
var Ss3 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, st2, ye), this.core = o5, this.logger = e2;
  }
};
var yt2 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, rt2, ye), this.core = o5, this.logger = e2;
  }
};
var Is3 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, ot2, ye, (t) => t.id), this.core = o5, this.logger = e2;
  }
};
var fs2 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, pt2, oe2, () => ae2), this.core = o5, this.logger = e2;
  }
};
var vs = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, ht2, oe2), this.core = o5, this.logger = e2;
  }
};
var qs2 = class extends ai {
  constructor(o5, e2) {
    super(o5, e2, dt2, oe2, (t) => t.id), this.core = o5, this.logger = e2;
  }
};
var Ts = class {
  constructor(o5, e2) {
    this.core = o5, this.logger = e2, this.authKeys = new fs2(this.core, this.logger), this.pairingTopics = new vs(this.core, this.logger), this.requests = new qs2(this.core, this.logger);
  }
  async init() {
    await this.authKeys.init(), await this.pairingTopics.init(), await this.requests.init();
  }
};
var _e2 = class __e extends S {
  constructor(o5) {
    super(o5), this.protocol = be2, this.version = Ce2, this.name = we2.name, this.events = new import_events8.EventEmitter(), this.on = (t, s2) => this.events.on(t, s2), this.once = (t, s2) => this.events.once(t, s2), this.off = (t, s2) => this.events.off(t, s2), this.removeListener = (t, s2) => this.events.removeListener(t, s2), this.removeAllListeners = (t) => this.events.removeAllListeners(t), this.connect = async (t) => {
      try {
        return await this.engine.connect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approve = async (t) => {
      try {
        return await this.engine.approve(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.reject = async (t) => {
      try {
        return await this.engine.reject(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.update = async (t) => {
      try {
        return await this.engine.update(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.extend = async (t) => {
      try {
        return await this.engine.extend(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.request = async (t) => {
      try {
        return await this.engine.request(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.respond = async (t) => {
      try {
        return await this.engine.respond(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.ping = async (t) => {
      try {
        return await this.engine.ping(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.emit = async (t) => {
      try {
        return await this.engine.emit(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.disconnect = async (t) => {
      try {
        return await this.engine.disconnect(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.find = (t) => {
      try {
        return this.engine.find(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.authenticate = async (t, s2) => {
      try {
        return await this.engine.authenticate(t, s2);
      } catch (i3) {
        throw this.logger.error(i3.message), i3;
      }
    }, this.formatAuthMessage = (t) => {
      try {
        return this.engine.formatAuthMessage(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.approveSessionAuthenticate = async (t) => {
      try {
        return await this.engine.approveSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.rejectSessionAuthenticate = async (t) => {
      try {
        return await this.engine.rejectSessionAuthenticate(t);
      } catch (s2) {
        throw this.logger.error(s2.message), s2;
      }
    }, this.name = (o5 == null ? void 0 : o5.name) || we2.name, this.metadata = (o5 == null ? void 0 : o5.metadata) || fs(), this.signConfig = o5 == null ? void 0 : o5.signConfig;
    const e2 = typeof (o5 == null ? void 0 : o5.logger) < "u" && typeof (o5 == null ? void 0 : o5.logger) != "string" ? o5.logger : (0, import_pino.default)(k({ level: (o5 == null ? void 0 : o5.logger) || we2.logger }));
    this.core = (o5 == null ? void 0 : o5.core) || new On(o5), this.logger = E(e2, this.name), this.session = new yt2(this.core, this.logger), this.proposal = new Ss3(this.core, this.logger), this.pendingRequest = new Is3(this.core, this.logger), this.engine = new Rs2(this), this.auth = new Ts(this.core, this.logger);
  }
  static async init(o5) {
    const e2 = new __e(o5);
    return await e2.initialize(), e2;
  }
  get context() {
    return y(this.logger);
  }
  get pairing() {
    return this.core.pairing.pairings;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.auth.init(), await this.engine.init(), this.logger.info("SignClient Initialization Success"), this.engine.processRelayMessageCache();
    } catch (o5) {
      throw this.logger.info("SignClient Initialization Failure"), this.logger.error(o5.message), o5;
    }
  }
};

// node_modules/@walletconnect/jsonrpc-http-connection/dist/index.es.js
var import_events9 = __toESM(require_events());
var import_cross_fetch = __toESM(require_browser_ponyfill());
var P2 = Object.defineProperty;
var w3 = Object.defineProperties;
var E3 = Object.getOwnPropertyDescriptors;
var c4 = Object.getOwnPropertySymbols;
var L = Object.prototype.hasOwnProperty;
var O3 = Object.prototype.propertyIsEnumerable;
var l3 = (r3, t, e2) => t in r3 ? P2(r3, t, { enumerable: true, configurable: true, writable: true, value: e2 }) : r3[t] = e2;
var p2 = (r3, t) => {
  for (var e2 in t || (t = {})) L.call(t, e2) && l3(r3, e2, t[e2]);
  if (c4) for (var e2 of c4(t)) O3.call(t, e2) && l3(r3, e2, t[e2]);
  return r3;
};
var v3 = (r3, t) => w3(r3, E3(t));
var j3 = { Accept: "application/json", "Content-Type": "application/json" };
var T2 = "POST";
var d2 = { headers: j3, method: T2 };
var g2 = 10;
var f2 = class {
  constructor(t, e2 = false) {
    if (this.url = t, this.disableProviderPing = e2, this.events = new import_events9.EventEmitter(), this.isAvailable = false, this.registering = false, !isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    this.url = t, this.disableProviderPing = e2;
  }
  get connected() {
    return this.isAvailable;
  }
  get connecting() {
    return this.registering;
  }
  on(t, e2) {
    this.events.on(t, e2);
  }
  once(t, e2) {
    this.events.once(t, e2);
  }
  off(t, e2) {
    this.events.off(t, e2);
  }
  removeListener(t, e2) {
    this.events.removeListener(t, e2);
  }
  async open(t = this.url) {
    await this.register(t);
  }
  async close() {
    if (!this.isAvailable) throw new Error("Connection already closed");
    this.onClose();
  }
  async send(t) {
    this.isAvailable || await this.register();
    try {
      const e2 = safeJsonStringify(t), s2 = await (await (0, import_cross_fetch.default)(this.url, v3(p2({}, d2), { body: e2 }))).json();
      this.onPayload({ data: s2 });
    } catch (e2) {
      this.onError(t.id, e2);
    }
  }
  async register(t = this.url) {
    if (!isHttpUrl(t)) throw new Error(`Provided URL is not compatible with HTTP connection: ${t}`);
    if (this.registering) {
      const e2 = this.events.getMaxListeners();
      return (this.events.listenerCount("register_error") >= e2 || this.events.listenerCount("open") >= e2) && this.events.setMaxListeners(e2 + 1), new Promise((s2, i3) => {
        this.events.once("register_error", (n4) => {
          this.resetMaxListeners(), i3(n4);
        }), this.events.once("open", () => {
          if (this.resetMaxListeners(), typeof this.isAvailable > "u") return i3(new Error("HTTP connection is missing or invalid"));
          s2();
        });
      });
    }
    this.url = t, this.registering = true;
    try {
      if (!this.disableProviderPing) {
        const e2 = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
        await (0, import_cross_fetch.default)(t, v3(p2({}, d2), { body: e2 }));
      }
      this.onOpen();
    } catch (e2) {
      const s2 = this.parseError(e2);
      throw this.events.emit("register_error", s2), this.onClose(), s2;
    }
  }
  onOpen() {
    this.isAvailable = true, this.registering = false, this.events.emit("open");
  }
  onClose() {
    this.isAvailable = false, this.registering = false, this.events.emit("close");
  }
  onPayload(t) {
    if (typeof t.data > "u") return;
    const e2 = typeof t.data == "string" ? safeJsonParse(t.data) : t.data;
    this.events.emit("payload", e2);
  }
  onError(t, e2) {
    const s2 = this.parseError(e2), i3 = s2.message || s2.toString(), n4 = formatJsonRpcError(t, i3);
    this.events.emit("payload", n4);
  }
  parseError(t, e2 = this.url) {
    return parseConnectionError(t, e2, "HTTP");
  }
  resetMaxListeners() {
    this.events.getMaxListeners() > g2 && this.events.setMaxListeners(g2);
  }
};

// node_modules/@walletconnect/universal-provider/dist/index.es.js
var import_events10 = __toESM(require_events());
var ya = "error";
var Yg = "wss://relay.walletconnect.org";
var Zg = "wc";
var Xg = "universal_provider";
var Sa = `${Zg}@2:${Xg}:`;
var Oa = "https://rpc.walletconnect.org/v1/";
var ze = "generic";
var Qg = `${Oa}bundler`;
var Tt2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
var _n2 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var qi = { exports: {} };
(function(P3, s2) {
  (function() {
    var i3, p3 = "4.17.21", w4 = 200, I3 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", y6 = "Expected a function", J = "Invalid `variable` option passed into `_.template`", Ht2 = "__lodash_hash_undefined__", Ke = 500, Ie2 = "__lodash_placeholder__", Dt2 = 1, Bt2 = 2, xe3 = 4, Ee2 = 1, mn2 = 2, vt2 = 1, he2 = 2, Gi = 4, Nt2 = 8, ye2 = 16, $t2 = 32, Se = 64, Gt2 = 128, Je = 256, gr3 = 512, Ma = 30, Ba = "...", Ga = 800, za = 16, zi = 1, Ka = 2, Ja = 3, le2 = 1 / 0, ee2 = 9007199254740991, Ya = 17976931348623157e292, wn2 = 0 / 0, Ut2 = 4294967295, Za = Ut2 - 1, Xa = Ut2 >>> 1, Qa = [["ary", Gt2], ["bind", vt2], ["bindKey", he2], ["curry", Nt2], ["curryRight", ye2], ["flip", gr3], ["partial", $t2], ["partialRight", Se], ["rearg", Je]], Oe = "[object Arguments]", Pn3 = "[object Array]", Va = "[object AsyncFunction]", Ye = "[object Boolean]", Ze4 = "[object Date]", ka = "[object DOMException]", Cn2 = "[object Error]", An2 = "[object Function]", Ki = "[object GeneratorFunction]", Et2 = "[object Map]", Xe2 = "[object Number]", ja = "[object Null]", zt2 = "[object Object]", Ji = "[object Promise]", to = "[object Proxy]", Qe2 = "[object RegExp]", yt3 = "[object Set]", Ve = "[object String]", In2 = "[object Symbol]", eo = "[object Undefined]", ke = "[object WeakMap]", no = "[object WeakSet]", je = "[object ArrayBuffer]", Re2 = "[object DataView]", vr2 = "[object Float32Array]", _r2 = "[object Float64Array]", mr2 = "[object Int8Array]", wr2 = "[object Int16Array]", Pr2 = "[object Int32Array]", Cr2 = "[object Uint8Array]", Ar2 = "[object Uint8ClampedArray]", Ir2 = "[object Uint16Array]", xr2 = "[object Uint32Array]", ro = /\b__p \+= '';/g, io = /\b(__p \+=) '' \+/g, so2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Yi = /&(?:amp|lt|gt|quot|#39);/g, Zi = /[&<>"']/g, uo = RegExp(Yi.source), ao = RegExp(Zi.source), oo = /<%-([\s\S]+?)%>/g, co = /<%([\s\S]+?)%>/g, Xi = /<%=([\s\S]+?)%>/g, fo = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, ho = /^\w*$/, lo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Er2 = /[\\^$.*+?()[\]{}|]/g, po = RegExp(Er2.source), yr2 = /^\s+/, go = /\s/, vo = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, _o = /\{\n\/\* \[wrapped with (.+)\] \*/, mo = /,? & /, wo = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Po2 = /[()=,{}\[\]\/\s]/, Co = /\\(\\)?/g, Ao = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Qi = /\w*$/, Io = /^[-+]0x[0-9a-f]+$/i, xo2 = /^0b[01]+$/i, Eo = /^\[object .+?Constructor\]$/, yo = /^0o[0-7]+$/i, So = /^(?:0|[1-9]\d*)$/, Oo2 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, xn2 = /($^)/, Ro = /['\n\r\u2028\u2029\\]/g, En2 = "\\ud800-\\udfff", bo = "\\u0300-\\u036f", To2 = "\\ufe20-\\ufe2f", Lo = "\\u20d0-\\u20ff", Vi2 = bo + To2 + Lo, ki2 = "\\u2700-\\u27bf", ji = "a-z\\xdf-\\xf6\\xf8-\\xff", Ho = "\\xac\\xb1\\xd7\\xf7", Do = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", No = "\\u2000-\\u206f", $o = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ts2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", es2 = "\\ufe0e\\ufe0f", ns2 = Ho + Do + No + $o, Sr3 = "['’]", Uo = "[" + En2 + "]", rs = "[" + ns2 + "]", yn2 = "[" + Vi2 + "]", is2 = "\\d+", qo = "[" + ki2 + "]", ss3 = "[" + ji + "]", us = "[^" + En2 + ns2 + is2 + ki2 + ji + ts2 + "]", Or2 = "\\ud83c[\\udffb-\\udfff]", Fo = "(?:" + yn2 + "|" + Or2 + ")", as = "[^" + En2 + "]", Rr2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", br2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", be3 = "[" + ts2 + "]", os = "\\u200d", cs2 = "(?:" + ss3 + "|" + us + ")", Wo = "(?:" + be3 + "|" + us + ")", fs3 = "(?:" + Sr3 + "(?:d|ll|m|re|s|t|ve))?", hs = "(?:" + Sr3 + "(?:D|LL|M|RE|S|T|VE))?", ls2 = Fo + "?", ps = "[" + es2 + "]?", Mo = "(?:" + os + "(?:" + [as, Rr2, br2].join("|") + ")" + ps + ls2 + ")*", Bo = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Go = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ds = ps + ls2 + Mo, zo = "(?:" + [qo, Rr2, br2].join("|") + ")" + ds, Ko = "(?:" + [as + yn2 + "?", yn2, Rr2, br2, Uo].join("|") + ")", Jo = RegExp(Sr3, "g"), Yo = RegExp(yn2, "g"), Tr2 = RegExp(Or2 + "(?=" + Or2 + ")|" + Ko + ds, "g"), Zo = RegExp([be3 + "?" + ss3 + "+" + fs3 + "(?=" + [rs, be3, "$"].join("|") + ")", Wo + "+" + hs + "(?=" + [rs, be3 + cs2, "$"].join("|") + ")", be3 + "?" + cs2 + "+" + fs3, be3 + "+" + hs, Go, Bo, is2, zo].join("|"), "g"), Xo = RegExp("[" + os + En2 + Vi2 + es2 + "]"), Qo = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Vo = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], ko = -1, G2 = {};
    G2[vr2] = G2[_r2] = G2[mr2] = G2[wr2] = G2[Pr2] = G2[Cr2] = G2[Ar2] = G2[Ir2] = G2[xr2] = true, G2[Oe] = G2[Pn3] = G2[je] = G2[Ye] = G2[Re2] = G2[Ze4] = G2[Cn2] = G2[An2] = G2[Et2] = G2[Xe2] = G2[zt2] = G2[Qe2] = G2[yt3] = G2[Ve] = G2[ke] = false;
    var B2 = {};
    B2[Oe] = B2[Pn3] = B2[je] = B2[Re2] = B2[Ye] = B2[Ze4] = B2[vr2] = B2[_r2] = B2[mr2] = B2[wr2] = B2[Pr2] = B2[Et2] = B2[Xe2] = B2[zt2] = B2[Qe2] = B2[yt3] = B2[Ve] = B2[In2] = B2[Cr2] = B2[Ar2] = B2[Ir2] = B2[xr2] = true, B2[Cn2] = B2[An2] = B2[ke] = false;
    var jo = { À: "A", Á: "A", Â: "A", Ã: "A", Ä: "A", Å: "A", à: "a", á: "a", â: "a", ã: "a", ä: "a", å: "a", Ç: "C", ç: "c", Ð: "D", ð: "d", È: "E", É: "E", Ê: "E", Ë: "E", è: "e", é: "e", ê: "e", ë: "e", Ì: "I", Í: "I", Î: "I", Ï: "I", ì: "i", í: "i", î: "i", ï: "i", Ñ: "N", ñ: "n", Ò: "O", Ó: "O", Ô: "O", Õ: "O", Ö: "O", Ø: "O", ò: "o", ó: "o", ô: "o", õ: "o", ö: "o", ø: "o", Ù: "U", Ú: "U", Û: "U", Ü: "U", ù: "u", ú: "u", û: "u", ü: "u", Ý: "Y", ý: "y", ÿ: "y", Æ: "Ae", æ: "ae", Þ: "Th", þ: "th", ß: "ss", Ā: "A", Ă: "A", Ą: "A", ā: "a", ă: "a", ą: "a", Ć: "C", Ĉ: "C", Ċ: "C", Č: "C", ć: "c", ĉ: "c", ċ: "c", č: "c", Ď: "D", Đ: "D", ď: "d", đ: "d", Ē: "E", Ĕ: "E", Ė: "E", Ę: "E", Ě: "E", ē: "e", ĕ: "e", ė: "e", ę: "e", ě: "e", Ĝ: "G", Ğ: "G", Ġ: "G", Ģ: "G", ĝ: "g", ğ: "g", ġ: "g", ģ: "g", Ĥ: "H", Ħ: "H", ĥ: "h", ħ: "h", Ĩ: "I", Ī: "I", Ĭ: "I", Į: "I", İ: "I", ĩ: "i", ī: "i", ĭ: "i", į: "i", ı: "i", Ĵ: "J", ĵ: "j", Ķ: "K", ķ: "k", ĸ: "k", Ĺ: "L", Ļ: "L", Ľ: "L", Ŀ: "L", Ł: "L", ĺ: "l", ļ: "l", ľ: "l", ŀ: "l", ł: "l", Ń: "N", Ņ: "N", Ň: "N", Ŋ: "N", ń: "n", ņ: "n", ň: "n", ŋ: "n", Ō: "O", Ŏ: "O", Ő: "O", ō: "o", ŏ: "o", ő: "o", Ŕ: "R", Ŗ: "R", Ř: "R", ŕ: "r", ŗ: "r", ř: "r", Ś: "S", Ŝ: "S", Ş: "S", Š: "S", ś: "s", ŝ: "s", ş: "s", š: "s", Ţ: "T", Ť: "T", Ŧ: "T", ţ: "t", ť: "t", ŧ: "t", Ũ: "U", Ū: "U", Ŭ: "U", Ů: "U", Ű: "U", Ų: "U", ũ: "u", ū: "u", ŭ: "u", ů: "u", ű: "u", ų: "u", Ŵ: "W", ŵ: "w", Ŷ: "Y", ŷ: "y", Ÿ: "Y", Ź: "Z", Ż: "Z", Ž: "Z", ź: "z", ż: "z", ž: "z", Ĳ: "IJ", ĳ: "ij", Œ: "Oe", œ: "oe", ŉ: "'n", ſ: "s" }, tc = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ec = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, nc = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, rc = parseFloat, ic = parseInt, gs2 = typeof _n2 == "object" && _n2 && _n2.Object === Object && _n2, sc = typeof self == "object" && self && self.Object === Object && self, j4 = gs2 || sc || Function("return this")(), Lr2 = s2 && !s2.nodeType && s2, pe = Lr2 && true && P3 && !P3.nodeType && P3, vs2 = pe && pe.exports === Lr2, Hr2 = vs2 && gs2.process, _t2 = function() {
      try {
        var h4 = pe && pe.require && pe.require("util").types;
        return h4 || Hr2 && Hr2.binding && Hr2.binding("util");
      } catch {
      }
    }(), _s3 = _t2 && _t2.isArrayBuffer, ms3 = _t2 && _t2.isDate, ws3 = _t2 && _t2.isMap, Ps2 = _t2 && _t2.isRegExp, Cs2 = _t2 && _t2.isSet, As3 = _t2 && _t2.isTypedArray;
    function ft2(h4, g3, d3) {
      switch (d3.length) {
        case 0:
          return h4.call(g3);
        case 1:
          return h4.call(g3, d3[0]);
        case 2:
          return h4.call(g3, d3[0], d3[1]);
        case 3:
          return h4.call(g3, d3[0], d3[1], d3[2]);
      }
      return h4.apply(g3, d3);
    }
    function uc(h4, g3, d3, A3) {
      for (var R2 = -1, U3 = h4 == null ? 0 : h4.length; ++R2 < U3; ) {
        var Q2 = h4[R2];
        g3(A3, Q2, d3(Q2), h4);
      }
      return A3;
    }
    function mt2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3 && g3(h4[d3], d3, h4) !== false; ) ;
      return h4;
    }
    function ac(h4, g3) {
      for (var d3 = h4 == null ? 0 : h4.length; d3-- && g3(h4[d3], d3, h4) !== false; ) ;
      return h4;
    }
    function Is4(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3; ) if (!g3(h4[d3], d3, h4)) return false;
      return true;
    }
    function ne2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length, R2 = 0, U3 = []; ++d3 < A3; ) {
        var Q2 = h4[d3];
        g3(Q2, d3, h4) && (U3[R2++] = Q2);
      }
      return U3;
    }
    function Sn2(h4, g3) {
      var d3 = h4 == null ? 0 : h4.length;
      return !!d3 && Te2(h4, g3, 0) > -1;
    }
    function Dr2(h4, g3, d3) {
      for (var A3 = -1, R2 = h4 == null ? 0 : h4.length; ++A3 < R2; ) if (d3(g3, h4[A3])) return true;
      return false;
    }
    function z4(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length, R2 = Array(A3); ++d3 < A3; ) R2[d3] = g3(h4[d3], d3, h4);
      return R2;
    }
    function re(h4, g3) {
      for (var d3 = -1, A3 = g3.length, R2 = h4.length; ++d3 < A3; ) h4[R2 + d3] = g3[d3];
      return h4;
    }
    function Nr3(h4, g3, d3, A3) {
      var R2 = -1, U3 = h4 == null ? 0 : h4.length;
      for (A3 && U3 && (d3 = h4[++R2]); ++R2 < U3; ) d3 = g3(d3, h4[R2], R2, h4);
      return d3;
    }
    function oc(h4, g3, d3, A3) {
      var R2 = h4 == null ? 0 : h4.length;
      for (A3 && R2 && (d3 = h4[--R2]); R2--; ) d3 = g3(d3, h4[R2], R2, h4);
      return d3;
    }
    function $r2(h4, g3) {
      for (var d3 = -1, A3 = h4 == null ? 0 : h4.length; ++d3 < A3; ) if (g3(h4[d3], d3, h4)) return true;
      return false;
    }
    var cc = Ur2("length");
    function fc(h4) {
      return h4.split("");
    }
    function hc(h4) {
      return h4.match(wo) || [];
    }
    function xs3(h4, g3, d3) {
      var A3;
      return d3(h4, function(R2, U3, Q2) {
        if (g3(R2, U3, Q2)) return A3 = U3, false;
      }), A3;
    }
    function On2(h4, g3, d3, A3) {
      for (var R2 = h4.length, U3 = d3 + (A3 ? 1 : -1); A3 ? U3-- : ++U3 < R2; ) if (g3(h4[U3], U3, h4)) return U3;
      return -1;
    }
    function Te2(h4, g3, d3) {
      return g3 === g3 ? Ic(h4, g3, d3) : On2(h4, Es3, d3);
    }
    function lc(h4, g3, d3, A3) {
      for (var R2 = d3 - 1, U3 = h4.length; ++R2 < U3; ) if (A3(h4[R2], g3)) return R2;
      return -1;
    }
    function Es3(h4) {
      return h4 !== h4;
    }
    function ys3(h4, g3) {
      var d3 = h4 == null ? 0 : h4.length;
      return d3 ? Fr2(h4, g3) / d3 : wn2;
    }
    function Ur2(h4) {
      return function(g3) {
        return g3 == null ? i3 : g3[h4];
      };
    }
    function qr2(h4) {
      return function(g3) {
        return h4 == null ? i3 : h4[g3];
      };
    }
    function Ss4(h4, g3, d3, A3, R2) {
      return R2(h4, function(U3, Q2, M3) {
        d3 = A3 ? (A3 = false, U3) : g3(d3, U3, Q2, M3);
      }), d3;
    }
    function pc(h4, g3) {
      var d3 = h4.length;
      for (h4.sort(g3); d3--; ) h4[d3] = h4[d3].value;
      return h4;
    }
    function Fr2(h4, g3) {
      for (var d3, A3 = -1, R2 = h4.length; ++A3 < R2; ) {
        var U3 = g3(h4[A3]);
        U3 !== i3 && (d3 = d3 === i3 ? U3 : d3 + U3);
      }
      return d3;
    }
    function Wr3(h4, g3) {
      for (var d3 = -1, A3 = Array(h4); ++d3 < h4; ) A3[d3] = g3(d3);
      return A3;
    }
    function dc(h4, g3) {
      return z4(g3, function(d3) {
        return [d3, h4[d3]];
      });
    }
    function Os2(h4) {
      return h4 && h4.slice(0, Ls2(h4) + 1).replace(yr2, "");
    }
    function ht3(h4) {
      return function(g3) {
        return h4(g3);
      };
    }
    function Mr2(h4, g3) {
      return z4(g3, function(d3) {
        return h4[d3];
      });
    }
    function tn3(h4, g3) {
      return h4.has(g3);
    }
    function Rs3(h4, g3) {
      for (var d3 = -1, A3 = h4.length; ++d3 < A3 && Te2(g3, h4[d3], 0) > -1; ) ;
      return d3;
    }
    function bs3(h4, g3) {
      for (var d3 = h4.length; d3-- && Te2(g3, h4[d3], 0) > -1; ) ;
      return d3;
    }
    function gc(h4, g3) {
      for (var d3 = h4.length, A3 = 0; d3--; ) h4[d3] === g3 && ++A3;
      return A3;
    }
    var vc = qr2(jo), _c = qr2(tc);
    function mc(h4) {
      return "\\" + nc[h4];
    }
    function wc(h4, g3) {
      return h4 == null ? i3 : h4[g3];
    }
    function Le2(h4) {
      return Xo.test(h4);
    }
    function Pc(h4) {
      return Qo.test(h4);
    }
    function Cc(h4) {
      for (var g3, d3 = []; !(g3 = h4.next()).done; ) d3.push(g3.value);
      return d3;
    }
    function Br2(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3, R2) {
        d3[++g3] = [R2, A3];
      }), d3;
    }
    function Ts2(h4, g3) {
      return function(d3) {
        return h4(g3(d3));
      };
    }
    function ie(h4, g3) {
      for (var d3 = -1, A3 = h4.length, R2 = 0, U3 = []; ++d3 < A3; ) {
        var Q2 = h4[d3];
        (Q2 === g3 || Q2 === Ie2) && (h4[d3] = Ie2, U3[R2++] = d3);
      }
      return U3;
    }
    function Rn2(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3) {
        d3[++g3] = A3;
      }), d3;
    }
    function Ac(h4) {
      var g3 = -1, d3 = Array(h4.size);
      return h4.forEach(function(A3) {
        d3[++g3] = [A3, A3];
      }), d3;
    }
    function Ic(h4, g3, d3) {
      for (var A3 = d3 - 1, R2 = h4.length; ++A3 < R2; ) if (h4[A3] === g3) return A3;
      return -1;
    }
    function xc(h4, g3, d3) {
      for (var A3 = d3 + 1; A3--; ) if (h4[A3] === g3) return A3;
      return A3;
    }
    function He(h4) {
      return Le2(h4) ? yc(h4) : cc(h4);
    }
    function St2(h4) {
      return Le2(h4) ? Sc(h4) : fc(h4);
    }
    function Ls2(h4) {
      for (var g3 = h4.length; g3-- && go.test(h4.charAt(g3)); ) ;
      return g3;
    }
    var Ec = qr2(ec);
    function yc(h4) {
      for (var g3 = Tr2.lastIndex = 0; Tr2.test(h4); ) ++g3;
      return g3;
    }
    function Sc(h4) {
      return h4.match(Tr2) || [];
    }
    function Oc(h4) {
      return h4.match(Zo) || [];
    }
    var Rc = function h4(g3) {
      g3 = g3 == null ? j4 : De.defaults(j4.Object(), g3, De.pick(j4, Vo));
      var d3 = g3.Array, A3 = g3.Date, R2 = g3.Error, U3 = g3.Function, Q2 = g3.Math, M3 = g3.Object, Gr2 = g3.RegExp, bc = g3.String, wt2 = g3.TypeError, bn2 = d3.prototype, Tc = U3.prototype, Ne = M3.prototype, Tn2 = g3["__core-js_shared__"], Ln = Tc.toString, W = Ne.hasOwnProperty, Lc = 0, Hs2 = function() {
        var t = /[^.]+$/.exec(Tn2 && Tn2.keys && Tn2.keys.IE_PROTO || "");
        return t ? "Symbol(src)_1." + t : "";
      }(), Hn = Ne.toString, Hc = Ln.call(M3), Dc = j4._, Nc = Gr2("^" + Ln.call(W).replace(Er2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Dn2 = vs2 ? g3.Buffer : i3, se2 = g3.Symbol, Nn = g3.Uint8Array, Ds = Dn2 ? Dn2.allocUnsafe : i3, $n = Ts2(M3.getPrototypeOf, M3), Ns3 = M3.create, $s2 = Ne.propertyIsEnumerable, Un = bn2.splice, Us2 = se2 ? se2.isConcatSpreadable : i3, en2 = se2 ? se2.iterator : i3, de = se2 ? se2.toStringTag : i3, qn = function() {
        try {
          var t = we3(M3, "defineProperty");
          return t({}, "", {}), t;
        } catch {
        }
      }(), $c = g3.clearTimeout !== j4.clearTimeout && g3.clearTimeout, Uc = A3 && A3.now !== j4.Date.now && A3.now, qc = g3.setTimeout !== j4.setTimeout && g3.setTimeout, Fn = Q2.ceil, Wn = Q2.floor, zr2 = M3.getOwnPropertySymbols, Fc = Dn2 ? Dn2.isBuffer : i3, qs3 = g3.isFinite, Wc = bn2.join, Mc = Ts2(M3.keys, M3), V = Q2.max, et3 = Q2.min, Bc = A3.now, Gc = g3.parseInt, Fs2 = Q2.random, zc = bn2.reverse, Kr2 = we3(g3, "DataView"), nn2 = we3(g3, "Map"), Jr2 = we3(g3, "Promise"), $e = we3(g3, "Set"), rn2 = we3(g3, "WeakMap"), sn2 = we3(M3, "create"), Mn = rn2 && new rn2(), Ue = {}, Kc = Pe3(Kr2), Jc = Pe3(nn2), Yc = Pe3(Jr2), Zc = Pe3($e), Xc = Pe3(rn2), Bn = se2 ? se2.prototype : i3, un2 = Bn ? Bn.valueOf : i3, Ws2 = Bn ? Bn.toString : i3;
      function a4(t) {
        if (Y2(t) && !b3(t) && !(t instanceof N2)) {
          if (t instanceof Pt2) return t;
          if (W.call(t, "__wrapped__")) return Mu2(t);
        }
        return new Pt2(t);
      }
      var qe = /* @__PURE__ */ function() {
        function t() {
        }
        return function(e2) {
          if (!K3(e2)) return {};
          if (Ns3) return Ns3(e2);
          t.prototype = e2;
          var n4 = new t();
          return t.prototype = i3, n4;
        };
      }();
      function Gn() {
      }
      function Pt2(t, e2) {
        this.__wrapped__ = t, this.__actions__ = [], this.__chain__ = !!e2, this.__index__ = 0, this.__values__ = i3;
      }
      a4.templateSettings = { escape: oo, evaluate: co, interpolate: Xi, variable: "", imports: { _: a4 } }, a4.prototype = Gn.prototype, a4.prototype.constructor = a4, Pt2.prototype = qe(Gn.prototype), Pt2.prototype.constructor = Pt2;
      function N2(t) {
        this.__wrapped__ = t, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Ut2, this.__views__ = [];
      }
      function Qc() {
        var t = new N2(this.__wrapped__);
        return t.__actions__ = ut3(this.__actions__), t.__dir__ = this.__dir__, t.__filtered__ = this.__filtered__, t.__iteratees__ = ut3(this.__iteratees__), t.__takeCount__ = this.__takeCount__, t.__views__ = ut3(this.__views__), t;
      }
      function Vc() {
        if (this.__filtered__) {
          var t = new N2(this);
          t.__dir__ = -1, t.__filtered__ = true;
        } else t = this.clone(), t.__dir__ *= -1;
        return t;
      }
      function kc() {
        var t = this.__wrapped__.value(), e2 = this.__dir__, n4 = b3(t), r3 = e2 < 0, u3 = n4 ? t.length : 0, o5 = hh2(0, u3, this.__views__), c5 = o5.start, f3 = o5.end, l4 = f3 - c5, v4 = r3 ? f3 : c5 - 1, _3 = this.__iteratees__, m2 = _3.length, C2 = 0, x4 = et3(l4, this.__takeCount__);
        if (!n4 || !r3 && u3 == l4 && x4 == l4) return fu(t, this.__actions__);
        var S3 = [];
        t: for (; l4-- && C2 < x4; ) {
          v4 += e2;
          for (var L2 = -1, O4 = t[v4]; ++L2 < m2; ) {
            var D3 = _3[L2], $2 = D3.iteratee, dt3 = D3.type, st3 = $2(O4);
            if (dt3 == Ka) O4 = st3;
            else if (!st3) {
              if (dt3 == zi) continue t;
              break t;
            }
          }
          S3[C2++] = O4;
        }
        return S3;
      }
      N2.prototype = qe(Gn.prototype), N2.prototype.constructor = N2;
      function ge(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.clear(); ++e2 < n4; ) {
          var r3 = t[e2];
          this.set(r3[0], r3[1]);
        }
      }
      function jc() {
        this.__data__ = sn2 ? sn2(null) : {}, this.size = 0;
      }
      function tf(t) {
        var e2 = this.has(t) && delete this.__data__[t];
        return this.size -= e2 ? 1 : 0, e2;
      }
      function ef(t) {
        var e2 = this.__data__;
        if (sn2) {
          var n4 = e2[t];
          return n4 === Ht2 ? i3 : n4;
        }
        return W.call(e2, t) ? e2[t] : i3;
      }
      function nf(t) {
        var e2 = this.__data__;
        return sn2 ? e2[t] !== i3 : W.call(e2, t);
      }
      function rf(t, e2) {
        var n4 = this.__data__;
        return this.size += this.has(t) ? 0 : 1, n4[t] = sn2 && e2 === i3 ? Ht2 : e2, this;
      }
      ge.prototype.clear = jc, ge.prototype.delete = tf, ge.prototype.get = ef, ge.prototype.has = nf, ge.prototype.set = rf;
      function Kt2(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.clear(); ++e2 < n4; ) {
          var r3 = t[e2];
          this.set(r3[0], r3[1]);
        }
      }
      function sf() {
        this.__data__ = [], this.size = 0;
      }
      function uf(t) {
        var e2 = this.__data__, n4 = zn(e2, t);
        if (n4 < 0) return false;
        var r3 = e2.length - 1;
        return n4 == r3 ? e2.pop() : Un.call(e2, n4, 1), --this.size, true;
      }
      function af(t) {
        var e2 = this.__data__, n4 = zn(e2, t);
        return n4 < 0 ? i3 : e2[n4][1];
      }
      function of(t) {
        return zn(this.__data__, t) > -1;
      }
      function cf(t, e2) {
        var n4 = this.__data__, r3 = zn(n4, t);
        return r3 < 0 ? (++this.size, n4.push([t, e2])) : n4[r3][1] = e2, this;
      }
      Kt2.prototype.clear = sf, Kt2.prototype.delete = uf, Kt2.prototype.get = af, Kt2.prototype.has = of, Kt2.prototype.set = cf;
      function Jt2(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.clear(); ++e2 < n4; ) {
          var r3 = t[e2];
          this.set(r3[0], r3[1]);
        }
      }
      function ff() {
        this.size = 0, this.__data__ = { hash: new ge(), map: new (nn2 || Kt2)(), string: new ge() };
      }
      function hf(t) {
        var e2 = nr2(this, t).delete(t);
        return this.size -= e2 ? 1 : 0, e2;
      }
      function lf(t) {
        return nr2(this, t).get(t);
      }
      function pf(t) {
        return nr2(this, t).has(t);
      }
      function df(t, e2) {
        var n4 = nr2(this, t), r3 = n4.size;
        return n4.set(t, e2), this.size += n4.size == r3 ? 0 : 1, this;
      }
      Jt2.prototype.clear = ff, Jt2.prototype.delete = hf, Jt2.prototype.get = lf, Jt2.prototype.has = pf, Jt2.prototype.set = df;
      function ve2(t) {
        var e2 = -1, n4 = t == null ? 0 : t.length;
        for (this.__data__ = new Jt2(); ++e2 < n4; ) this.add(t[e2]);
      }
      function gf(t) {
        return this.__data__.set(t, Ht2), this;
      }
      function vf(t) {
        return this.__data__.has(t);
      }
      ve2.prototype.add = ve2.prototype.push = gf, ve2.prototype.has = vf;
      function Ot2(t) {
        var e2 = this.__data__ = new Kt2(t);
        this.size = e2.size;
      }
      function _f() {
        this.__data__ = new Kt2(), this.size = 0;
      }
      function mf(t) {
        var e2 = this.__data__, n4 = e2.delete(t);
        return this.size = e2.size, n4;
      }
      function wf(t) {
        return this.__data__.get(t);
      }
      function Pf(t) {
        return this.__data__.has(t);
      }
      function Cf(t, e2) {
        var n4 = this.__data__;
        if (n4 instanceof Kt2) {
          var r3 = n4.__data__;
          if (!nn2 || r3.length < w4 - 1) return r3.push([t, e2]), this.size = ++n4.size, this;
          n4 = this.__data__ = new Jt2(r3);
        }
        return n4.set(t, e2), this.size = n4.size, this;
      }
      Ot2.prototype.clear = _f, Ot2.prototype.delete = mf, Ot2.prototype.get = wf, Ot2.prototype.has = Pf, Ot2.prototype.set = Cf;
      function Ms3(t, e2) {
        var n4 = b3(t), r3 = !n4 && Ce3(t), u3 = !n4 && !r3 && fe2(t), o5 = !n4 && !r3 && !u3 && Be(t), c5 = n4 || r3 || u3 || o5, f3 = c5 ? Wr3(t.length, bc) : [], l4 = f3.length;
        for (var v4 in t) (e2 || W.call(t, v4)) && !(c5 && (v4 == "length" || u3 && (v4 == "offset" || v4 == "parent") || o5 && (v4 == "buffer" || v4 == "byteLength" || v4 == "byteOffset") || Qt2(v4, l4))) && f3.push(v4);
        return f3;
      }
      function Bs2(t) {
        var e2 = t.length;
        return e2 ? t[ri2(0, e2 - 1)] : i3;
      }
      function Af(t, e2) {
        return rr3(ut3(t), _e3(e2, 0, t.length));
      }
      function If(t) {
        return rr3(ut3(t));
      }
      function Yr2(t, e2, n4) {
        (n4 !== i3 && !Rt2(t[e2], n4) || n4 === i3 && !(e2 in t)) && Yt3(t, e2, n4);
      }
      function an2(t, e2, n4) {
        var r3 = t[e2];
        (!(W.call(t, e2) && Rt2(r3, n4)) || n4 === i3 && !(e2 in t)) && Yt3(t, e2, n4);
      }
      function zn(t, e2) {
        for (var n4 = t.length; n4--; ) if (Rt2(t[n4][0], e2)) return n4;
        return -1;
      }
      function xf(t, e2, n4, r3) {
        return ue2(t, function(u3, o5, c5) {
          e2(r3, u3, n4(u3), c5);
        }), r3;
      }
      function Gs2(t, e2) {
        return t && Ft2(e2, k3(e2), t);
      }
      function Ef(t, e2) {
        return t && Ft2(e2, ot3(e2), t);
      }
      function Yt3(t, e2, n4) {
        e2 == "__proto__" && qn ? qn(t, e2, { configurable: true, enumerable: true, value: n4, writable: true }) : t[e2] = n4;
      }
      function Zr2(t, e2) {
        for (var n4 = -1, r3 = e2.length, u3 = d3(r3), o5 = t == null; ++n4 < r3; ) u3[n4] = o5 ? i3 : Oi(t, e2[n4]);
        return u3;
      }
      function _e3(t, e2, n4) {
        return t === t && (n4 !== i3 && (t = t <= n4 ? t : n4), e2 !== i3 && (t = t >= e2 ? t : e2)), t;
      }
      function Ct2(t, e2, n4, r3, u3, o5) {
        var c5, f3 = e2 & Dt2, l4 = e2 & Bt2, v4 = e2 & xe3;
        if (n4 && (c5 = u3 ? n4(t, r3, u3, o5) : n4(t)), c5 !== i3) return c5;
        if (!K3(t)) return t;
        var _3 = b3(t);
        if (_3) {
          if (c5 = ph2(t), !f3) return ut3(t, c5);
        } else {
          var m2 = nt3(t), C2 = m2 == An2 || m2 == Ki;
          if (fe2(t)) return pu(t, f3);
          if (m2 == zt2 || m2 == Oe || C2 && !u3) {
            if (c5 = l4 || C2 ? {} : Lu2(t), !f3) return l4 ? nh(t, Ef(c5, t)) : eh(t, Gs2(c5, t));
          } else {
            if (!B2[m2]) return u3 ? t : {};
            c5 = dh2(t, m2, f3);
          }
        }
        o5 || (o5 = new Ot2());
        var x4 = o5.get(t);
        if (x4) return x4;
        o5.set(t, c5), aa(t) ? t.forEach(function(O4) {
          c5.add(Ct2(O4, e2, n4, O4, t, o5));
        }) : sa(t) && t.forEach(function(O4, D3) {
          c5.set(D3, Ct2(O4, e2, n4, D3, t, o5));
        });
        var S3 = v4 ? l4 ? di2 : pi2 : l4 ? ot3 : k3, L2 = _3 ? i3 : S3(t);
        return mt2(L2 || t, function(O4, D3) {
          L2 && (D3 = O4, O4 = t[D3]), an2(c5, D3, Ct2(O4, e2, n4, D3, t, o5));
        }), c5;
      }
      function yf(t) {
        var e2 = k3(t);
        return function(n4) {
          return zs2(n4, t, e2);
        };
      }
      function zs2(t, e2, n4) {
        var r3 = n4.length;
        if (t == null) return !r3;
        for (t = M3(t); r3--; ) {
          var u3 = n4[r3], o5 = e2[u3], c5 = t[u3];
          if (c5 === i3 && !(u3 in t) || !o5(c5)) return false;
        }
        return true;
      }
      function Ks2(t, e2, n4) {
        if (typeof t != "function") throw new wt2(y6);
        return dn2(function() {
          t.apply(i3, n4);
        }, e2);
      }
      function on3(t, e2, n4, r3) {
        var u3 = -1, o5 = Sn2, c5 = true, f3 = t.length, l4 = [], v4 = e2.length;
        if (!f3) return l4;
        n4 && (e2 = z4(e2, ht3(n4))), r3 ? (o5 = Dr2, c5 = false) : e2.length >= w4 && (o5 = tn3, c5 = false, e2 = new ve2(e2));
        t: for (; ++u3 < f3; ) {
          var _3 = t[u3], m2 = n4 == null ? _3 : n4(_3);
          if (_3 = r3 || _3 !== 0 ? _3 : 0, c5 && m2 === m2) {
            for (var C2 = v4; C2--; ) if (e2[C2] === m2) continue t;
            l4.push(_3);
          } else o5(e2, m2, r3) || l4.push(_3);
        }
        return l4;
      }
      var ue2 = mu2(qt2), Js2 = mu2(Qr2, true);
      function Sf(t, e2) {
        var n4 = true;
        return ue2(t, function(r3, u3, o5) {
          return n4 = !!e2(r3, u3, o5), n4;
        }), n4;
      }
      function Kn(t, e2, n4) {
        for (var r3 = -1, u3 = t.length; ++r3 < u3; ) {
          var o5 = t[r3], c5 = e2(o5);
          if (c5 != null && (f3 === i3 ? c5 === c5 && !pt3(c5) : n4(c5, f3))) var f3 = c5, l4 = o5;
        }
        return l4;
      }
      function Of(t, e2, n4, r3) {
        var u3 = t.length;
        for (n4 = T3(n4), n4 < 0 && (n4 = -n4 > u3 ? 0 : u3 + n4), r3 = r3 === i3 || r3 > u3 ? u3 : T3(r3), r3 < 0 && (r3 += u3), r3 = n4 > r3 ? 0 : ca(r3); n4 < r3; ) t[n4++] = e2;
        return t;
      }
      function Ys2(t, e2) {
        var n4 = [];
        return ue2(t, function(r3, u3, o5) {
          e2(r3, u3, o5) && n4.push(r3);
        }), n4;
      }
      function tt3(t, e2, n4, r3, u3) {
        var o5 = -1, c5 = t.length;
        for (n4 || (n4 = vh2), u3 || (u3 = []); ++o5 < c5; ) {
          var f3 = t[o5];
          e2 > 0 && n4(f3) ? e2 > 1 ? tt3(f3, e2 - 1, n4, r3, u3) : re(u3, f3) : r3 || (u3[u3.length] = f3);
        }
        return u3;
      }
      var Xr3 = wu(), Zs2 = wu(true);
      function qt2(t, e2) {
        return t && Xr3(t, e2, k3);
      }
      function Qr2(t, e2) {
        return t && Zs2(t, e2, k3);
      }
      function Jn(t, e2) {
        return ne2(e2, function(n4) {
          return Vt2(t[n4]);
        });
      }
      function me3(t, e2) {
        e2 = oe3(e2, t);
        for (var n4 = 0, r3 = e2.length; t != null && n4 < r3; ) t = t[Wt2(e2[n4++])];
        return n4 && n4 == r3 ? t : i3;
      }
      function Xs2(t, e2, n4) {
        var r3 = e2(t);
        return b3(t) ? r3 : re(r3, n4(t));
      }
      function rt3(t) {
        return t == null ? t === i3 ? eo : ja : de && de in M3(t) ? fh(t) : Ih(t);
      }
      function Vr3(t, e2) {
        return t > e2;
      }
      function Rf(t, e2) {
        return t != null && W.call(t, e2);
      }
      function bf(t, e2) {
        return t != null && e2 in M3(t);
      }
      function Tf(t, e2, n4) {
        return t >= et3(e2, n4) && t < V(e2, n4);
      }
      function kr2(t, e2, n4) {
        for (var r3 = n4 ? Dr2 : Sn2, u3 = t[0].length, o5 = t.length, c5 = o5, f3 = d3(o5), l4 = 1 / 0, v4 = []; c5--; ) {
          var _3 = t[c5];
          c5 && e2 && (_3 = z4(_3, ht3(e2))), l4 = et3(_3.length, l4), f3[c5] = !n4 && (e2 || u3 >= 120 && _3.length >= 120) ? new ve2(c5 && _3) : i3;
        }
        _3 = t[0];
        var m2 = -1, C2 = f3[0];
        t: for (; ++m2 < u3 && v4.length < l4; ) {
          var x4 = _3[m2], S3 = e2 ? e2(x4) : x4;
          if (x4 = n4 || x4 !== 0 ? x4 : 0, !(C2 ? tn3(C2, S3) : r3(v4, S3, n4))) {
            for (c5 = o5; --c5; ) {
              var L2 = f3[c5];
              if (!(L2 ? tn3(L2, S3) : r3(t[c5], S3, n4))) continue t;
            }
            C2 && C2.push(S3), v4.push(x4);
          }
        }
        return v4;
      }
      function Lf(t, e2, n4, r3) {
        return qt2(t, function(u3, o5, c5) {
          e2(r3, n4(u3), o5, c5);
        }), r3;
      }
      function cn2(t, e2, n4) {
        e2 = oe3(e2, t), t = $u2(t, e2);
        var r3 = t == null ? t : t[Wt2(It2(e2))];
        return r3 == null ? i3 : ft2(r3, t, n4);
      }
      function Qs2(t) {
        return Y2(t) && rt3(t) == Oe;
      }
      function Hf(t) {
        return Y2(t) && rt3(t) == je;
      }
      function Df(t) {
        return Y2(t) && rt3(t) == Ze4;
      }
      function fn2(t, e2, n4, r3, u3) {
        return t === e2 ? true : t == null || e2 == null || !Y2(t) && !Y2(e2) ? t !== t && e2 !== e2 : Nf(t, e2, n4, r3, fn2, u3);
      }
      function Nf(t, e2, n4, r3, u3, o5) {
        var c5 = b3(t), f3 = b3(e2), l4 = c5 ? Pn3 : nt3(t), v4 = f3 ? Pn3 : nt3(e2);
        l4 = l4 == Oe ? zt2 : l4, v4 = v4 == Oe ? zt2 : v4;
        var _3 = l4 == zt2, m2 = v4 == zt2, C2 = l4 == v4;
        if (C2 && fe2(t)) {
          if (!fe2(e2)) return false;
          c5 = true, _3 = false;
        }
        if (C2 && !_3) return o5 || (o5 = new Ot2()), c5 || Be(t) ? Ru2(t, e2, n4, r3, u3, o5) : oh(t, e2, l4, n4, r3, u3, o5);
        if (!(n4 & Ee2)) {
          var x4 = _3 && W.call(t, "__wrapped__"), S3 = m2 && W.call(e2, "__wrapped__");
          if (x4 || S3) {
            var L2 = x4 ? t.value() : t, O4 = S3 ? e2.value() : e2;
            return o5 || (o5 = new Ot2()), u3(L2, O4, n4, r3, o5);
          }
        }
        return C2 ? (o5 || (o5 = new Ot2()), ch2(t, e2, n4, r3, u3, o5)) : false;
      }
      function $f(t) {
        return Y2(t) && nt3(t) == Et2;
      }
      function jr2(t, e2, n4, r3) {
        var u3 = n4.length, o5 = u3, c5 = !r3;
        if (t == null) return !o5;
        for (t = M3(t); u3--; ) {
          var f3 = n4[u3];
          if (c5 && f3[2] ? f3[1] !== t[f3[0]] : !(f3[0] in t)) return false;
        }
        for (; ++u3 < o5; ) {
          f3 = n4[u3];
          var l4 = f3[0], v4 = t[l4], _3 = f3[1];
          if (c5 && f3[2]) {
            if (v4 === i3 && !(l4 in t)) return false;
          } else {
            var m2 = new Ot2();
            if (r3) var C2 = r3(v4, _3, l4, t, e2, m2);
            if (!(C2 === i3 ? fn2(_3, v4, Ee2 | mn2, r3, m2) : C2)) return false;
          }
        }
        return true;
      }
      function Vs2(t) {
        if (!K3(t) || mh2(t)) return false;
        var e2 = Vt2(t) ? Nc : Eo;
        return e2.test(Pe3(t));
      }
      function Uf(t) {
        return Y2(t) && rt3(t) == Qe2;
      }
      function qf(t) {
        return Y2(t) && nt3(t) == yt3;
      }
      function Ff(t) {
        return Y2(t) && cr2(t.length) && !!G2[rt3(t)];
      }
      function ks2(t) {
        return typeof t == "function" ? t : t == null ? ct3 : typeof t == "object" ? b3(t) ? eu(t[0], t[1]) : tu(t) : Pa(t);
      }
      function ti2(t) {
        if (!pn2(t)) return Mc(t);
        var e2 = [];
        for (var n4 in M3(t)) W.call(t, n4) && n4 != "constructor" && e2.push(n4);
        return e2;
      }
      function Wf2(t) {
        if (!K3(t)) return Ah2(t);
        var e2 = pn2(t), n4 = [];
        for (var r3 in t) r3 == "constructor" && (e2 || !W.call(t, r3)) || n4.push(r3);
        return n4;
      }
      function ei2(t, e2) {
        return t < e2;
      }
      function js2(t, e2) {
        var n4 = -1, r3 = at3(t) ? d3(t.length) : [];
        return ue2(t, function(u3, o5, c5) {
          r3[++n4] = e2(u3, o5, c5);
        }), r3;
      }
      function tu(t) {
        var e2 = vi(t);
        return e2.length == 1 && e2[0][2] ? Du2(e2[0][0], e2[0][1]) : function(n4) {
          return n4 === t || jr2(n4, t, e2);
        };
      }
      function eu(t, e2) {
        return mi2(t) && Hu(e2) ? Du2(Wt2(t), e2) : function(n4) {
          var r3 = Oi(n4, t);
          return r3 === i3 && r3 === e2 ? Ri(n4, t) : fn2(e2, r3, Ee2 | mn2);
        };
      }
      function Yn(t, e2, n4, r3, u3) {
        t !== e2 && Xr3(e2, function(o5, c5) {
          if (u3 || (u3 = new Ot2()), K3(o5)) Mf(t, e2, c5, n4, Yn, r3, u3);
          else {
            var f3 = r3 ? r3(Pi(t, c5), o5, c5 + "", t, e2, u3) : i3;
            f3 === i3 && (f3 = o5), Yr2(t, c5, f3);
          }
        }, ot3);
      }
      function Mf(t, e2, n4, r3, u3, o5, c5) {
        var f3 = Pi(t, n4), l4 = Pi(e2, n4), v4 = c5.get(l4);
        if (v4) {
          Yr2(t, n4, v4);
          return;
        }
        var _3 = o5 ? o5(f3, l4, n4 + "", t, e2, c5) : i3, m2 = _3 === i3;
        if (m2) {
          var C2 = b3(l4), x4 = !C2 && fe2(l4), S3 = !C2 && !x4 && Be(l4);
          _3 = l4, C2 || x4 || S3 ? b3(f3) ? _3 = f3 : Z2(f3) ? _3 = ut3(f3) : x4 ? (m2 = false, _3 = pu(l4, true)) : S3 ? (m2 = false, _3 = du(l4, true)) : _3 = [] : gn2(l4) || Ce3(l4) ? (_3 = f3, Ce3(f3) ? _3 = fa(f3) : (!K3(f3) || Vt2(f3)) && (_3 = Lu2(l4))) : m2 = false;
        }
        m2 && (c5.set(l4, _3), u3(_3, l4, r3, o5, c5), c5.delete(l4)), Yr2(t, n4, _3);
      }
      function nu(t, e2) {
        var n4 = t.length;
        if (n4) return e2 += e2 < 0 ? n4 : 0, Qt2(e2, n4) ? t[e2] : i3;
      }
      function ru(t, e2, n4) {
        e2.length ? e2 = z4(e2, function(o5) {
          return b3(o5) ? function(c5) {
            return me3(c5, o5.length === 1 ? o5[0] : o5);
          } : o5;
        }) : e2 = [ct3];
        var r3 = -1;
        e2 = z4(e2, ht3(E4()));
        var u3 = js2(t, function(o5, c5, f3) {
          var l4 = z4(e2, function(v4) {
            return v4(o5);
          });
          return { criteria: l4, index: ++r3, value: o5 };
        });
        return pc(u3, function(o5, c5) {
          return th(o5, c5, n4);
        });
      }
      function Bf(t, e2) {
        return iu(t, e2, function(n4, r3) {
          return Ri(t, r3);
        });
      }
      function iu(t, e2, n4) {
        for (var r3 = -1, u3 = e2.length, o5 = {}; ++r3 < u3; ) {
          var c5 = e2[r3], f3 = me3(t, c5);
          n4(f3, c5) && hn2(o5, oe3(c5, t), f3);
        }
        return o5;
      }
      function Gf(t) {
        return function(e2) {
          return me3(e2, t);
        };
      }
      function ni2(t, e2, n4, r3) {
        var u3 = r3 ? lc : Te2, o5 = -1, c5 = e2.length, f3 = t;
        for (t === e2 && (e2 = ut3(e2)), n4 && (f3 = z4(t, ht3(n4))); ++o5 < c5; ) for (var l4 = 0, v4 = e2[o5], _3 = n4 ? n4(v4) : v4; (l4 = u3(f3, _3, l4, r3)) > -1; ) f3 !== t && Un.call(f3, l4, 1), Un.call(t, l4, 1);
        return t;
      }
      function su(t, e2) {
        for (var n4 = t ? e2.length : 0, r3 = n4 - 1; n4--; ) {
          var u3 = e2[n4];
          if (n4 == r3 || u3 !== o5) {
            var o5 = u3;
            Qt2(u3) ? Un.call(t, u3, 1) : ui2(t, u3);
          }
        }
        return t;
      }
      function ri2(t, e2) {
        return t + Wn(Fs2() * (e2 - t + 1));
      }
      function zf(t, e2, n4, r3) {
        for (var u3 = -1, o5 = V(Fn((e2 - t) / (n4 || 1)), 0), c5 = d3(o5); o5--; ) c5[r3 ? o5 : ++u3] = t, t += n4;
        return c5;
      }
      function ii2(t, e2) {
        var n4 = "";
        if (!t || e2 < 1 || e2 > ee2) return n4;
        do
          e2 % 2 && (n4 += t), e2 = Wn(e2 / 2), e2 && (t += t);
        while (e2);
        return n4;
      }
      function H(t, e2) {
        return Ci(Nu(t, e2, ct3), t + "");
      }
      function Kf(t) {
        return Bs2(Ge(t));
      }
      function Jf(t, e2) {
        var n4 = Ge(t);
        return rr3(n4, _e3(e2, 0, n4.length));
      }
      function hn2(t, e2, n4, r3) {
        if (!K3(t)) return t;
        e2 = oe3(e2, t);
        for (var u3 = -1, o5 = e2.length, c5 = o5 - 1, f3 = t; f3 != null && ++u3 < o5; ) {
          var l4 = Wt2(e2[u3]), v4 = n4;
          if (l4 === "__proto__" || l4 === "constructor" || l4 === "prototype") return t;
          if (u3 != c5) {
            var _3 = f3[l4];
            v4 = r3 ? r3(_3, l4, f3) : i3, v4 === i3 && (v4 = K3(_3) ? _3 : Qt2(e2[u3 + 1]) ? [] : {});
          }
          an2(f3, l4, v4), f3 = f3[l4];
        }
        return t;
      }
      var uu = Mn ? function(t, e2) {
        return Mn.set(t, e2), t;
      } : ct3, Yf = qn ? function(t, e2) {
        return qn(t, "toString", { configurable: true, enumerable: false, value: Ti(e2), writable: true });
      } : ct3;
      function Zf(t) {
        return rr3(Ge(t));
      }
      function At2(t, e2, n4) {
        var r3 = -1, u3 = t.length;
        e2 < 0 && (e2 = -e2 > u3 ? 0 : u3 + e2), n4 = n4 > u3 ? u3 : n4, n4 < 0 && (n4 += u3), u3 = e2 > n4 ? 0 : n4 - e2 >>> 0, e2 >>>= 0;
        for (var o5 = d3(u3); ++r3 < u3; ) o5[r3] = t[r3 + e2];
        return o5;
      }
      function Xf(t, e2) {
        var n4;
        return ue2(t, function(r3, u3, o5) {
          return n4 = e2(r3, u3, o5), !n4;
        }), !!n4;
      }
      function Zn(t, e2, n4) {
        var r3 = 0, u3 = t == null ? r3 : t.length;
        if (typeof e2 == "number" && e2 === e2 && u3 <= Xa) {
          for (; r3 < u3; ) {
            var o5 = r3 + u3 >>> 1, c5 = t[o5];
            c5 !== null && !pt3(c5) && (n4 ? c5 <= e2 : c5 < e2) ? r3 = o5 + 1 : u3 = o5;
          }
          return u3;
        }
        return si2(t, e2, ct3, n4);
      }
      function si2(t, e2, n4, r3) {
        var u3 = 0, o5 = t == null ? 0 : t.length;
        if (o5 === 0) return 0;
        e2 = n4(e2);
        for (var c5 = e2 !== e2, f3 = e2 === null, l4 = pt3(e2), v4 = e2 === i3; u3 < o5; ) {
          var _3 = Wn((u3 + o5) / 2), m2 = n4(t[_3]), C2 = m2 !== i3, x4 = m2 === null, S3 = m2 === m2, L2 = pt3(m2);
          if (c5) var O4 = r3 || S3;
          else v4 ? O4 = S3 && (r3 || C2) : f3 ? O4 = S3 && C2 && (r3 || !x4) : l4 ? O4 = S3 && C2 && !x4 && (r3 || !L2) : x4 || L2 ? O4 = false : O4 = r3 ? m2 <= e2 : m2 < e2;
          O4 ? u3 = _3 + 1 : o5 = _3;
        }
        return et3(o5, Za);
      }
      function au(t, e2) {
        for (var n4 = -1, r3 = t.length, u3 = 0, o5 = []; ++n4 < r3; ) {
          var c5 = t[n4], f3 = e2 ? e2(c5) : c5;
          if (!n4 || !Rt2(f3, l4)) {
            var l4 = f3;
            o5[u3++] = c5 === 0 ? 0 : c5;
          }
        }
        return o5;
      }
      function ou(t) {
        return typeof t == "number" ? t : pt3(t) ? wn2 : +t;
      }
      function lt3(t) {
        if (typeof t == "string") return t;
        if (b3(t)) return z4(t, lt3) + "";
        if (pt3(t)) return Ws2 ? Ws2.call(t) : "";
        var e2 = t + "";
        return e2 == "0" && 1 / t == -le2 ? "-0" : e2;
      }
      function ae3(t, e2, n4) {
        var r3 = -1, u3 = Sn2, o5 = t.length, c5 = true, f3 = [], l4 = f3;
        if (n4) c5 = false, u3 = Dr2;
        else if (o5 >= w4) {
          var v4 = e2 ? null : uh2(t);
          if (v4) return Rn2(v4);
          c5 = false, u3 = tn3, l4 = new ve2();
        } else l4 = e2 ? [] : f3;
        t: for (; ++r3 < o5; ) {
          var _3 = t[r3], m2 = e2 ? e2(_3) : _3;
          if (_3 = n4 || _3 !== 0 ? _3 : 0, c5 && m2 === m2) {
            for (var C2 = l4.length; C2--; ) if (l4[C2] === m2) continue t;
            e2 && l4.push(m2), f3.push(_3);
          } else u3(l4, m2, n4) || (l4 !== f3 && l4.push(m2), f3.push(_3));
        }
        return f3;
      }
      function ui2(t, e2) {
        return e2 = oe3(e2, t), t = $u2(t, e2), t == null || delete t[Wt2(It2(e2))];
      }
      function cu(t, e2, n4, r3) {
        return hn2(t, e2, n4(me3(t, e2)), r3);
      }
      function Xn(t, e2, n4, r3) {
        for (var u3 = t.length, o5 = r3 ? u3 : -1; (r3 ? o5-- : ++o5 < u3) && e2(t[o5], o5, t); ) ;
        return n4 ? At2(t, r3 ? 0 : o5, r3 ? o5 + 1 : u3) : At2(t, r3 ? o5 + 1 : 0, r3 ? u3 : o5);
      }
      function fu(t, e2) {
        var n4 = t;
        return n4 instanceof N2 && (n4 = n4.value()), Nr3(e2, function(r3, u3) {
          return u3.func.apply(u3.thisArg, re([r3], u3.args));
        }, n4);
      }
      function ai2(t, e2, n4) {
        var r3 = t.length;
        if (r3 < 2) return r3 ? ae3(t[0]) : [];
        for (var u3 = -1, o5 = d3(r3); ++u3 < r3; ) for (var c5 = t[u3], f3 = -1; ++f3 < r3; ) f3 != u3 && (o5[u3] = on3(o5[u3] || c5, t[f3], e2, n4));
        return ae3(tt3(o5, 1), e2, n4);
      }
      function hu(t, e2, n4) {
        for (var r3 = -1, u3 = t.length, o5 = e2.length, c5 = {}; ++r3 < u3; ) {
          var f3 = r3 < o5 ? e2[r3] : i3;
          n4(c5, t[r3], f3);
        }
        return c5;
      }
      function oi2(t) {
        return Z2(t) ? t : [];
      }
      function ci2(t) {
        return typeof t == "function" ? t : ct3;
      }
      function oe3(t, e2) {
        return b3(t) ? t : mi2(t, e2) ? [t] : Wu(q2(t));
      }
      var Qf = H;
      function ce2(t, e2, n4) {
        var r3 = t.length;
        return n4 = n4 === i3 ? r3 : n4, !e2 && n4 >= r3 ? t : At2(t, e2, n4);
      }
      var lu = $c || function(t) {
        return j4.clearTimeout(t);
      };
      function pu(t, e2) {
        if (e2) return t.slice();
        var n4 = t.length, r3 = Ds ? Ds(n4) : new t.constructor(n4);
        return t.copy(r3), r3;
      }
      function fi2(t) {
        var e2 = new t.constructor(t.byteLength);
        return new Nn(e2).set(new Nn(t)), e2;
      }
      function Vf(t, e2) {
        var n4 = e2 ? fi2(t.buffer) : t.buffer;
        return new t.constructor(n4, t.byteOffset, t.byteLength);
      }
      function kf(t) {
        var e2 = new t.constructor(t.source, Qi.exec(t));
        return e2.lastIndex = t.lastIndex, e2;
      }
      function jf(t) {
        return un2 ? M3(un2.call(t)) : {};
      }
      function du(t, e2) {
        var n4 = e2 ? fi2(t.buffer) : t.buffer;
        return new t.constructor(n4, t.byteOffset, t.length);
      }
      function gu2(t, e2) {
        if (t !== e2) {
          var n4 = t !== i3, r3 = t === null, u3 = t === t, o5 = pt3(t), c5 = e2 !== i3, f3 = e2 === null, l4 = e2 === e2, v4 = pt3(e2);
          if (!f3 && !v4 && !o5 && t > e2 || o5 && c5 && l4 && !f3 && !v4 || r3 && c5 && l4 || !n4 && l4 || !u3) return 1;
          if (!r3 && !o5 && !v4 && t < e2 || v4 && n4 && u3 && !r3 && !o5 || f3 && n4 && u3 || !c5 && u3 || !l4) return -1;
        }
        return 0;
      }
      function th(t, e2, n4) {
        for (var r3 = -1, u3 = t.criteria, o5 = e2.criteria, c5 = u3.length, f3 = n4.length; ++r3 < c5; ) {
          var l4 = gu2(u3[r3], o5[r3]);
          if (l4) {
            if (r3 >= f3) return l4;
            var v4 = n4[r3];
            return l4 * (v4 == "desc" ? -1 : 1);
          }
        }
        return t.index - e2.index;
      }
      function vu(t, e2, n4, r3) {
        for (var u3 = -1, o5 = t.length, c5 = n4.length, f3 = -1, l4 = e2.length, v4 = V(o5 - c5, 0), _3 = d3(l4 + v4), m2 = !r3; ++f3 < l4; ) _3[f3] = e2[f3];
        for (; ++u3 < c5; ) (m2 || u3 < o5) && (_3[n4[u3]] = t[u3]);
        for (; v4--; ) _3[f3++] = t[u3++];
        return _3;
      }
      function _u2(t, e2, n4, r3) {
        for (var u3 = -1, o5 = t.length, c5 = -1, f3 = n4.length, l4 = -1, v4 = e2.length, _3 = V(o5 - f3, 0), m2 = d3(_3 + v4), C2 = !r3; ++u3 < _3; ) m2[u3] = t[u3];
        for (var x4 = u3; ++l4 < v4; ) m2[x4 + l4] = e2[l4];
        for (; ++c5 < f3; ) (C2 || u3 < o5) && (m2[x4 + n4[c5]] = t[u3++]);
        return m2;
      }
      function ut3(t, e2) {
        var n4 = -1, r3 = t.length;
        for (e2 || (e2 = d3(r3)); ++n4 < r3; ) e2[n4] = t[n4];
        return e2;
      }
      function Ft2(t, e2, n4, r3) {
        var u3 = !n4;
        n4 || (n4 = {});
        for (var o5 = -1, c5 = e2.length; ++o5 < c5; ) {
          var f3 = e2[o5], l4 = r3 ? r3(n4[f3], t[f3], f3, n4, t) : i3;
          l4 === i3 && (l4 = t[f3]), u3 ? Yt3(n4, f3, l4) : an2(n4, f3, l4);
        }
        return n4;
      }
      function eh(t, e2) {
        return Ft2(t, _i2(t), e2);
      }
      function nh(t, e2) {
        return Ft2(t, bu(t), e2);
      }
      function Qn(t, e2) {
        return function(n4, r3) {
          var u3 = b3(n4) ? uc : xf, o5 = e2 ? e2() : {};
          return u3(n4, t, E4(r3, 2), o5);
        };
      }
      function Fe(t) {
        return H(function(e2, n4) {
          var r3 = -1, u3 = n4.length, o5 = u3 > 1 ? n4[u3 - 1] : i3, c5 = u3 > 2 ? n4[2] : i3;
          for (o5 = t.length > 3 && typeof o5 == "function" ? (u3--, o5) : i3, c5 && it3(n4[0], n4[1], c5) && (o5 = u3 < 3 ? i3 : o5, u3 = 1), e2 = M3(e2); ++r3 < u3; ) {
            var f3 = n4[r3];
            f3 && t(e2, f3, r3, o5);
          }
          return e2;
        });
      }
      function mu2(t, e2) {
        return function(n4, r3) {
          if (n4 == null) return n4;
          if (!at3(n4)) return t(n4, r3);
          for (var u3 = n4.length, o5 = e2 ? u3 : -1, c5 = M3(n4); (e2 ? o5-- : ++o5 < u3) && r3(c5[o5], o5, c5) !== false; ) ;
          return n4;
        };
      }
      function wu(t) {
        return function(e2, n4, r3) {
          for (var u3 = -1, o5 = M3(e2), c5 = r3(e2), f3 = c5.length; f3--; ) {
            var l4 = c5[t ? f3 : ++u3];
            if (n4(o5[l4], l4, o5) === false) break;
          }
          return e2;
        };
      }
      function rh(t, e2, n4) {
        var r3 = e2 & vt2, u3 = ln2(t);
        function o5() {
          var c5 = this && this !== j4 && this instanceof o5 ? u3 : t;
          return c5.apply(r3 ? n4 : this, arguments);
        }
        return o5;
      }
      function Pu2(t) {
        return function(e2) {
          e2 = q2(e2);
          var n4 = Le2(e2) ? St2(e2) : i3, r3 = n4 ? n4[0] : e2.charAt(0), u3 = n4 ? ce2(n4, 1).join("") : e2.slice(1);
          return r3[t]() + u3;
        };
      }
      function We(t) {
        return function(e2) {
          return Nr3(ma(_a(e2).replace(Jo, "")), t, "");
        };
      }
      function ln2(t) {
        return function() {
          var e2 = arguments;
          switch (e2.length) {
            case 0:
              return new t();
            case 1:
              return new t(e2[0]);
            case 2:
              return new t(e2[0], e2[1]);
            case 3:
              return new t(e2[0], e2[1], e2[2]);
            case 4:
              return new t(e2[0], e2[1], e2[2], e2[3]);
            case 5:
              return new t(e2[0], e2[1], e2[2], e2[3], e2[4]);
            case 6:
              return new t(e2[0], e2[1], e2[2], e2[3], e2[4], e2[5]);
            case 7:
              return new t(e2[0], e2[1], e2[2], e2[3], e2[4], e2[5], e2[6]);
          }
          var n4 = qe(t.prototype), r3 = t.apply(n4, e2);
          return K3(r3) ? r3 : n4;
        };
      }
      function ih(t, e2, n4) {
        var r3 = ln2(t);
        function u3() {
          for (var o5 = arguments.length, c5 = d3(o5), f3 = o5, l4 = Me(u3); f3--; ) c5[f3] = arguments[f3];
          var v4 = o5 < 3 && c5[0] !== l4 && c5[o5 - 1] !== l4 ? [] : ie(c5, l4);
          if (o5 -= v4.length, o5 < n4) return Eu2(t, e2, Vn, u3.placeholder, i3, c5, v4, i3, i3, n4 - o5);
          var _3 = this && this !== j4 && this instanceof u3 ? r3 : t;
          return ft2(_3, this, c5);
        }
        return u3;
      }
      function Cu2(t) {
        return function(e2, n4, r3) {
          var u3 = M3(e2);
          if (!at3(e2)) {
            var o5 = E4(n4, 3);
            e2 = k3(e2), n4 = function(f3) {
              return o5(u3[f3], f3, u3);
            };
          }
          var c5 = t(e2, n4, r3);
          return c5 > -1 ? u3[o5 ? e2[c5] : c5] : i3;
        };
      }
      function Au(t) {
        return Xt2(function(e2) {
          var n4 = e2.length, r3 = n4, u3 = Pt2.prototype.thru;
          for (t && e2.reverse(); r3--; ) {
            var o5 = e2[r3];
            if (typeof o5 != "function") throw new wt2(y6);
            if (u3 && !c5 && er3(o5) == "wrapper") var c5 = new Pt2([], true);
          }
          for (r3 = c5 ? r3 : n4; ++r3 < n4; ) {
            o5 = e2[r3];
            var f3 = er3(o5), l4 = f3 == "wrapper" ? gi2(o5) : i3;
            l4 && wi(l4[0]) && l4[1] == (Gt2 | Nt2 | $t2 | Je) && !l4[4].length && l4[9] == 1 ? c5 = c5[er3(l4[0])].apply(c5, l4[3]) : c5 = o5.length == 1 && wi(o5) ? c5[f3]() : c5.thru(o5);
          }
          return function() {
            var v4 = arguments, _3 = v4[0];
            if (c5 && v4.length == 1 && b3(_3)) return c5.plant(_3).value();
            for (var m2 = 0, C2 = n4 ? e2[m2].apply(this, v4) : _3; ++m2 < n4; ) C2 = e2[m2].call(this, C2);
            return C2;
          };
        });
      }
      function Vn(t, e2, n4, r3, u3, o5, c5, f3, l4, v4) {
        var _3 = e2 & Gt2, m2 = e2 & vt2, C2 = e2 & he2, x4 = e2 & (Nt2 | ye2), S3 = e2 & gr3, L2 = C2 ? i3 : ln2(t);
        function O4() {
          for (var D3 = arguments.length, $2 = d3(D3), dt3 = D3; dt3--; ) $2[dt3] = arguments[dt3];
          if (x4) var st3 = Me(O4), gt3 = gc($2, st3);
          if (r3 && ($2 = vu($2, r3, u3, x4)), o5 && ($2 = _u2($2, o5, c5, x4)), D3 -= gt3, x4 && D3 < v4) {
            var X = ie($2, st3);
            return Eu2(t, e2, Vn, O4.placeholder, n4, $2, X, f3, l4, v4 - D3);
          }
          var bt2 = m2 ? n4 : this, jt2 = C2 ? bt2[t] : t;
          return D3 = $2.length, f3 ? $2 = xh2($2, f3) : S3 && D3 > 1 && $2.reverse(), _3 && l4 < D3 && ($2.length = l4), this && this !== j4 && this instanceof O4 && (jt2 = L2 || ln2(jt2)), jt2.apply(bt2, $2);
        }
        return O4;
      }
      function Iu2(t, e2) {
        return function(n4, r3) {
          return Lf(n4, t, e2(r3), {});
        };
      }
      function kn(t, e2) {
        return function(n4, r3) {
          var u3;
          if (n4 === i3 && r3 === i3) return e2;
          if (n4 !== i3 && (u3 = n4), r3 !== i3) {
            if (u3 === i3) return r3;
            typeof n4 == "string" || typeof r3 == "string" ? (n4 = lt3(n4), r3 = lt3(r3)) : (n4 = ou(n4), r3 = ou(r3)), u3 = t(n4, r3);
          }
          return u3;
        };
      }
      function hi2(t) {
        return Xt2(function(e2) {
          return e2 = z4(e2, ht3(E4())), H(function(n4) {
            var r3 = this;
            return t(e2, function(u3) {
              return ft2(u3, r3, n4);
            });
          });
        });
      }
      function jn(t, e2) {
        e2 = e2 === i3 ? " " : lt3(e2);
        var n4 = e2.length;
        if (n4 < 2) return n4 ? ii2(e2, t) : e2;
        var r3 = ii2(e2, Fn(t / He(e2)));
        return Le2(e2) ? ce2(St2(r3), 0, t).join("") : r3.slice(0, t);
      }
      function sh(t, e2, n4, r3) {
        var u3 = e2 & vt2, o5 = ln2(t);
        function c5() {
          for (var f3 = -1, l4 = arguments.length, v4 = -1, _3 = r3.length, m2 = d3(_3 + l4), C2 = this && this !== j4 && this instanceof c5 ? o5 : t; ++v4 < _3; ) m2[v4] = r3[v4];
          for (; l4--; ) m2[v4++] = arguments[++f3];
          return ft2(C2, u3 ? n4 : this, m2);
        }
        return c5;
      }
      function xu2(t) {
        return function(e2, n4, r3) {
          return r3 && typeof r3 != "number" && it3(e2, n4, r3) && (n4 = r3 = i3), e2 = kt2(e2), n4 === i3 ? (n4 = e2, e2 = 0) : n4 = kt2(n4), r3 = r3 === i3 ? e2 < n4 ? 1 : -1 : kt2(r3), zf(e2, n4, r3, t);
        };
      }
      function tr2(t) {
        return function(e2, n4) {
          return typeof e2 == "string" && typeof n4 == "string" || (e2 = xt2(e2), n4 = xt2(n4)), t(e2, n4);
        };
      }
      function Eu2(t, e2, n4, r3, u3, o5, c5, f3, l4, v4) {
        var _3 = e2 & Nt2, m2 = _3 ? c5 : i3, C2 = _3 ? i3 : c5, x4 = _3 ? o5 : i3, S3 = _3 ? i3 : o5;
        e2 |= _3 ? $t2 : Se, e2 &= ~(_3 ? Se : $t2), e2 & Gi || (e2 &= ~(vt2 | he2));
        var L2 = [t, e2, u3, x4, m2, S3, C2, f3, l4, v4], O4 = n4.apply(i3, L2);
        return wi(t) && Uu2(O4, L2), O4.placeholder = r3, qu2(O4, t, e2);
      }
      function li2(t) {
        var e2 = Q2[t];
        return function(n4, r3) {
          if (n4 = xt2(n4), r3 = r3 == null ? 0 : et3(T3(r3), 292), r3 && qs3(n4)) {
            var u3 = (q2(n4) + "e").split("e"), o5 = e2(u3[0] + "e" + (+u3[1] + r3));
            return u3 = (q2(o5) + "e").split("e"), +(u3[0] + "e" + (+u3[1] - r3));
          }
          return e2(n4);
        };
      }
      var uh2 = $e && 1 / Rn2(new $e([, -0]))[1] == le2 ? function(t) {
        return new $e(t);
      } : Di2;
      function yu(t) {
        return function(e2) {
          var n4 = nt3(e2);
          return n4 == Et2 ? Br2(e2) : n4 == yt3 ? Ac(e2) : dc(e2, t(e2));
        };
      }
      function Zt2(t, e2, n4, r3, u3, o5, c5, f3) {
        var l4 = e2 & he2;
        if (!l4 && typeof t != "function") throw new wt2(y6);
        var v4 = r3 ? r3.length : 0;
        if (v4 || (e2 &= ~($t2 | Se), r3 = u3 = i3), c5 = c5 === i3 ? c5 : V(T3(c5), 0), f3 = f3 === i3 ? f3 : T3(f3), v4 -= u3 ? u3.length : 0, e2 & Se) {
          var _3 = r3, m2 = u3;
          r3 = u3 = i3;
        }
        var C2 = l4 ? i3 : gi2(t), x4 = [t, e2, n4, r3, u3, _3, m2, o5, c5, f3];
        if (C2 && Ch2(x4, C2), t = x4[0], e2 = x4[1], n4 = x4[2], r3 = x4[3], u3 = x4[4], f3 = x4[9] = x4[9] === i3 ? l4 ? 0 : t.length : V(x4[9] - v4, 0), !f3 && e2 & (Nt2 | ye2) && (e2 &= ~(Nt2 | ye2)), !e2 || e2 == vt2) var S3 = rh(t, e2, n4);
        else e2 == Nt2 || e2 == ye2 ? S3 = ih(t, e2, f3) : (e2 == $t2 || e2 == (vt2 | $t2)) && !u3.length ? S3 = sh(t, e2, n4, r3) : S3 = Vn.apply(i3, x4);
        var L2 = C2 ? uu : Uu2;
        return qu2(L2(S3, x4), t, e2);
      }
      function Su2(t, e2, n4, r3) {
        return t === i3 || Rt2(t, Ne[n4]) && !W.call(r3, n4) ? e2 : t;
      }
      function Ou2(t, e2, n4, r3, u3, o5) {
        return K3(t) && K3(e2) && (o5.set(e2, t), Yn(t, e2, i3, Ou2, o5), o5.delete(e2)), t;
      }
      function ah(t) {
        return gn2(t) ? i3 : t;
      }
      function Ru2(t, e2, n4, r3, u3, o5) {
        var c5 = n4 & Ee2, f3 = t.length, l4 = e2.length;
        if (f3 != l4 && !(c5 && l4 > f3)) return false;
        var v4 = o5.get(t), _3 = o5.get(e2);
        if (v4 && _3) return v4 == e2 && _3 == t;
        var m2 = -1, C2 = true, x4 = n4 & mn2 ? new ve2() : i3;
        for (o5.set(t, e2), o5.set(e2, t); ++m2 < f3; ) {
          var S3 = t[m2], L2 = e2[m2];
          if (r3) var O4 = c5 ? r3(L2, S3, m2, e2, t, o5) : r3(S3, L2, m2, t, e2, o5);
          if (O4 !== i3) {
            if (O4) continue;
            C2 = false;
            break;
          }
          if (x4) {
            if (!$r2(e2, function(D3, $2) {
              if (!tn3(x4, $2) && (S3 === D3 || u3(S3, D3, n4, r3, o5))) return x4.push($2);
            })) {
              C2 = false;
              break;
            }
          } else if (!(S3 === L2 || u3(S3, L2, n4, r3, o5))) {
            C2 = false;
            break;
          }
        }
        return o5.delete(t), o5.delete(e2), C2;
      }
      function oh(t, e2, n4, r3, u3, o5, c5) {
        switch (n4) {
          case Re2:
            if (t.byteLength != e2.byteLength || t.byteOffset != e2.byteOffset) return false;
            t = t.buffer, e2 = e2.buffer;
          case je:
            return !(t.byteLength != e2.byteLength || !o5(new Nn(t), new Nn(e2)));
          case Ye:
          case Ze4:
          case Xe2:
            return Rt2(+t, +e2);
          case Cn2:
            return t.name == e2.name && t.message == e2.message;
          case Qe2:
          case Ve:
            return t == e2 + "";
          case Et2:
            var f3 = Br2;
          case yt3:
            var l4 = r3 & Ee2;
            if (f3 || (f3 = Rn2), t.size != e2.size && !l4) return false;
            var v4 = c5.get(t);
            if (v4) return v4 == e2;
            r3 |= mn2, c5.set(t, e2);
            var _3 = Ru2(f3(t), f3(e2), r3, u3, o5, c5);
            return c5.delete(t), _3;
          case In2:
            if (un2) return un2.call(t) == un2.call(e2);
        }
        return false;
      }
      function ch2(t, e2, n4, r3, u3, o5) {
        var c5 = n4 & Ee2, f3 = pi2(t), l4 = f3.length, v4 = pi2(e2), _3 = v4.length;
        if (l4 != _3 && !c5) return false;
        for (var m2 = l4; m2--; ) {
          var C2 = f3[m2];
          if (!(c5 ? C2 in e2 : W.call(e2, C2))) return false;
        }
        var x4 = o5.get(t), S3 = o5.get(e2);
        if (x4 && S3) return x4 == e2 && S3 == t;
        var L2 = true;
        o5.set(t, e2), o5.set(e2, t);
        for (var O4 = c5; ++m2 < l4; ) {
          C2 = f3[m2];
          var D3 = t[C2], $2 = e2[C2];
          if (r3) var dt3 = c5 ? r3($2, D3, C2, e2, t, o5) : r3(D3, $2, C2, t, e2, o5);
          if (!(dt3 === i3 ? D3 === $2 || u3(D3, $2, n4, r3, o5) : dt3)) {
            L2 = false;
            break;
          }
          O4 || (O4 = C2 == "constructor");
        }
        if (L2 && !O4) {
          var st3 = t.constructor, gt3 = e2.constructor;
          st3 != gt3 && "constructor" in t && "constructor" in e2 && !(typeof st3 == "function" && st3 instanceof st3 && typeof gt3 == "function" && gt3 instanceof gt3) && (L2 = false);
        }
        return o5.delete(t), o5.delete(e2), L2;
      }
      function Xt2(t) {
        return Ci(Nu(t, i3, zu2), t + "");
      }
      function pi2(t) {
        return Xs2(t, k3, _i2);
      }
      function di2(t) {
        return Xs2(t, ot3, bu);
      }
      var gi2 = Mn ? function(t) {
        return Mn.get(t);
      } : Di2;
      function er3(t) {
        for (var e2 = t.name + "", n4 = Ue[e2], r3 = W.call(Ue, e2) ? n4.length : 0; r3--; ) {
          var u3 = n4[r3], o5 = u3.func;
          if (o5 == null || o5 == t) return u3.name;
        }
        return e2;
      }
      function Me(t) {
        var e2 = W.call(a4, "placeholder") ? a4 : t;
        return e2.placeholder;
      }
      function E4() {
        var t = a4.iteratee || Li;
        return t = t === Li ? ks2 : t, arguments.length ? t(arguments[0], arguments[1]) : t;
      }
      function nr2(t, e2) {
        var n4 = t.__data__;
        return _h2(e2) ? n4[typeof e2 == "string" ? "string" : "hash"] : n4.map;
      }
      function vi(t) {
        for (var e2 = k3(t), n4 = e2.length; n4--; ) {
          var r3 = e2[n4], u3 = t[r3];
          e2[n4] = [r3, u3, Hu(u3)];
        }
        return e2;
      }
      function we3(t, e2) {
        var n4 = wc(t, e2);
        return Vs2(n4) ? n4 : i3;
      }
      function fh(t) {
        var e2 = W.call(t, de), n4 = t[de];
        try {
          t[de] = i3;
          var r3 = true;
        } catch {
        }
        var u3 = Hn.call(t);
        return r3 && (e2 ? t[de] = n4 : delete t[de]), u3;
      }
      var _i2 = zr2 ? function(t) {
        return t == null ? [] : (t = M3(t), ne2(zr2(t), function(e2) {
          return $s2.call(t, e2);
        }));
      } : Ni, bu = zr2 ? function(t) {
        for (var e2 = []; t; ) re(e2, _i2(t)), t = $n(t);
        return e2;
      } : Ni, nt3 = rt3;
      (Kr2 && nt3(new Kr2(new ArrayBuffer(1))) != Re2 || nn2 && nt3(new nn2()) != Et2 || Jr2 && nt3(Jr2.resolve()) != Ji || $e && nt3(new $e()) != yt3 || rn2 && nt3(new rn2()) != ke) && (nt3 = function(t) {
        var e2 = rt3(t), n4 = e2 == zt2 ? t.constructor : i3, r3 = n4 ? Pe3(n4) : "";
        if (r3) switch (r3) {
          case Kc:
            return Re2;
          case Jc:
            return Et2;
          case Yc:
            return Ji;
          case Zc:
            return yt3;
          case Xc:
            return ke;
        }
        return e2;
      });
      function hh2(t, e2, n4) {
        for (var r3 = -1, u3 = n4.length; ++r3 < u3; ) {
          var o5 = n4[r3], c5 = o5.size;
          switch (o5.type) {
            case "drop":
              t += c5;
              break;
            case "dropRight":
              e2 -= c5;
              break;
            case "take":
              e2 = et3(e2, t + c5);
              break;
            case "takeRight":
              t = V(t, e2 - c5);
              break;
          }
        }
        return { start: t, end: e2 };
      }
      function lh2(t) {
        var e2 = t.match(_o);
        return e2 ? e2[1].split(mo) : [];
      }
      function Tu2(t, e2, n4) {
        e2 = oe3(e2, t);
        for (var r3 = -1, u3 = e2.length, o5 = false; ++r3 < u3; ) {
          var c5 = Wt2(e2[r3]);
          if (!(o5 = t != null && n4(t, c5))) break;
          t = t[c5];
        }
        return o5 || ++r3 != u3 ? o5 : (u3 = t == null ? 0 : t.length, !!u3 && cr2(u3) && Qt2(c5, u3) && (b3(t) || Ce3(t)));
      }
      function ph2(t) {
        var e2 = t.length, n4 = new t.constructor(e2);
        return e2 && typeof t[0] == "string" && W.call(t, "index") && (n4.index = t.index, n4.input = t.input), n4;
      }
      function Lu2(t) {
        return typeof t.constructor == "function" && !pn2(t) ? qe($n(t)) : {};
      }
      function dh2(t, e2, n4) {
        var r3 = t.constructor;
        switch (e2) {
          case je:
            return fi2(t);
          case Ye:
          case Ze4:
            return new r3(+t);
          case Re2:
            return Vf(t, n4);
          case vr2:
          case _r2:
          case mr2:
          case wr2:
          case Pr2:
          case Cr2:
          case Ar2:
          case Ir2:
          case xr2:
            return du(t, n4);
          case Et2:
            return new r3();
          case Xe2:
          case Ve:
            return new r3(t);
          case Qe2:
            return kf(t);
          case yt3:
            return new r3();
          case In2:
            return jf(t);
        }
      }
      function gh2(t, e2) {
        var n4 = e2.length;
        if (!n4) return t;
        var r3 = n4 - 1;
        return e2[r3] = (n4 > 1 ? "& " : "") + e2[r3], e2 = e2.join(n4 > 2 ? ", " : " "), t.replace(vo, `{
/* [wrapped with ` + e2 + `] */
`);
      }
      function vh2(t) {
        return b3(t) || Ce3(t) || !!(Us2 && t && t[Us2]);
      }
      function Qt2(t, e2) {
        var n4 = typeof t;
        return e2 = e2 ?? ee2, !!e2 && (n4 == "number" || n4 != "symbol" && So.test(t)) && t > -1 && t % 1 == 0 && t < e2;
      }
      function it3(t, e2, n4) {
        if (!K3(n4)) return false;
        var r3 = typeof e2;
        return (r3 == "number" ? at3(n4) && Qt2(e2, n4.length) : r3 == "string" && e2 in n4) ? Rt2(n4[e2], t) : false;
      }
      function mi2(t, e2) {
        if (b3(t)) return false;
        var n4 = typeof t;
        return n4 == "number" || n4 == "symbol" || n4 == "boolean" || t == null || pt3(t) ? true : ho.test(t) || !fo.test(t) || e2 != null && t in M3(e2);
      }
      function _h2(t) {
        var e2 = typeof t;
        return e2 == "string" || e2 == "number" || e2 == "symbol" || e2 == "boolean" ? t !== "__proto__" : t === null;
      }
      function wi(t) {
        var e2 = er3(t), n4 = a4[e2];
        if (typeof n4 != "function" || !(e2 in N2.prototype)) return false;
        if (t === n4) return true;
        var r3 = gi2(n4);
        return !!r3 && t === r3[0];
      }
      function mh2(t) {
        return !!Hs2 && Hs2 in t;
      }
      var wh2 = Tn2 ? Vt2 : $i;
      function pn2(t) {
        var e2 = t && t.constructor, n4 = typeof e2 == "function" && e2.prototype || Ne;
        return t === n4;
      }
      function Hu(t) {
        return t === t && !K3(t);
      }
      function Du2(t, e2) {
        return function(n4) {
          return n4 == null ? false : n4[t] === e2 && (e2 !== i3 || t in M3(n4));
        };
      }
      function Ph(t) {
        var e2 = ar2(t, function(r3) {
          return n4.size === Ke && n4.clear(), r3;
        }), n4 = e2.cache;
        return e2;
      }
      function Ch2(t, e2) {
        var n4 = t[1], r3 = e2[1], u3 = n4 | r3, o5 = u3 < (vt2 | he2 | Gt2), c5 = r3 == Gt2 && n4 == Nt2 || r3 == Gt2 && n4 == Je && t[7].length <= e2[8] || r3 == (Gt2 | Je) && e2[7].length <= e2[8] && n4 == Nt2;
        if (!(o5 || c5)) return t;
        r3 & vt2 && (t[2] = e2[2], u3 |= n4 & vt2 ? 0 : Gi);
        var f3 = e2[3];
        if (f3) {
          var l4 = t[3];
          t[3] = l4 ? vu(l4, f3, e2[4]) : f3, t[4] = l4 ? ie(t[3], Ie2) : e2[4];
        }
        return f3 = e2[5], f3 && (l4 = t[5], t[5] = l4 ? _u2(l4, f3, e2[6]) : f3, t[6] = l4 ? ie(t[5], Ie2) : e2[6]), f3 = e2[7], f3 && (t[7] = f3), r3 & Gt2 && (t[8] = t[8] == null ? e2[8] : et3(t[8], e2[8])), t[9] == null && (t[9] = e2[9]), t[0] = e2[0], t[1] = u3, t;
      }
      function Ah2(t) {
        var e2 = [];
        if (t != null) for (var n4 in M3(t)) e2.push(n4);
        return e2;
      }
      function Ih(t) {
        return Hn.call(t);
      }
      function Nu(t, e2, n4) {
        return e2 = V(e2 === i3 ? t.length - 1 : e2, 0), function() {
          for (var r3 = arguments, u3 = -1, o5 = V(r3.length - e2, 0), c5 = d3(o5); ++u3 < o5; ) c5[u3] = r3[e2 + u3];
          u3 = -1;
          for (var f3 = d3(e2 + 1); ++u3 < e2; ) f3[u3] = r3[u3];
          return f3[e2] = n4(c5), ft2(t, this, f3);
        };
      }
      function $u2(t, e2) {
        return e2.length < 2 ? t : me3(t, At2(e2, 0, -1));
      }
      function xh2(t, e2) {
        for (var n4 = t.length, r3 = et3(e2.length, n4), u3 = ut3(t); r3--; ) {
          var o5 = e2[r3];
          t[r3] = Qt2(o5, n4) ? u3[o5] : i3;
        }
        return t;
      }
      function Pi(t, e2) {
        if (!(e2 === "constructor" && typeof t[e2] == "function") && e2 != "__proto__") return t[e2];
      }
      var Uu2 = Fu2(uu), dn2 = qc || function(t, e2) {
        return j4.setTimeout(t, e2);
      }, Ci = Fu2(Yf);
      function qu2(t, e2, n4) {
        var r3 = e2 + "";
        return Ci(t, gh2(r3, Eh2(lh2(r3), n4)));
      }
      function Fu2(t) {
        var e2 = 0, n4 = 0;
        return function() {
          var r3 = Bc(), u3 = za - (r3 - n4);
          if (n4 = r3, u3 > 0) {
            if (++e2 >= Ga) return arguments[0];
          } else e2 = 0;
          return t.apply(i3, arguments);
        };
      }
      function rr3(t, e2) {
        var n4 = -1, r3 = t.length, u3 = r3 - 1;
        for (e2 = e2 === i3 ? r3 : e2; ++n4 < e2; ) {
          var o5 = ri2(n4, u3), c5 = t[o5];
          t[o5] = t[n4], t[n4] = c5;
        }
        return t.length = e2, t;
      }
      var Wu = Ph(function(t) {
        var e2 = [];
        return t.charCodeAt(0) === 46 && e2.push(""), t.replace(lo, function(n4, r3, u3, o5) {
          e2.push(u3 ? o5.replace(Co, "$1") : r3 || n4);
        }), e2;
      });
      function Wt2(t) {
        if (typeof t == "string" || pt3(t)) return t;
        var e2 = t + "";
        return e2 == "0" && 1 / t == -le2 ? "-0" : e2;
      }
      function Pe3(t) {
        if (t != null) {
          try {
            return Ln.call(t);
          } catch {
          }
          try {
            return t + "";
          } catch {
          }
        }
        return "";
      }
      function Eh2(t, e2) {
        return mt2(Qa, function(n4) {
          var r3 = "_." + n4[0];
          e2 & n4[1] && !Sn2(t, r3) && t.push(r3);
        }), t.sort();
      }
      function Mu2(t) {
        if (t instanceof N2) return t.clone();
        var e2 = new Pt2(t.__wrapped__, t.__chain__);
        return e2.__actions__ = ut3(t.__actions__), e2.__index__ = t.__index__, e2.__values__ = t.__values__, e2;
      }
      function yh2(t, e2, n4) {
        (n4 ? it3(t, e2, n4) : e2 === i3) ? e2 = 1 : e2 = V(T3(e2), 0);
        var r3 = t == null ? 0 : t.length;
        if (!r3 || e2 < 1) return [];
        for (var u3 = 0, o5 = 0, c5 = d3(Fn(r3 / e2)); u3 < r3; ) c5[o5++] = At2(t, u3, u3 += e2);
        return c5;
      }
      function Sh2(t) {
        for (var e2 = -1, n4 = t == null ? 0 : t.length, r3 = 0, u3 = []; ++e2 < n4; ) {
          var o5 = t[e2];
          o5 && (u3[r3++] = o5);
        }
        return u3;
      }
      function Oh() {
        var t = arguments.length;
        if (!t) return [];
        for (var e2 = d3(t - 1), n4 = arguments[0], r3 = t; r3--; ) e2[r3 - 1] = arguments[r3];
        return re(b3(n4) ? ut3(n4) : [n4], tt3(e2, 1));
      }
      var Rh2 = H(function(t, e2) {
        return Z2(t) ? on3(t, tt3(e2, 1, Z2, true)) : [];
      }), bh2 = H(function(t, e2) {
        var n4 = It2(e2);
        return Z2(n4) && (n4 = i3), Z2(t) ? on3(t, tt3(e2, 1, Z2, true), E4(n4, 2)) : [];
      }), Th = H(function(t, e2) {
        var n4 = It2(e2);
        return Z2(n4) && (n4 = i3), Z2(t) ? on3(t, tt3(e2, 1, Z2, true), i3, n4) : [];
      });
      function Lh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), At2(t, e2 < 0 ? 0 : e2, r3)) : [];
      }
      function Hh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), e2 = r3 - e2, At2(t, 0, e2 < 0 ? 0 : e2)) : [];
      }
      function Dh(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3), true, true) : [];
      }
      function Nh(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3), true) : [];
      }
      function $h(t, e2, n4, r3) {
        var u3 = t == null ? 0 : t.length;
        return u3 ? (n4 && typeof n4 != "number" && it3(t, e2, n4) && (n4 = 0, r3 = u3), Of(t, e2, n4, r3)) : [];
      }
      function Bu2(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = n4 == null ? 0 : T3(n4);
        return u3 < 0 && (u3 = V(r3 + u3, 0)), On2(t, E4(e2, 3), u3);
      }
      function Gu(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = r3 - 1;
        return n4 !== i3 && (u3 = T3(n4), u3 = n4 < 0 ? V(r3 + u3, 0) : et3(u3, r3 - 1)), On2(t, E4(e2, 3), u3, true);
      }
      function zu2(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? tt3(t, 1) : [];
      }
      function Uh(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? tt3(t, le2) : [];
      }
      function qh(t, e2) {
        var n4 = t == null ? 0 : t.length;
        return n4 ? (e2 = e2 === i3 ? 1 : T3(e2), tt3(t, e2)) : [];
      }
      function Fh(t) {
        for (var e2 = -1, n4 = t == null ? 0 : t.length, r3 = {}; ++e2 < n4; ) {
          var u3 = t[e2];
          r3[u3[0]] = u3[1];
        }
        return r3;
      }
      function Ku(t) {
        return t && t.length ? t[0] : i3;
      }
      function Wh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = n4 == null ? 0 : T3(n4);
        return u3 < 0 && (u3 = V(r3 + u3, 0)), Te2(t, e2, u3);
      }
      function Mh2(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? At2(t, 0, -1) : [];
      }
      var Bh2 = H(function(t) {
        var e2 = z4(t, oi2);
        return e2.length && e2[0] === t[0] ? kr2(e2) : [];
      }), Gh = H(function(t) {
        var e2 = It2(t), n4 = z4(t, oi2);
        return e2 === It2(n4) ? e2 = i3 : n4.pop(), n4.length && n4[0] === t[0] ? kr2(n4, E4(e2, 2)) : [];
      }), zh = H(function(t) {
        var e2 = It2(t), n4 = z4(t, oi2);
        return e2 = typeof e2 == "function" ? e2 : i3, e2 && n4.pop(), n4.length && n4[0] === t[0] ? kr2(n4, i3, e2) : [];
      });
      function Kh(t, e2) {
        return t == null ? "" : Wc.call(t, e2);
      }
      function It2(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? t[e2 - 1] : i3;
      }
      function Jh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        if (!r3) return -1;
        var u3 = r3;
        return n4 !== i3 && (u3 = T3(n4), u3 = u3 < 0 ? V(r3 + u3, 0) : et3(u3, r3 - 1)), e2 === e2 ? xc(t, e2, u3) : On2(t, Es3, u3, true);
      }
      function Yh(t, e2) {
        return t && t.length ? nu(t, T3(e2)) : i3;
      }
      var Zh = H(Ju);
      function Ju(t, e2) {
        return t && t.length && e2 && e2.length ? ni2(t, e2) : t;
      }
      function Xh(t, e2, n4) {
        return t && t.length && e2 && e2.length ? ni2(t, e2, E4(n4, 2)) : t;
      }
      function Qh(t, e2, n4) {
        return t && t.length && e2 && e2.length ? ni2(t, e2, i3, n4) : t;
      }
      var Vh = Xt2(function(t, e2) {
        var n4 = t == null ? 0 : t.length, r3 = Zr2(t, e2);
        return su(t, z4(e2, function(u3) {
          return Qt2(u3, n4) ? +u3 : u3;
        }).sort(gu2)), r3;
      });
      function kh(t, e2) {
        var n4 = [];
        if (!(t && t.length)) return n4;
        var r3 = -1, u3 = [], o5 = t.length;
        for (e2 = E4(e2, 3); ++r3 < o5; ) {
          var c5 = t[r3];
          e2(c5, r3, t) && (n4.push(c5), u3.push(r3));
        }
        return su(t, u3), n4;
      }
      function Ai(t) {
        return t == null ? t : zc.call(t);
      }
      function jh(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (n4 && typeof n4 != "number" && it3(t, e2, n4) ? (e2 = 0, n4 = r3) : (e2 = e2 == null ? 0 : T3(e2), n4 = n4 === i3 ? r3 : T3(n4)), At2(t, e2, n4)) : [];
      }
      function tl(t, e2) {
        return Zn(t, e2);
      }
      function el(t, e2, n4) {
        return si2(t, e2, E4(n4, 2));
      }
      function nl(t, e2) {
        var n4 = t == null ? 0 : t.length;
        if (n4) {
          var r3 = Zn(t, e2);
          if (r3 < n4 && Rt2(t[r3], e2)) return r3;
        }
        return -1;
      }
      function rl(t, e2) {
        return Zn(t, e2, true);
      }
      function il(t, e2, n4) {
        return si2(t, e2, E4(n4, 2), true);
      }
      function sl(t, e2) {
        var n4 = t == null ? 0 : t.length;
        if (n4) {
          var r3 = Zn(t, e2, true) - 1;
          if (Rt2(t[r3], e2)) return r3;
        }
        return -1;
      }
      function ul(t) {
        return t && t.length ? au(t) : [];
      }
      function al(t, e2) {
        return t && t.length ? au(t, E4(e2, 2)) : [];
      }
      function ol(t) {
        var e2 = t == null ? 0 : t.length;
        return e2 ? At2(t, 1, e2) : [];
      }
      function cl(t, e2, n4) {
        return t && t.length ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), At2(t, 0, e2 < 0 ? 0 : e2)) : [];
      }
      function fl(t, e2, n4) {
        var r3 = t == null ? 0 : t.length;
        return r3 ? (e2 = n4 || e2 === i3 ? 1 : T3(e2), e2 = r3 - e2, At2(t, e2 < 0 ? 0 : e2, r3)) : [];
      }
      function hl(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3), false, true) : [];
      }
      function ll(t, e2) {
        return t && t.length ? Xn(t, E4(e2, 3)) : [];
      }
      var pl = H(function(t) {
        return ae3(tt3(t, 1, Z2, true));
      }), dl = H(function(t) {
        var e2 = It2(t);
        return Z2(e2) && (e2 = i3), ae3(tt3(t, 1, Z2, true), E4(e2, 2));
      }), gl = H(function(t) {
        var e2 = It2(t);
        return e2 = typeof e2 == "function" ? e2 : i3, ae3(tt3(t, 1, Z2, true), i3, e2);
      });
      function vl(t) {
        return t && t.length ? ae3(t) : [];
      }
      function _l(t, e2) {
        return t && t.length ? ae3(t, E4(e2, 2)) : [];
      }
      function ml(t, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, t && t.length ? ae3(t, i3, e2) : [];
      }
      function Ii(t) {
        if (!(t && t.length)) return [];
        var e2 = 0;
        return t = ne2(t, function(n4) {
          if (Z2(n4)) return e2 = V(n4.length, e2), true;
        }), Wr3(e2, function(n4) {
          return z4(t, Ur2(n4));
        });
      }
      function Yu(t, e2) {
        if (!(t && t.length)) return [];
        var n4 = Ii(t);
        return e2 == null ? n4 : z4(n4, function(r3) {
          return ft2(e2, i3, r3);
        });
      }
      var wl = H(function(t, e2) {
        return Z2(t) ? on3(t, e2) : [];
      }), Pl = H(function(t) {
        return ai2(ne2(t, Z2));
      }), Cl = H(function(t) {
        var e2 = It2(t);
        return Z2(e2) && (e2 = i3), ai2(ne2(t, Z2), E4(e2, 2));
      }), Al = H(function(t) {
        var e2 = It2(t);
        return e2 = typeof e2 == "function" ? e2 : i3, ai2(ne2(t, Z2), i3, e2);
      }), Il = H(Ii);
      function xl(t, e2) {
        return hu(t || [], e2 || [], an2);
      }
      function El(t, e2) {
        return hu(t || [], e2 || [], hn2);
      }
      var yl = H(function(t) {
        var e2 = t.length, n4 = e2 > 1 ? t[e2 - 1] : i3;
        return n4 = typeof n4 == "function" ? (t.pop(), n4) : i3, Yu(t, n4);
      });
      function Zu2(t) {
        var e2 = a4(t);
        return e2.__chain__ = true, e2;
      }
      function Sl(t, e2) {
        return e2(t), t;
      }
      function ir2(t, e2) {
        return e2(t);
      }
      var Ol = Xt2(function(t) {
        var e2 = t.length, n4 = e2 ? t[0] : 0, r3 = this.__wrapped__, u3 = function(o5) {
          return Zr2(o5, t);
        };
        return e2 > 1 || this.__actions__.length || !(r3 instanceof N2) || !Qt2(n4) ? this.thru(u3) : (r3 = r3.slice(n4, +n4 + (e2 ? 1 : 0)), r3.__actions__.push({ func: ir2, args: [u3], thisArg: i3 }), new Pt2(r3, this.__chain__).thru(function(o5) {
          return e2 && !o5.length && o5.push(i3), o5;
        }));
      });
      function Rl() {
        return Zu2(this);
      }
      function bl() {
        return new Pt2(this.value(), this.__chain__);
      }
      function Tl() {
        this.__values__ === i3 && (this.__values__ = oa(this.value()));
        var t = this.__index__ >= this.__values__.length, e2 = t ? i3 : this.__values__[this.__index__++];
        return { done: t, value: e2 };
      }
      function Ll() {
        return this;
      }
      function Hl(t) {
        for (var e2, n4 = this; n4 instanceof Gn; ) {
          var r3 = Mu2(n4);
          r3.__index__ = 0, r3.__values__ = i3, e2 ? u3.__wrapped__ = r3 : e2 = r3;
          var u3 = r3;
          n4 = n4.__wrapped__;
        }
        return u3.__wrapped__ = t, e2;
      }
      function Dl() {
        var t = this.__wrapped__;
        if (t instanceof N2) {
          var e2 = t;
          return this.__actions__.length && (e2 = new N2(this)), e2 = e2.reverse(), e2.__actions__.push({ func: ir2, args: [Ai], thisArg: i3 }), new Pt2(e2, this.__chain__);
        }
        return this.thru(Ai);
      }
      function Nl() {
        return fu(this.__wrapped__, this.__actions__);
      }
      var $l = Qn(function(t, e2, n4) {
        W.call(t, n4) ? ++t[n4] : Yt3(t, n4, 1);
      });
      function Ul(t, e2, n4) {
        var r3 = b3(t) ? Is4 : Sf;
        return n4 && it3(t, e2, n4) && (e2 = i3), r3(t, E4(e2, 3));
      }
      function ql(t, e2) {
        var n4 = b3(t) ? ne2 : Ys2;
        return n4(t, E4(e2, 3));
      }
      var Fl = Cu2(Bu2), Wl = Cu2(Gu);
      function Ml(t, e2) {
        return tt3(sr2(t, e2), 1);
      }
      function Bl(t, e2) {
        return tt3(sr2(t, e2), le2);
      }
      function Gl(t, e2, n4) {
        return n4 = n4 === i3 ? 1 : T3(n4), tt3(sr2(t, e2), n4);
      }
      function Xu2(t, e2) {
        var n4 = b3(t) ? mt2 : ue2;
        return n4(t, E4(e2, 3));
      }
      function Qu(t, e2) {
        var n4 = b3(t) ? ac : Js2;
        return n4(t, E4(e2, 3));
      }
      var zl = Qn(function(t, e2, n4) {
        W.call(t, n4) ? t[n4].push(e2) : Yt3(t, n4, [e2]);
      });
      function Kl(t, e2, n4, r3) {
        t = at3(t) ? t : Ge(t), n4 = n4 && !r3 ? T3(n4) : 0;
        var u3 = t.length;
        return n4 < 0 && (n4 = V(u3 + n4, 0)), fr2(t) ? n4 <= u3 && t.indexOf(e2, n4) > -1 : !!u3 && Te2(t, e2, n4) > -1;
      }
      var Jl = H(function(t, e2, n4) {
        var r3 = -1, u3 = typeof e2 == "function", o5 = at3(t) ? d3(t.length) : [];
        return ue2(t, function(c5) {
          o5[++r3] = u3 ? ft2(e2, c5, n4) : cn2(c5, e2, n4);
        }), o5;
      }), Yl = Qn(function(t, e2, n4) {
        Yt3(t, n4, e2);
      });
      function sr2(t, e2) {
        var n4 = b3(t) ? z4 : js2;
        return n4(t, E4(e2, 3));
      }
      function Zl(t, e2, n4, r3) {
        return t == null ? [] : (b3(e2) || (e2 = e2 == null ? [] : [e2]), n4 = r3 ? i3 : n4, b3(n4) || (n4 = n4 == null ? [] : [n4]), ru(t, e2, n4));
      }
      var Xl = Qn(function(t, e2, n4) {
        t[n4 ? 0 : 1].push(e2);
      }, function() {
        return [[], []];
      });
      function Ql(t, e2, n4) {
        var r3 = b3(t) ? Nr3 : Ss4, u3 = arguments.length < 3;
        return r3(t, E4(e2, 4), n4, u3, ue2);
      }
      function Vl(t, e2, n4) {
        var r3 = b3(t) ? oc : Ss4, u3 = arguments.length < 3;
        return r3(t, E4(e2, 4), n4, u3, Js2);
      }
      function kl(t, e2) {
        var n4 = b3(t) ? ne2 : Ys2;
        return n4(t, or2(E4(e2, 3)));
      }
      function jl(t) {
        var e2 = b3(t) ? Bs2 : Kf;
        return e2(t);
      }
      function tp(t, e2, n4) {
        (n4 ? it3(t, e2, n4) : e2 === i3) ? e2 = 1 : e2 = T3(e2);
        var r3 = b3(t) ? Af : Jf;
        return r3(t, e2);
      }
      function ep(t) {
        var e2 = b3(t) ? If : Zf;
        return e2(t);
      }
      function np(t) {
        if (t == null) return 0;
        if (at3(t)) return fr2(t) ? He(t) : t.length;
        var e2 = nt3(t);
        return e2 == Et2 || e2 == yt3 ? t.size : ti2(t).length;
      }
      function rp(t, e2, n4) {
        var r3 = b3(t) ? $r2 : Xf;
        return n4 && it3(t, e2, n4) && (e2 = i3), r3(t, E4(e2, 3));
      }
      var ip = H(function(t, e2) {
        if (t == null) return [];
        var n4 = e2.length;
        return n4 > 1 && it3(t, e2[0], e2[1]) ? e2 = [] : n4 > 2 && it3(e2[0], e2[1], e2[2]) && (e2 = [e2[0]]), ru(t, tt3(e2, 1), []);
      }), ur2 = Uc || function() {
        return j4.Date.now();
      };
      function sp(t, e2) {
        if (typeof e2 != "function") throw new wt2(y6);
        return t = T3(t), function() {
          if (--t < 1) return e2.apply(this, arguments);
        };
      }
      function Vu(t, e2, n4) {
        return e2 = n4 ? i3 : e2, e2 = t && e2 == null ? t.length : e2, Zt2(t, Gt2, i3, i3, i3, i3, e2);
      }
      function ku2(t, e2) {
        var n4;
        if (typeof e2 != "function") throw new wt2(y6);
        return t = T3(t), function() {
          return --t > 0 && (n4 = e2.apply(this, arguments)), t <= 1 && (e2 = i3), n4;
        };
      }
      var xi = H(function(t, e2, n4) {
        var r3 = vt2;
        if (n4.length) {
          var u3 = ie(n4, Me(xi));
          r3 |= $t2;
        }
        return Zt2(t, r3, e2, n4, u3);
      }), ju2 = H(function(t, e2, n4) {
        var r3 = vt2 | he2;
        if (n4.length) {
          var u3 = ie(n4, Me(ju2));
          r3 |= $t2;
        }
        return Zt2(e2, r3, t, n4, u3);
      });
      function ta(t, e2, n4) {
        e2 = n4 ? i3 : e2;
        var r3 = Zt2(t, Nt2, i3, i3, i3, i3, i3, e2);
        return r3.placeholder = ta.placeholder, r3;
      }
      function ea(t, e2, n4) {
        e2 = n4 ? i3 : e2;
        var r3 = Zt2(t, ye2, i3, i3, i3, i3, i3, e2);
        return r3.placeholder = ea.placeholder, r3;
      }
      function na(t, e2, n4) {
        var r3, u3, o5, c5, f3, l4, v4 = 0, _3 = false, m2 = false, C2 = true;
        if (typeof t != "function") throw new wt2(y6);
        e2 = xt2(e2) || 0, K3(n4) && (_3 = !!n4.leading, m2 = "maxWait" in n4, o5 = m2 ? V(xt2(n4.maxWait) || 0, e2) : o5, C2 = "trailing" in n4 ? !!n4.trailing : C2);
        function x4(X) {
          var bt2 = r3, jt2 = u3;
          return r3 = u3 = i3, v4 = X, c5 = t.apply(jt2, bt2), c5;
        }
        function S3(X) {
          return v4 = X, f3 = dn2(D3, e2), _3 ? x4(X) : c5;
        }
        function L2(X) {
          var bt2 = X - l4, jt2 = X - v4, Ca = e2 - bt2;
          return m2 ? et3(Ca, o5 - jt2) : Ca;
        }
        function O4(X) {
          var bt2 = X - l4, jt2 = X - v4;
          return l4 === i3 || bt2 >= e2 || bt2 < 0 || m2 && jt2 >= o5;
        }
        function D3() {
          var X = ur2();
          if (O4(X)) return $2(X);
          f3 = dn2(D3, L2(X));
        }
        function $2(X) {
          return f3 = i3, C2 && r3 ? x4(X) : (r3 = u3 = i3, c5);
        }
        function dt3() {
          f3 !== i3 && lu(f3), v4 = 0, r3 = l4 = u3 = f3 = i3;
        }
        function st3() {
          return f3 === i3 ? c5 : $2(ur2());
        }
        function gt3() {
          var X = ur2(), bt2 = O4(X);
          if (r3 = arguments, u3 = this, l4 = X, bt2) {
            if (f3 === i3) return S3(l4);
            if (m2) return lu(f3), f3 = dn2(D3, e2), x4(l4);
          }
          return f3 === i3 && (f3 = dn2(D3, e2)), c5;
        }
        return gt3.cancel = dt3, gt3.flush = st3, gt3;
      }
      var up = H(function(t, e2) {
        return Ks2(t, 1, e2);
      }), ap = H(function(t, e2, n4) {
        return Ks2(t, xt2(e2) || 0, n4);
      });
      function op(t) {
        return Zt2(t, gr3);
      }
      function ar2(t, e2) {
        if (typeof t != "function" || e2 != null && typeof e2 != "function") throw new wt2(y6);
        var n4 = function() {
          var r3 = arguments, u3 = e2 ? e2.apply(this, r3) : r3[0], o5 = n4.cache;
          if (o5.has(u3)) return o5.get(u3);
          var c5 = t.apply(this, r3);
          return n4.cache = o5.set(u3, c5) || o5, c5;
        };
        return n4.cache = new (ar2.Cache || Jt2)(), n4;
      }
      ar2.Cache = Jt2;
      function or2(t) {
        if (typeof t != "function") throw new wt2(y6);
        return function() {
          var e2 = arguments;
          switch (e2.length) {
            case 0:
              return !t.call(this);
            case 1:
              return !t.call(this, e2[0]);
            case 2:
              return !t.call(this, e2[0], e2[1]);
            case 3:
              return !t.call(this, e2[0], e2[1], e2[2]);
          }
          return !t.apply(this, e2);
        };
      }
      function cp(t) {
        return ku2(2, t);
      }
      var fp = Qf(function(t, e2) {
        e2 = e2.length == 1 && b3(e2[0]) ? z4(e2[0], ht3(E4())) : z4(tt3(e2, 1), ht3(E4()));
        var n4 = e2.length;
        return H(function(r3) {
          for (var u3 = -1, o5 = et3(r3.length, n4); ++u3 < o5; ) r3[u3] = e2[u3].call(this, r3[u3]);
          return ft2(t, this, r3);
        });
      }), Ei = H(function(t, e2) {
        var n4 = ie(e2, Me(Ei));
        return Zt2(t, $t2, i3, e2, n4);
      }), ra = H(function(t, e2) {
        var n4 = ie(e2, Me(ra));
        return Zt2(t, Se, i3, e2, n4);
      }), hp = Xt2(function(t, e2) {
        return Zt2(t, Je, i3, i3, i3, e2);
      });
      function lp(t, e2) {
        if (typeof t != "function") throw new wt2(y6);
        return e2 = e2 === i3 ? e2 : T3(e2), H(t, e2);
      }
      function pp(t, e2) {
        if (typeof t != "function") throw new wt2(y6);
        return e2 = e2 == null ? 0 : V(T3(e2), 0), H(function(n4) {
          var r3 = n4[e2], u3 = ce2(n4, 0, e2);
          return r3 && re(u3, r3), ft2(t, this, u3);
        });
      }
      function dp(t, e2, n4) {
        var r3 = true, u3 = true;
        if (typeof t != "function") throw new wt2(y6);
        return K3(n4) && (r3 = "leading" in n4 ? !!n4.leading : r3, u3 = "trailing" in n4 ? !!n4.trailing : u3), na(t, e2, { leading: r3, maxWait: e2, trailing: u3 });
      }
      function gp(t) {
        return Vu(t, 1);
      }
      function vp(t, e2) {
        return Ei(ci2(e2), t);
      }
      function _p() {
        if (!arguments.length) return [];
        var t = arguments[0];
        return b3(t) ? t : [t];
      }
      function mp(t) {
        return Ct2(t, xe3);
      }
      function wp(t, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, Ct2(t, xe3, e2);
      }
      function Pp(t) {
        return Ct2(t, Dt2 | xe3);
      }
      function Cp(t, e2) {
        return e2 = typeof e2 == "function" ? e2 : i3, Ct2(t, Dt2 | xe3, e2);
      }
      function Ap(t, e2) {
        return e2 == null || zs2(t, e2, k3(e2));
      }
      function Rt2(t, e2) {
        return t === e2 || t !== t && e2 !== e2;
      }
      var Ip = tr2(Vr3), xp = tr2(function(t, e2) {
        return t >= e2;
      }), Ce3 = Qs2(/* @__PURE__ */ function() {
        return arguments;
      }()) ? Qs2 : function(t) {
        return Y2(t) && W.call(t, "callee") && !$s2.call(t, "callee");
      }, b3 = d3.isArray, Ep = _s3 ? ht3(_s3) : Hf;
      function at3(t) {
        return t != null && cr2(t.length) && !Vt2(t);
      }
      function Z2(t) {
        return Y2(t) && at3(t);
      }
      function yp(t) {
        return t === true || t === false || Y2(t) && rt3(t) == Ye;
      }
      var fe2 = Fc || $i, Sp = ms3 ? ht3(ms3) : Df;
      function Op(t) {
        return Y2(t) && t.nodeType === 1 && !gn2(t);
      }
      function Rp(t) {
        if (t == null) return true;
        if (at3(t) && (b3(t) || typeof t == "string" || typeof t.splice == "function" || fe2(t) || Be(t) || Ce3(t))) return !t.length;
        var e2 = nt3(t);
        if (e2 == Et2 || e2 == yt3) return !t.size;
        if (pn2(t)) return !ti2(t).length;
        for (var n4 in t) if (W.call(t, n4)) return false;
        return true;
      }
      function bp(t, e2) {
        return fn2(t, e2);
      }
      function Tp(t, e2, n4) {
        n4 = typeof n4 == "function" ? n4 : i3;
        var r3 = n4 ? n4(t, e2) : i3;
        return r3 === i3 ? fn2(t, e2, i3, n4) : !!r3;
      }
      function yi2(t) {
        if (!Y2(t)) return false;
        var e2 = rt3(t);
        return e2 == Cn2 || e2 == ka || typeof t.message == "string" && typeof t.name == "string" && !gn2(t);
      }
      function Lp(t) {
        return typeof t == "number" && qs3(t);
      }
      function Vt2(t) {
        if (!K3(t)) return false;
        var e2 = rt3(t);
        return e2 == An2 || e2 == Ki || e2 == Va || e2 == to;
      }
      function ia(t) {
        return typeof t == "number" && t == T3(t);
      }
      function cr2(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= ee2;
      }
      function K3(t) {
        var e2 = typeof t;
        return t != null && (e2 == "object" || e2 == "function");
      }
      function Y2(t) {
        return t != null && typeof t == "object";
      }
      var sa = ws3 ? ht3(ws3) : $f;
      function Hp(t, e2) {
        return t === e2 || jr2(t, e2, vi(e2));
      }
      function Dp(t, e2, n4) {
        return n4 = typeof n4 == "function" ? n4 : i3, jr2(t, e2, vi(e2), n4);
      }
      function Np(t) {
        return ua(t) && t != +t;
      }
      function $p(t) {
        if (wh2(t)) throw new R2(I3);
        return Vs2(t);
      }
      function Up(t) {
        return t === null;
      }
      function qp(t) {
        return t == null;
      }
      function ua(t) {
        return typeof t == "number" || Y2(t) && rt3(t) == Xe2;
      }
      function gn2(t) {
        if (!Y2(t) || rt3(t) != zt2) return false;
        var e2 = $n(t);
        if (e2 === null) return true;
        var n4 = W.call(e2, "constructor") && e2.constructor;
        return typeof n4 == "function" && n4 instanceof n4 && Ln.call(n4) == Hc;
      }
      var Si = Ps2 ? ht3(Ps2) : Uf;
      function Fp(t) {
        return ia(t) && t >= -ee2 && t <= ee2;
      }
      var aa = Cs2 ? ht3(Cs2) : qf;
      function fr2(t) {
        return typeof t == "string" || !b3(t) && Y2(t) && rt3(t) == Ve;
      }
      function pt3(t) {
        return typeof t == "symbol" || Y2(t) && rt3(t) == In2;
      }
      var Be = As3 ? ht3(As3) : Ff;
      function Wp(t) {
        return t === i3;
      }
      function Mp(t) {
        return Y2(t) && nt3(t) == ke;
      }
      function Bp(t) {
        return Y2(t) && rt3(t) == no;
      }
      var Gp = tr2(ei2), zp = tr2(function(t, e2) {
        return t <= e2;
      });
      function oa(t) {
        if (!t) return [];
        if (at3(t)) return fr2(t) ? St2(t) : ut3(t);
        if (en2 && t[en2]) return Cc(t[en2]());
        var e2 = nt3(t), n4 = e2 == Et2 ? Br2 : e2 == yt3 ? Rn2 : Ge;
        return n4(t);
      }
      function kt2(t) {
        if (!t) return t === 0 ? t : 0;
        if (t = xt2(t), t === le2 || t === -le2) {
          var e2 = t < 0 ? -1 : 1;
          return e2 * Ya;
        }
        return t === t ? t : 0;
      }
      function T3(t) {
        var e2 = kt2(t), n4 = e2 % 1;
        return e2 === e2 ? n4 ? e2 - n4 : e2 : 0;
      }
      function ca(t) {
        return t ? _e3(T3(t), 0, Ut2) : 0;
      }
      function xt2(t) {
        if (typeof t == "number") return t;
        if (pt3(t)) return wn2;
        if (K3(t)) {
          var e2 = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = K3(e2) ? e2 + "" : e2;
        }
        if (typeof t != "string") return t === 0 ? t : +t;
        t = Os2(t);
        var n4 = xo2.test(t);
        return n4 || yo.test(t) ? ic(t.slice(2), n4 ? 2 : 8) : Io.test(t) ? wn2 : +t;
      }
      function fa(t) {
        return Ft2(t, ot3(t));
      }
      function Kp(t) {
        return t ? _e3(T3(t), -ee2, ee2) : t === 0 ? t : 0;
      }
      function q2(t) {
        return t == null ? "" : lt3(t);
      }
      var Jp = Fe(function(t, e2) {
        if (pn2(e2) || at3(e2)) {
          Ft2(e2, k3(e2), t);
          return;
        }
        for (var n4 in e2) W.call(e2, n4) && an2(t, n4, e2[n4]);
      }), ha = Fe(function(t, e2) {
        Ft2(e2, ot3(e2), t);
      }), hr2 = Fe(function(t, e2, n4, r3) {
        Ft2(e2, ot3(e2), t, r3);
      }), Yp = Fe(function(t, e2, n4, r3) {
        Ft2(e2, k3(e2), t, r3);
      }), Zp = Xt2(Zr2);
      function Xp(t, e2) {
        var n4 = qe(t);
        return e2 == null ? n4 : Gs2(n4, e2);
      }
      var Qp = H(function(t, e2) {
        t = M3(t);
        var n4 = -1, r3 = e2.length, u3 = r3 > 2 ? e2[2] : i3;
        for (u3 && it3(e2[0], e2[1], u3) && (r3 = 1); ++n4 < r3; ) for (var o5 = e2[n4], c5 = ot3(o5), f3 = -1, l4 = c5.length; ++f3 < l4; ) {
          var v4 = c5[f3], _3 = t[v4];
          (_3 === i3 || Rt2(_3, Ne[v4]) && !W.call(t, v4)) && (t[v4] = o5[v4]);
        }
        return t;
      }), Vp = H(function(t) {
        return t.push(i3, Ou2), ft2(la, i3, t);
      });
      function kp(t, e2) {
        return xs3(t, E4(e2, 3), qt2);
      }
      function jp(t, e2) {
        return xs3(t, E4(e2, 3), Qr2);
      }
      function td(t, e2) {
        return t == null ? t : Xr3(t, E4(e2, 3), ot3);
      }
      function ed(t, e2) {
        return t == null ? t : Zs2(t, E4(e2, 3), ot3);
      }
      function nd(t, e2) {
        return t && qt2(t, E4(e2, 3));
      }
      function rd(t, e2) {
        return t && Qr2(t, E4(e2, 3));
      }
      function id(t) {
        return t == null ? [] : Jn(t, k3(t));
      }
      function sd(t) {
        return t == null ? [] : Jn(t, ot3(t));
      }
      function Oi(t, e2, n4) {
        var r3 = t == null ? i3 : me3(t, e2);
        return r3 === i3 ? n4 : r3;
      }
      function ud(t, e2) {
        return t != null && Tu2(t, e2, Rf);
      }
      function Ri(t, e2) {
        return t != null && Tu2(t, e2, bf);
      }
      var ad = Iu2(function(t, e2, n4) {
        e2 != null && typeof e2.toString != "function" && (e2 = Hn.call(e2)), t[e2] = n4;
      }, Ti(ct3)), od = Iu2(function(t, e2, n4) {
        e2 != null && typeof e2.toString != "function" && (e2 = Hn.call(e2)), W.call(t, e2) ? t[e2].push(n4) : t[e2] = [n4];
      }, E4), cd = H(cn2);
      function k3(t) {
        return at3(t) ? Ms3(t) : ti2(t);
      }
      function ot3(t) {
        return at3(t) ? Ms3(t, true) : Wf2(t);
      }
      function fd(t, e2) {
        var n4 = {};
        return e2 = E4(e2, 3), qt2(t, function(r3, u3, o5) {
          Yt3(n4, e2(r3, u3, o5), r3);
        }), n4;
      }
      function hd(t, e2) {
        var n4 = {};
        return e2 = E4(e2, 3), qt2(t, function(r3, u3, o5) {
          Yt3(n4, u3, e2(r3, u3, o5));
        }), n4;
      }
      var ld = Fe(function(t, e2, n4) {
        Yn(t, e2, n4);
      }), la = Fe(function(t, e2, n4, r3) {
        Yn(t, e2, n4, r3);
      }), pd = Xt2(function(t, e2) {
        var n4 = {};
        if (t == null) return n4;
        var r3 = false;
        e2 = z4(e2, function(o5) {
          return o5 = oe3(o5, t), r3 || (r3 = o5.length > 1), o5;
        }), Ft2(t, di2(t), n4), r3 && (n4 = Ct2(n4, Dt2 | Bt2 | xe3, ah));
        for (var u3 = e2.length; u3--; ) ui2(n4, e2[u3]);
        return n4;
      });
      function dd(t, e2) {
        return pa(t, or2(E4(e2)));
      }
      var gd = Xt2(function(t, e2) {
        return t == null ? {} : Bf(t, e2);
      });
      function pa(t, e2) {
        if (t == null) return {};
        var n4 = z4(di2(t), function(r3) {
          return [r3];
        });
        return e2 = E4(e2), iu(t, n4, function(r3, u3) {
          return e2(r3, u3[0]);
        });
      }
      function vd(t, e2, n4) {
        e2 = oe3(e2, t);
        var r3 = -1, u3 = e2.length;
        for (u3 || (u3 = 1, t = i3); ++r3 < u3; ) {
          var o5 = t == null ? i3 : t[Wt2(e2[r3])];
          o5 === i3 && (r3 = u3, o5 = n4), t = Vt2(o5) ? o5.call(t) : o5;
        }
        return t;
      }
      function _d(t, e2, n4) {
        return t == null ? t : hn2(t, e2, n4);
      }
      function md(t, e2, n4, r3) {
        return r3 = typeof r3 == "function" ? r3 : i3, t == null ? t : hn2(t, e2, n4, r3);
      }
      var da = yu(k3), ga = yu(ot3);
      function wd(t, e2, n4) {
        var r3 = b3(t), u3 = r3 || fe2(t) || Be(t);
        if (e2 = E4(e2, 4), n4 == null) {
          var o5 = t && t.constructor;
          u3 ? n4 = r3 ? new o5() : [] : K3(t) ? n4 = Vt2(o5) ? qe($n(t)) : {} : n4 = {};
        }
        return (u3 ? mt2 : qt2)(t, function(c5, f3, l4) {
          return e2(n4, c5, f3, l4);
        }), n4;
      }
      function Pd(t, e2) {
        return t == null ? true : ui2(t, e2);
      }
      function Cd(t, e2, n4) {
        return t == null ? t : cu(t, e2, ci2(n4));
      }
      function Ad(t, e2, n4, r3) {
        return r3 = typeof r3 == "function" ? r3 : i3, t == null ? t : cu(t, e2, ci2(n4), r3);
      }
      function Ge(t) {
        return t == null ? [] : Mr2(t, k3(t));
      }
      function Id(t) {
        return t == null ? [] : Mr2(t, ot3(t));
      }
      function xd(t, e2, n4) {
        return n4 === i3 && (n4 = e2, e2 = i3), n4 !== i3 && (n4 = xt2(n4), n4 = n4 === n4 ? n4 : 0), e2 !== i3 && (e2 = xt2(e2), e2 = e2 === e2 ? e2 : 0), _e3(xt2(t), e2, n4);
      }
      function Ed(t, e2, n4) {
        return e2 = kt2(e2), n4 === i3 ? (n4 = e2, e2 = 0) : n4 = kt2(n4), t = xt2(t), Tf(t, e2, n4);
      }
      function yd(t, e2, n4) {
        if (n4 && typeof n4 != "boolean" && it3(t, e2, n4) && (e2 = n4 = i3), n4 === i3 && (typeof e2 == "boolean" ? (n4 = e2, e2 = i3) : typeof t == "boolean" && (n4 = t, t = i3)), t === i3 && e2 === i3 ? (t = 0, e2 = 1) : (t = kt2(t), e2 === i3 ? (e2 = t, t = 0) : e2 = kt2(e2)), t > e2) {
          var r3 = t;
          t = e2, e2 = r3;
        }
        if (n4 || t % 1 || e2 % 1) {
          var u3 = Fs2();
          return et3(t + u3 * (e2 - t + rc("1e-" + ((u3 + "").length - 1))), e2);
        }
        return ri2(t, e2);
      }
      var Sd = We(function(t, e2, n4) {
        return e2 = e2.toLowerCase(), t + (n4 ? va(e2) : e2);
      });
      function va(t) {
        return bi3(q2(t).toLowerCase());
      }
      function _a(t) {
        return t = q2(t), t && t.replace(Oo2, vc).replace(Yo, "");
      }
      function Od(t, e2, n4) {
        t = q2(t), e2 = lt3(e2);
        var r3 = t.length;
        n4 = n4 === i3 ? r3 : _e3(T3(n4), 0, r3);
        var u3 = n4;
        return n4 -= e2.length, n4 >= 0 && t.slice(n4, u3) == e2;
      }
      function Rd(t) {
        return t = q2(t), t && ao.test(t) ? t.replace(Zi, _c) : t;
      }
      function bd(t) {
        return t = q2(t), t && po.test(t) ? t.replace(Er2, "\\$&") : t;
      }
      var Td = We(function(t, e2, n4) {
        return t + (n4 ? "-" : "") + e2.toLowerCase();
      }), Ld = We(function(t, e2, n4) {
        return t + (n4 ? " " : "") + e2.toLowerCase();
      }), Hd = Pu2("toLowerCase");
      function Dd(t, e2, n4) {
        t = q2(t), e2 = T3(e2);
        var r3 = e2 ? He(t) : 0;
        if (!e2 || r3 >= e2) return t;
        var u3 = (e2 - r3) / 2;
        return jn(Wn(u3), n4) + t + jn(Fn(u3), n4);
      }
      function Nd(t, e2, n4) {
        t = q2(t), e2 = T3(e2);
        var r3 = e2 ? He(t) : 0;
        return e2 && r3 < e2 ? t + jn(e2 - r3, n4) : t;
      }
      function $d(t, e2, n4) {
        t = q2(t), e2 = T3(e2);
        var r3 = e2 ? He(t) : 0;
        return e2 && r3 < e2 ? jn(e2 - r3, n4) + t : t;
      }
      function Ud(t, e2, n4) {
        return n4 || e2 == null ? e2 = 0 : e2 && (e2 = +e2), Gc(q2(t).replace(yr2, ""), e2 || 0);
      }
      function qd(t, e2, n4) {
        return (n4 ? it3(t, e2, n4) : e2 === i3) ? e2 = 1 : e2 = T3(e2), ii2(q2(t), e2);
      }
      function Fd() {
        var t = arguments, e2 = q2(t[0]);
        return t.length < 3 ? e2 : e2.replace(t[1], t[2]);
      }
      var Wd = We(function(t, e2, n4) {
        return t + (n4 ? "_" : "") + e2.toLowerCase();
      });
      function Md(t, e2, n4) {
        return n4 && typeof n4 != "number" && it3(t, e2, n4) && (e2 = n4 = i3), n4 = n4 === i3 ? Ut2 : n4 >>> 0, n4 ? (t = q2(t), t && (typeof e2 == "string" || e2 != null && !Si(e2)) && (e2 = lt3(e2), !e2 && Le2(t)) ? ce2(St2(t), 0, n4) : t.split(e2, n4)) : [];
      }
      var Bd = We(function(t, e2, n4) {
        return t + (n4 ? " " : "") + bi3(e2);
      });
      function Gd(t, e2, n4) {
        return t = q2(t), n4 = n4 == null ? 0 : _e3(T3(n4), 0, t.length), e2 = lt3(e2), t.slice(n4, n4 + e2.length) == e2;
      }
      function zd(t, e2, n4) {
        var r3 = a4.templateSettings;
        n4 && it3(t, e2, n4) && (e2 = i3), t = q2(t), e2 = hr2({}, e2, r3, Su2);
        var u3 = hr2({}, e2.imports, r3.imports, Su2), o5 = k3(u3), c5 = Mr2(u3, o5), f3, l4, v4 = 0, _3 = e2.interpolate || xn2, m2 = "__p += '", C2 = Gr2((e2.escape || xn2).source + "|" + _3.source + "|" + (_3 === Xi ? Ao : xn2).source + "|" + (e2.evaluate || xn2).source + "|$", "g"), x4 = "//# sourceURL=" + (W.call(e2, "sourceURL") ? (e2.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++ko + "]") + `
`;
        t.replace(C2, function(O4, D3, $2, dt3, st3, gt3) {
          return $2 || ($2 = dt3), m2 += t.slice(v4, gt3).replace(Ro, mc), D3 && (f3 = true, m2 += `' +
__e(` + D3 + `) +
'`), st3 && (l4 = true, m2 += `';
` + st3 + `;
__p += '`), $2 && (m2 += `' +
((__t = (` + $2 + `)) == null ? '' : __t) +
'`), v4 = gt3 + O4.length, O4;
        }), m2 += `';
`;
        var S3 = W.call(e2, "variable") && e2.variable;
        if (!S3) m2 = `with (obj) {
` + m2 + `
}
`;
        else if (Po2.test(S3)) throw new R2(J);
        m2 = (l4 ? m2.replace(ro, "") : m2).replace(io, "$1").replace(so2, "$1;"), m2 = "function(" + (S3 || "obj") + `) {
` + (S3 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (f3 ? ", __e = _.escape" : "") + (l4 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m2 + `return __p
}`;
        var L2 = wa(function() {
          return U3(o5, x4 + "return " + m2).apply(i3, c5);
        });
        if (L2.source = m2, yi2(L2)) throw L2;
        return L2;
      }
      function Kd(t) {
        return q2(t).toLowerCase();
      }
      function Jd(t) {
        return q2(t).toUpperCase();
      }
      function Yd(t, e2, n4) {
        if (t = q2(t), t && (n4 || e2 === i3)) return Os2(t);
        if (!t || !(e2 = lt3(e2))) return t;
        var r3 = St2(t), u3 = St2(e2), o5 = Rs3(r3, u3), c5 = bs3(r3, u3) + 1;
        return ce2(r3, o5, c5).join("");
      }
      function Zd(t, e2, n4) {
        if (t = q2(t), t && (n4 || e2 === i3)) return t.slice(0, Ls2(t) + 1);
        if (!t || !(e2 = lt3(e2))) return t;
        var r3 = St2(t), u3 = bs3(r3, St2(e2)) + 1;
        return ce2(r3, 0, u3).join("");
      }
      function Xd(t, e2, n4) {
        if (t = q2(t), t && (n4 || e2 === i3)) return t.replace(yr2, "");
        if (!t || !(e2 = lt3(e2))) return t;
        var r3 = St2(t), u3 = Rs3(r3, St2(e2));
        return ce2(r3, u3).join("");
      }
      function Qd(t, e2) {
        var n4 = Ma, r3 = Ba;
        if (K3(e2)) {
          var u3 = "separator" in e2 ? e2.separator : u3;
          n4 = "length" in e2 ? T3(e2.length) : n4, r3 = "omission" in e2 ? lt3(e2.omission) : r3;
        }
        t = q2(t);
        var o5 = t.length;
        if (Le2(t)) {
          var c5 = St2(t);
          o5 = c5.length;
        }
        if (n4 >= o5) return t;
        var f3 = n4 - He(r3);
        if (f3 < 1) return r3;
        var l4 = c5 ? ce2(c5, 0, f3).join("") : t.slice(0, f3);
        if (u3 === i3) return l4 + r3;
        if (c5 && (f3 += l4.length - f3), Si(u3)) {
          if (t.slice(f3).search(u3)) {
            var v4, _3 = l4;
            for (u3.global || (u3 = Gr2(u3.source, q2(Qi.exec(u3)) + "g")), u3.lastIndex = 0; v4 = u3.exec(_3); ) var m2 = v4.index;
            l4 = l4.slice(0, m2 === i3 ? f3 : m2);
          }
        } else if (t.indexOf(lt3(u3), f3) != f3) {
          var C2 = l4.lastIndexOf(u3);
          C2 > -1 && (l4 = l4.slice(0, C2));
        }
        return l4 + r3;
      }
      function Vd(t) {
        return t = q2(t), t && uo.test(t) ? t.replace(Yi, Ec) : t;
      }
      var kd = We(function(t, e2, n4) {
        return t + (n4 ? " " : "") + e2.toUpperCase();
      }), bi3 = Pu2("toUpperCase");
      function ma(t, e2, n4) {
        return t = q2(t), e2 = n4 ? i3 : e2, e2 === i3 ? Pc(t) ? Oc(t) : hc(t) : t.match(e2) || [];
      }
      var wa = H(function(t, e2) {
        try {
          return ft2(t, i3, e2);
        } catch (n4) {
          return yi2(n4) ? n4 : new R2(n4);
        }
      }), jd = Xt2(function(t, e2) {
        return mt2(e2, function(n4) {
          n4 = Wt2(n4), Yt3(t, n4, xi(t[n4], t));
        }), t;
      });
      function tg(t) {
        var e2 = t == null ? 0 : t.length, n4 = E4();
        return t = e2 ? z4(t, function(r3) {
          if (typeof r3[1] != "function") throw new wt2(y6);
          return [n4(r3[0]), r3[1]];
        }) : [], H(function(r3) {
          for (var u3 = -1; ++u3 < e2; ) {
            var o5 = t[u3];
            if (ft2(o5[0], this, r3)) return ft2(o5[1], this, r3);
          }
        });
      }
      function eg(t) {
        return yf(Ct2(t, Dt2));
      }
      function Ti(t) {
        return function() {
          return t;
        };
      }
      function ng(t, e2) {
        return t == null || t !== t ? e2 : t;
      }
      var rg = Au(), ig = Au(true);
      function ct3(t) {
        return t;
      }
      function Li(t) {
        return ks2(typeof t == "function" ? t : Ct2(t, Dt2));
      }
      function sg(t) {
        return tu(Ct2(t, Dt2));
      }
      function ug(t, e2) {
        return eu(t, Ct2(e2, Dt2));
      }
      var ag = H(function(t, e2) {
        return function(n4) {
          return cn2(n4, t, e2);
        };
      }), og = H(function(t, e2) {
        return function(n4) {
          return cn2(t, n4, e2);
        };
      });
      function Hi(t, e2, n4) {
        var r3 = k3(e2), u3 = Jn(e2, r3);
        n4 == null && !(K3(e2) && (u3.length || !r3.length)) && (n4 = e2, e2 = t, t = this, u3 = Jn(e2, k3(e2)));
        var o5 = !(K3(n4) && "chain" in n4) || !!n4.chain, c5 = Vt2(t);
        return mt2(u3, function(f3) {
          var l4 = e2[f3];
          t[f3] = l4, c5 && (t.prototype[f3] = function() {
            var v4 = this.__chain__;
            if (o5 || v4) {
              var _3 = t(this.__wrapped__), m2 = _3.__actions__ = ut3(this.__actions__);
              return m2.push({ func: l4, args: arguments, thisArg: t }), _3.__chain__ = v4, _3;
            }
            return l4.apply(t, re([this.value()], arguments));
          });
        }), t;
      }
      function cg() {
        return j4._ === this && (j4._ = Dc), this;
      }
      function Di2() {
      }
      function fg(t) {
        return t = T3(t), H(function(e2) {
          return nu(e2, t);
        });
      }
      var hg = hi2(z4), lg = hi2(Is4), pg = hi2($r2);
      function Pa(t) {
        return mi2(t) ? Ur2(Wt2(t)) : Gf(t);
      }
      function dg(t) {
        return function(e2) {
          return t == null ? i3 : me3(t, e2);
        };
      }
      var gg = xu2(), vg = xu2(true);
      function Ni() {
        return [];
      }
      function $i() {
        return false;
      }
      function _g() {
        return {};
      }
      function mg() {
        return "";
      }
      function wg() {
        return true;
      }
      function Pg(t, e2) {
        if (t = T3(t), t < 1 || t > ee2) return [];
        var n4 = Ut2, r3 = et3(t, Ut2);
        e2 = E4(e2), t -= Ut2;
        for (var u3 = Wr3(r3, e2); ++n4 < t; ) e2(n4);
        return u3;
      }
      function Cg(t) {
        return b3(t) ? z4(t, Wt2) : pt3(t) ? [t] : ut3(Wu(q2(t)));
      }
      function Ag(t) {
        var e2 = ++Lc;
        return q2(t) + e2;
      }
      var Ig = kn(function(t, e2) {
        return t + e2;
      }, 0), xg = li2("ceil"), Eg = kn(function(t, e2) {
        return t / e2;
      }, 1), yg = li2("floor");
      function Sg(t) {
        return t && t.length ? Kn(t, ct3, Vr3) : i3;
      }
      function Og(t, e2) {
        return t && t.length ? Kn(t, E4(e2, 2), Vr3) : i3;
      }
      function Rg(t) {
        return ys3(t, ct3);
      }
      function bg(t, e2) {
        return ys3(t, E4(e2, 2));
      }
      function Tg(t) {
        return t && t.length ? Kn(t, ct3, ei2) : i3;
      }
      function Lg(t, e2) {
        return t && t.length ? Kn(t, E4(e2, 2), ei2) : i3;
      }
      var Hg = kn(function(t, e2) {
        return t * e2;
      }, 1), Dg = li2("round"), Ng = kn(function(t, e2) {
        return t - e2;
      }, 0);
      function $g(t) {
        return t && t.length ? Fr2(t, ct3) : 0;
      }
      function Ug(t, e2) {
        return t && t.length ? Fr2(t, E4(e2, 2)) : 0;
      }
      return a4.after = sp, a4.ary = Vu, a4.assign = Jp, a4.assignIn = ha, a4.assignInWith = hr2, a4.assignWith = Yp, a4.at = Zp, a4.before = ku2, a4.bind = xi, a4.bindAll = jd, a4.bindKey = ju2, a4.castArray = _p, a4.chain = Zu2, a4.chunk = yh2, a4.compact = Sh2, a4.concat = Oh, a4.cond = tg, a4.conforms = eg, a4.constant = Ti, a4.countBy = $l, a4.create = Xp, a4.curry = ta, a4.curryRight = ea, a4.debounce = na, a4.defaults = Qp, a4.defaultsDeep = Vp, a4.defer = up, a4.delay = ap, a4.difference = Rh2, a4.differenceBy = bh2, a4.differenceWith = Th, a4.drop = Lh, a4.dropRight = Hh, a4.dropRightWhile = Dh, a4.dropWhile = Nh, a4.fill = $h, a4.filter = ql, a4.flatMap = Ml, a4.flatMapDeep = Bl, a4.flatMapDepth = Gl, a4.flatten = zu2, a4.flattenDeep = Uh, a4.flattenDepth = qh, a4.flip = op, a4.flow = rg, a4.flowRight = ig, a4.fromPairs = Fh, a4.functions = id, a4.functionsIn = sd, a4.groupBy = zl, a4.initial = Mh2, a4.intersection = Bh2, a4.intersectionBy = Gh, a4.intersectionWith = zh, a4.invert = ad, a4.invertBy = od, a4.invokeMap = Jl, a4.iteratee = Li, a4.keyBy = Yl, a4.keys = k3, a4.keysIn = ot3, a4.map = sr2, a4.mapKeys = fd, a4.mapValues = hd, a4.matches = sg, a4.matchesProperty = ug, a4.memoize = ar2, a4.merge = ld, a4.mergeWith = la, a4.method = ag, a4.methodOf = og, a4.mixin = Hi, a4.negate = or2, a4.nthArg = fg, a4.omit = pd, a4.omitBy = dd, a4.once = cp, a4.orderBy = Zl, a4.over = hg, a4.overArgs = fp, a4.overEvery = lg, a4.overSome = pg, a4.partial = Ei, a4.partialRight = ra, a4.partition = Xl, a4.pick = gd, a4.pickBy = pa, a4.property = Pa, a4.propertyOf = dg, a4.pull = Zh, a4.pullAll = Ju, a4.pullAllBy = Xh, a4.pullAllWith = Qh, a4.pullAt = Vh, a4.range = gg, a4.rangeRight = vg, a4.rearg = hp, a4.reject = kl, a4.remove = kh, a4.rest = lp, a4.reverse = Ai, a4.sampleSize = tp, a4.set = _d, a4.setWith = md, a4.shuffle = ep, a4.slice = jh, a4.sortBy = ip, a4.sortedUniq = ul, a4.sortedUniqBy = al, a4.split = Md, a4.spread = pp, a4.tail = ol, a4.take = cl, a4.takeRight = fl, a4.takeRightWhile = hl, a4.takeWhile = ll, a4.tap = Sl, a4.throttle = dp, a4.thru = ir2, a4.toArray = oa, a4.toPairs = da, a4.toPairsIn = ga, a4.toPath = Cg, a4.toPlainObject = fa, a4.transform = wd, a4.unary = gp, a4.union = pl, a4.unionBy = dl, a4.unionWith = gl, a4.uniq = vl, a4.uniqBy = _l, a4.uniqWith = ml, a4.unset = Pd, a4.unzip = Ii, a4.unzipWith = Yu, a4.update = Cd, a4.updateWith = Ad, a4.values = Ge, a4.valuesIn = Id, a4.without = wl, a4.words = ma, a4.wrap = vp, a4.xor = Pl, a4.xorBy = Cl, a4.xorWith = Al, a4.zip = Il, a4.zipObject = xl, a4.zipObjectDeep = El, a4.zipWith = yl, a4.entries = da, a4.entriesIn = ga, a4.extend = ha, a4.extendWith = hr2, Hi(a4, a4), a4.add = Ig, a4.attempt = wa, a4.camelCase = Sd, a4.capitalize = va, a4.ceil = xg, a4.clamp = xd, a4.clone = mp, a4.cloneDeep = Pp, a4.cloneDeepWith = Cp, a4.cloneWith = wp, a4.conformsTo = Ap, a4.deburr = _a, a4.defaultTo = ng, a4.divide = Eg, a4.endsWith = Od, a4.eq = Rt2, a4.escape = Rd, a4.escapeRegExp = bd, a4.every = Ul, a4.find = Fl, a4.findIndex = Bu2, a4.findKey = kp, a4.findLast = Wl, a4.findLastIndex = Gu, a4.findLastKey = jp, a4.floor = yg, a4.forEach = Xu2, a4.forEachRight = Qu, a4.forIn = td, a4.forInRight = ed, a4.forOwn = nd, a4.forOwnRight = rd, a4.get = Oi, a4.gt = Ip, a4.gte = xp, a4.has = ud, a4.hasIn = Ri, a4.head = Ku, a4.identity = ct3, a4.includes = Kl, a4.indexOf = Wh, a4.inRange = Ed, a4.invoke = cd, a4.isArguments = Ce3, a4.isArray = b3, a4.isArrayBuffer = Ep, a4.isArrayLike = at3, a4.isArrayLikeObject = Z2, a4.isBoolean = yp, a4.isBuffer = fe2, a4.isDate = Sp, a4.isElement = Op, a4.isEmpty = Rp, a4.isEqual = bp, a4.isEqualWith = Tp, a4.isError = yi2, a4.isFinite = Lp, a4.isFunction = Vt2, a4.isInteger = ia, a4.isLength = cr2, a4.isMap = sa, a4.isMatch = Hp, a4.isMatchWith = Dp, a4.isNaN = Np, a4.isNative = $p, a4.isNil = qp, a4.isNull = Up, a4.isNumber = ua, a4.isObject = K3, a4.isObjectLike = Y2, a4.isPlainObject = gn2, a4.isRegExp = Si, a4.isSafeInteger = Fp, a4.isSet = aa, a4.isString = fr2, a4.isSymbol = pt3, a4.isTypedArray = Be, a4.isUndefined = Wp, a4.isWeakMap = Mp, a4.isWeakSet = Bp, a4.join = Kh, a4.kebabCase = Td, a4.last = It2, a4.lastIndexOf = Jh, a4.lowerCase = Ld, a4.lowerFirst = Hd, a4.lt = Gp, a4.lte = zp, a4.max = Sg, a4.maxBy = Og, a4.mean = Rg, a4.meanBy = bg, a4.min = Tg, a4.minBy = Lg, a4.stubArray = Ni, a4.stubFalse = $i, a4.stubObject = _g, a4.stubString = mg, a4.stubTrue = wg, a4.multiply = Hg, a4.nth = Yh, a4.noConflict = cg, a4.noop = Di2, a4.now = ur2, a4.pad = Dd, a4.padEnd = Nd, a4.padStart = $d, a4.parseInt = Ud, a4.random = yd, a4.reduce = Ql, a4.reduceRight = Vl, a4.repeat = qd, a4.replace = Fd, a4.result = vd, a4.round = Dg, a4.runInContext = h4, a4.sample = jl, a4.size = np, a4.snakeCase = Wd, a4.some = rp, a4.sortedIndex = tl, a4.sortedIndexBy = el, a4.sortedIndexOf = nl, a4.sortedLastIndex = rl, a4.sortedLastIndexBy = il, a4.sortedLastIndexOf = sl, a4.startCase = Bd, a4.startsWith = Gd, a4.subtract = Ng, a4.sum = $g, a4.sumBy = Ug, a4.template = zd, a4.times = Pg, a4.toFinite = kt2, a4.toInteger = T3, a4.toLength = ca, a4.toLower = Kd, a4.toNumber = xt2, a4.toSafeInteger = Kp, a4.toString = q2, a4.toUpper = Jd, a4.trim = Yd, a4.trimEnd = Zd, a4.trimStart = Xd, a4.truncate = Qd, a4.unescape = Vd, a4.uniqueId = Ag, a4.upperCase = kd, a4.upperFirst = bi3, a4.each = Xu2, a4.eachRight = Qu, a4.first = Ku, Hi(a4, function() {
        var t = {};
        return qt2(a4, function(e2, n4) {
          W.call(a4.prototype, n4) || (t[n4] = e2);
        }), t;
      }(), { chain: false }), a4.VERSION = p3, mt2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(t) {
        a4[t].placeholder = a4;
      }), mt2(["drop", "take"], function(t, e2) {
        N2.prototype[t] = function(n4) {
          n4 = n4 === i3 ? 1 : V(T3(n4), 0);
          var r3 = this.__filtered__ && !e2 ? new N2(this) : this.clone();
          return r3.__filtered__ ? r3.__takeCount__ = et3(n4, r3.__takeCount__) : r3.__views__.push({ size: et3(n4, Ut2), type: t + (r3.__dir__ < 0 ? "Right" : "") }), r3;
        }, N2.prototype[t + "Right"] = function(n4) {
          return this.reverse()[t](n4).reverse();
        };
      }), mt2(["filter", "map", "takeWhile"], function(t, e2) {
        var n4 = e2 + 1, r3 = n4 == zi || n4 == Ja;
        N2.prototype[t] = function(u3) {
          var o5 = this.clone();
          return o5.__iteratees__.push({ iteratee: E4(u3, 3), type: n4 }), o5.__filtered__ = o5.__filtered__ || r3, o5;
        };
      }), mt2(["head", "last"], function(t, e2) {
        var n4 = "take" + (e2 ? "Right" : "");
        N2.prototype[t] = function() {
          return this[n4](1).value()[0];
        };
      }), mt2(["initial", "tail"], function(t, e2) {
        var n4 = "drop" + (e2 ? "" : "Right");
        N2.prototype[t] = function() {
          return this.__filtered__ ? new N2(this) : this[n4](1);
        };
      }), N2.prototype.compact = function() {
        return this.filter(ct3);
      }, N2.prototype.find = function(t) {
        return this.filter(t).head();
      }, N2.prototype.findLast = function(t) {
        return this.reverse().find(t);
      }, N2.prototype.invokeMap = H(function(t, e2) {
        return typeof t == "function" ? new N2(this) : this.map(function(n4) {
          return cn2(n4, t, e2);
        });
      }), N2.prototype.reject = function(t) {
        return this.filter(or2(E4(t)));
      }, N2.prototype.slice = function(t, e2) {
        t = T3(t);
        var n4 = this;
        return n4.__filtered__ && (t > 0 || e2 < 0) ? new N2(n4) : (t < 0 ? n4 = n4.takeRight(-t) : t && (n4 = n4.drop(t)), e2 !== i3 && (e2 = T3(e2), n4 = e2 < 0 ? n4.dropRight(-e2) : n4.take(e2 - t)), n4);
      }, N2.prototype.takeRightWhile = function(t) {
        return this.reverse().takeWhile(t).reverse();
      }, N2.prototype.toArray = function() {
        return this.take(Ut2);
      }, qt2(N2.prototype, function(t, e2) {
        var n4 = /^(?:filter|find|map|reject)|While$/.test(e2), r3 = /^(?:head|last)$/.test(e2), u3 = a4[r3 ? "take" + (e2 == "last" ? "Right" : "") : e2], o5 = r3 || /^find/.test(e2);
        u3 && (a4.prototype[e2] = function() {
          var c5 = this.__wrapped__, f3 = r3 ? [1] : arguments, l4 = c5 instanceof N2, v4 = f3[0], _3 = l4 || b3(c5), m2 = function(D3) {
            var $2 = u3.apply(a4, re([D3], f3));
            return r3 && C2 ? $2[0] : $2;
          };
          _3 && n4 && typeof v4 == "function" && v4.length != 1 && (l4 = _3 = false);
          var C2 = this.__chain__, x4 = !!this.__actions__.length, S3 = o5 && !C2, L2 = l4 && !x4;
          if (!o5 && _3) {
            c5 = L2 ? c5 : new N2(this);
            var O4 = t.apply(c5, f3);
            return O4.__actions__.push({ func: ir2, args: [m2], thisArg: i3 }), new Pt2(O4, C2);
          }
          return S3 && L2 ? t.apply(this, f3) : (O4 = this.thru(m2), S3 ? r3 ? O4.value()[0] : O4.value() : O4);
        });
      }), mt2(["pop", "push", "shift", "sort", "splice", "unshift"], function(t) {
        var e2 = bn2[t], n4 = /^(?:push|sort|unshift)$/.test(t) ? "tap" : "thru", r3 = /^(?:pop|shift)$/.test(t);
        a4.prototype[t] = function() {
          var u3 = arguments;
          if (r3 && !this.__chain__) {
            var o5 = this.value();
            return e2.apply(b3(o5) ? o5 : [], u3);
          }
          return this[n4](function(c5) {
            return e2.apply(b3(c5) ? c5 : [], u3);
          });
        };
      }), qt2(N2.prototype, function(t, e2) {
        var n4 = a4[e2];
        if (n4) {
          var r3 = n4.name + "";
          W.call(Ue, r3) || (Ue[r3] = []), Ue[r3].push({ name: e2, func: n4 });
        }
      }), Ue[Vn(i3, he2).name] = [{ name: "wrapper", func: i3 }], N2.prototype.clone = Qc, N2.prototype.reverse = Vc, N2.prototype.value = kc, a4.prototype.at = Ol, a4.prototype.chain = Rl, a4.prototype.commit = bl, a4.prototype.next = Tl, a4.prototype.plant = Hl, a4.prototype.reverse = Dl, a4.prototype.toJSON = a4.prototype.valueOf = a4.prototype.value = Nl, a4.prototype.first = a4.prototype.head, en2 && (a4.prototype[en2] = Ll), a4;
    }, De = Rc();
    pe ? ((pe.exports = De)._ = De, Lr2._ = De) : j4._ = De;
  }).call(_n2);
})(qi, qi.exports);
var Vg = Object.defineProperty;
var kg = Object.defineProperties;
var jg = Object.getOwnPropertyDescriptors;
var Ra = Object.getOwnPropertySymbols;
var tv = Object.prototype.hasOwnProperty;
var ev = Object.prototype.propertyIsEnumerable;
var ba = (P3, s2, i3) => s2 in P3 ? Vg(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var lr2 = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) tv.call(s2, i3) && ba(P3, i3, s2[i3]);
  if (Ra) for (var i3 of Ra(s2)) ev.call(s2, i3) && ba(P3, i3, s2[i3]);
  return P3;
};
var nv = (P3, s2) => kg(P3, jg(s2));
function Lt3(P3, s2, i3) {
  var p3;
  const w4 = An(P3);
  return ((p3 = s2.rpcMap) == null ? void 0 : p3[w4.reference]) || `${Oa}?chainId=${w4.namespace}:${w4.reference}&projectId=${i3}`;
}
function Ae(P3) {
  return P3.includes(":") ? P3.split(":")[1] : P3;
}
function Ta(P3) {
  return P3.map((s2) => `${s2.split(":")[0]}:${s2.split(":")[1]}`);
}
function rv(P3, s2) {
  const i3 = Object.keys(s2.namespaces).filter((w4) => w4.includes(P3));
  if (!i3.length) return [];
  const p3 = [];
  return i3.forEach((w4) => {
    const I3 = s2.namespaces[w4].accounts;
    p3.push(...I3);
  }), p3;
}
function Fi(P3 = {}, s2 = {}) {
  const i3 = La(P3), p3 = La(s2);
  return qi.exports.merge(i3, p3);
}
function La(P3) {
  var s2, i3, p3, w4;
  const I3 = {};
  if (!Xr(P3)) return I3;
  for (const [y6, J] of Object.entries(P3)) {
    const Ht2 = on(y6) ? [y6] : J.chains, Ke = J.methods || [], Ie2 = J.events || [], Dt2 = J.rpcMap || {}, Bt2 = xo(y6);
    I3[Bt2] = nv(lr2(lr2({}, I3[Bt2]), J), { chains: me(Ht2, (s2 = I3[Bt2]) == null ? void 0 : s2.chains), methods: me(Ke, (i3 = I3[Bt2]) == null ? void 0 : i3.methods), events: me(Ie2, (p3 = I3[Bt2]) == null ? void 0 : p3.events), rpcMap: lr2(lr2({}, Dt2), (w4 = I3[Bt2]) == null ? void 0 : w4.rpcMap) });
  }
  return I3;
}
function iv(P3) {
  return P3.includes(":") ? P3.split(":")[2] : P3;
}
function Ha(P3) {
  const s2 = {};
  for (const [i3, p3] of Object.entries(P3)) {
    const w4 = p3.methods || [], I3 = p3.events || [], y6 = p3.accounts || [], J = on(i3) ? [i3] : p3.chains ? p3.chains : Ta(p3.accounts);
    s2[i3] = { chains: J, methods: w4, events: I3, accounts: y6 };
  }
  return s2;
}
function Wi(P3) {
  return typeof P3 == "number" ? P3 : P3.includes("0x") ? parseInt(P3, 16) : (P3 = P3.includes(":") ? P3.split(":")[1] : P3, isNaN(Number(P3)) ? P3 : Number(P3));
}
var Da = {};
var F2 = (P3) => Da[P3];
var Mi2 = (P3, s2) => {
  Da[P3] = s2;
};
var sv = class {
  constructor(s2) {
    this.name = "polkadot", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = Ae(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var uv = Object.defineProperty;
var av = Object.defineProperties;
var ov = Object.getOwnPropertyDescriptors;
var Na = Object.getOwnPropertySymbols;
var cv = Object.prototype.hasOwnProperty;
var fv = Object.prototype.propertyIsEnumerable;
var $a = (P3, s2, i3) => s2 in P3 ? uv(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var Ua = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) cv.call(s2, i3) && $a(P3, i3, s2[i3]);
  if (Na) for (var i3 of Na(s2)) fv.call(s2, i3) && $a(P3, i3, s2[i3]);
  return P3;
};
var qa = (P3, s2) => av(P3, ov(s2));
var hv = class {
  constructor(s2) {
    this.name = "eip155", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
  }
  async request(s2) {
    switch (s2.request.method) {
      case "eth_requestAccounts":
        return this.getAccounts();
      case "eth_accounts":
        return this.getAccounts();
      case "wallet_switchEthereumChain":
        return await this.handleSwitchChain(s2);
      case "eth_chainId":
        return parseInt(this.getDefaultChain());
      case "wallet_getCapabilities":
        return await this.getCapabilities(s2);
      case "wallet_getCallsStatus":
        return await this.getCallStatus(s2);
    }
    return this.namespace.methods.includes(s2.request.method) ? await this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(parseInt(s2), i3), this.chainId = parseInt(s2), this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId.toString();
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(`${this.name}:${s2}`, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = parseInt(Ae(i3));
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  getHttpProvider() {
    const s2 = this.chainId, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  async handleSwitchChain(s2) {
    var i3, p3;
    let w4 = s2.request.params ? (i3 = s2.request.params[0]) == null ? void 0 : i3.chainId : "0x0";
    w4 = w4.startsWith("0x") ? w4 : `0x${w4}`;
    const I3 = parseInt(w4, 16);
    if (this.isChainApproved(I3)) this.setDefaultChain(`${I3}`);
    else if (this.namespace.methods.includes("wallet_switchEthereumChain")) await this.client.request({ topic: s2.topic, request: { method: s2.request.method, params: [{ chainId: w4 }] }, chainId: (p3 = this.namespace.chains) == null ? void 0 : p3[0] }), this.setDefaultChain(`${I3}`);
    else throw new Error(`Failed to switch to chain 'eip155:${I3}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
    return null;
  }
  isChainApproved(s2) {
    return this.namespace.chains.includes(`${this.name}:${s2}`);
  }
  async getCapabilities(s2) {
    var i3, p3, w4;
    const I3 = (p3 = (i3 = s2.request) == null ? void 0 : i3.params) == null ? void 0 : p3[0];
    if (!I3) throw new Error("Missing address parameter in `wallet_getCapabilities` request");
    const y6 = this.client.session.get(s2.topic), J = ((w4 = y6 == null ? void 0 : y6.sessionProperties) == null ? void 0 : w4.capabilities) || {};
    if (J != null && J[I3]) return J == null ? void 0 : J[I3];
    const Ht2 = await this.client.request(s2);
    try {
      await this.client.session.update(s2.topic, { sessionProperties: qa(Ua({}, y6.sessionProperties || {}), { capabilities: qa(Ua({}, J || {}), { [I3]: Ht2 }) }) });
    } catch (Ke) {
      console.warn("Failed to update session with capabilities", Ke);
    }
    return Ht2;
  }
  async getCallStatus(s2) {
    var i3, p3;
    const w4 = this.client.session.get(s2.topic), I3 = (i3 = w4.sessionProperties) == null ? void 0 : i3.bundler_name;
    if (I3) {
      const J = this.getBundlerUrl(s2.chainId, I3);
      try {
        return await this.getUserOperationReceipt(J, s2);
      } catch (Ht2) {
        console.warn("Failed to fetch call status from bundler", Ht2, J);
      }
    }
    const y6 = (p3 = w4.sessionProperties) == null ? void 0 : p3.bundler_url;
    if (y6) try {
      return await this.getUserOperationReceipt(y6, s2);
    } catch (J) {
      console.warn("Failed to fetch call status from custom bundler", J, y6);
    }
    if (this.namespace.methods.includes(s2.request.method)) return await this.client.request(s2);
    throw new Error("Fetching call status not approved by the wallet.");
  }
  async getUserOperationReceipt(s2, i3) {
    var p3;
    const w4 = new URL(s2), I3 = await fetch(w4, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(formatJsonRpcRequest("eth_getUserOperationReceipt", [(p3 = i3.request.params) == null ? void 0 : p3[0]])) });
    if (!I3.ok) throw new Error(`Failed to fetch user operation receipt - ${I3.status}`);
    return await I3.json();
  }
  getBundlerUrl(s2, i3) {
    return `${Qg}?projectId=${this.client.core.projectId}&chainId=${s2}&bundler=${i3}`;
  }
};
var lv = class {
  constructor(s2) {
    this.name = "solana", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = Ae(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var pv = class {
  constructor(s2) {
    this.name = "cosmos", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = Ae(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var dv = class {
  constructor(s2) {
    this.name = "algorand", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    if (!this.httpProviders[s2]) {
      const p3 = i3 || Lt3(`${this.name}:${s2}`, this.namespace, this.client.core.projectId);
      if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
      this.setHttpProvider(s2, p3);
    }
    this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      s2[i3] = this.createHttpProvider(i3, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    return typeof p3 > "u" ? void 0 : new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var gv = class {
  constructor(s2) {
    this.name = "cip34", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      const p3 = this.getCardanoRPCUrl(i3), w4 = Ae(i3);
      s2[w4] = this.createHttpProvider(w4, p3);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  getCardanoRPCUrl(s2) {
    const i3 = this.namespace.rpcMap;
    if (i3) return i3[s2];
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || this.getCardanoRPCUrl(s2);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var vv = class {
  constructor(s2) {
    this.name = "elrond", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = Ae(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var _v = class {
  constructor(s2) {
    this.name = "multiversx", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      const w4 = Ae(i3);
      s2[w4] = this.createHttpProvider(w4, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var mv = class {
  constructor(s2) {
    this.name = "near", this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace = Object.assign(this.namespace, s2);
  }
  requestAccounts() {
    return this.getAccounts();
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider().request(s2.request);
  }
  setDefaultChain(s2, i3) {
    if (this.chainId = s2, !this.httpProviders[s2]) {
      const p3 = i3 || Lt3(`${this.name}:${s2}`, this.namespace);
      if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
      this.setHttpProvider(s2, p3);
    }
    this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]) || [] : [];
  }
  createHttpProviders() {
    const s2 = {};
    return this.namespace.chains.forEach((i3) => {
      var p3;
      s2[i3] = this.createHttpProvider(i3, (p3 = this.namespace.rpcMap) == null ? void 0 : p3[i3]);
    }), s2;
  }
  getHttpProvider() {
    const s2 = `${this.name}:${this.chainId}`, i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace);
    return typeof p3 > "u" ? void 0 : new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var wv = class {
  constructor(s2) {
    this.name = ze, this.namespace = s2.namespace, this.events = F2("events"), this.client = F2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
  }
  updateNamespace(s2) {
    this.namespace.chains = [...new Set((this.namespace.chains || []).concat(s2.chains || []))], this.namespace.accounts = [...new Set((this.namespace.accounts || []).concat(s2.accounts || []))], this.namespace.methods = [...new Set((this.namespace.methods || []).concat(s2.methods || []))], this.namespace.events = [...new Set((this.namespace.events || []).concat(s2.events || []))], this.httpProviders = this.createHttpProviders();
  }
  requestAccounts() {
    return this.getAccounts();
  }
  request(s2) {
    return this.namespace.methods.includes(s2.request.method) ? this.client.request(s2) : this.getHttpProvider(s2.chainId).request(s2.request);
  }
  setDefaultChain(s2, i3) {
    this.httpProviders[s2] || this.setHttpProvider(s2, i3), this.chainId = s2, this.events.emit(Tt2.DEFAULT_CHAIN_CHANGED, `${this.name}:${s2}`);
  }
  getDefaultChain() {
    if (this.chainId) return this.chainId;
    if (this.namespace.defaultChain) return this.namespace.defaultChain;
    const s2 = this.namespace.chains[0];
    if (!s2) throw new Error("ChainId not found");
    return s2.split(":")[1];
  }
  getAccounts() {
    const s2 = this.namespace.accounts;
    return s2 ? [...new Set(s2.filter((i3) => i3.split(":")[1] === this.chainId.toString()).map((i3) => i3.split(":")[2]))] : [];
  }
  createHttpProviders() {
    var s2, i3;
    const p3 = {};
    return (i3 = (s2 = this.namespace) == null ? void 0 : s2.accounts) == null || i3.forEach((w4) => {
      const I3 = An(w4);
      p3[`${I3.namespace}:${I3.reference}`] = this.createHttpProvider(w4);
    }), p3;
  }
  getHttpProvider(s2) {
    const i3 = this.httpProviders[s2];
    if (typeof i3 > "u") throw new Error(`JSON-RPC provider for ${s2} not found`);
    return i3;
  }
  setHttpProvider(s2, i3) {
    const p3 = this.createHttpProvider(s2, i3);
    p3 && (this.httpProviders[s2] = p3);
  }
  createHttpProvider(s2, i3) {
    const p3 = i3 || Lt3(s2, this.namespace, this.client.core.projectId);
    if (!p3) throw new Error(`No RPC url provided for chainId: ${s2}`);
    return new o3(new f2(p3, F2("disableProviderPing")));
  }
};
var Pv = Object.defineProperty;
var Cv = Object.defineProperties;
var Av = Object.getOwnPropertyDescriptors;
var Fa = Object.getOwnPropertySymbols;
var Iv = Object.prototype.hasOwnProperty;
var xv = Object.prototype.propertyIsEnumerable;
var Wa = (P3, s2, i3) => s2 in P3 ? Pv(P3, s2, { enumerable: true, configurable: true, writable: true, value: i3 }) : P3[s2] = i3;
var pr3 = (P3, s2) => {
  for (var i3 in s2 || (s2 = {})) Iv.call(s2, i3) && Wa(P3, i3, s2[i3]);
  if (Fa) for (var i3 of Fa(s2)) xv.call(s2, i3) && Wa(P3, i3, s2[i3]);
  return P3;
};
var Bi = (P3, s2) => Cv(P3, Av(s2));
var dr2 = class _dr {
  constructor(s2) {
    this.events = new import_events10.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.disableProviderPing = false, this.providerOpts = s2, this.logger = typeof (s2 == null ? void 0 : s2.logger) < "u" && typeof (s2 == null ? void 0 : s2.logger) != "string" ? s2.logger : (0, import_pino.default)(k({ level: (s2 == null ? void 0 : s2.logger) || ya })), this.disableProviderPing = (s2 == null ? void 0 : s2.disableProviderPing) || false;
  }
  static async init(s2) {
    const i3 = new _dr(s2);
    return await i3.initialize(), i3;
  }
  async request(s2, i3, p3) {
    const [w4, I3] = this.validateChain(i3);
    if (!this.session) throw new Error("Please call connect() before request()");
    return await this.getProvider(w4).request({ request: pr3({}, s2), chainId: `${w4}:${I3}`, topic: this.session.topic, expiry: p3 });
  }
  sendAsync(s2, i3, p3, w4) {
    const I3 = (/* @__PURE__ */ new Date()).getTime();
    this.request(s2, p3, w4).then((y6) => i3(null, formatJsonRpcResult(I3, y6))).catch((y6) => i3(y6, void 0));
  }
  async enable() {
    if (!this.client) throw new Error("Sign Client not initialized");
    return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
  }
  async disconnect() {
    var s2;
    if (!this.session) throw new Error("Please call connect() before enable()");
    await this.client.disconnect({ topic: (s2 = this.session) == null ? void 0 : s2.topic, reason: er("USER_DISCONNECTED") }), await this.cleanup();
  }
  async connect(s2) {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (this.setNamespaces(s2), await this.cleanupPendingPairings(), !s2.skipPairing) return await this.pair(s2.pairingTopic);
  }
  async authenticate(s2, i3) {
    if (!this.client) throw new Error("Sign Client not initialized");
    this.setNamespaces(s2), await this.cleanupPendingPairings();
    const { uri: p3, response: w4 } = await this.client.authenticate(s2, i3);
    p3 && (this.uri = p3, this.events.emit("display_uri", p3));
    const I3 = await w4();
    if (this.session = I3.session, this.session) {
      const y6 = Ha(this.session.namespaces);
      this.namespaces = Fi(this.namespaces, y6), this.persist("namespaces", this.namespaces), this.onConnect();
    }
    return I3;
  }
  on(s2, i3) {
    this.events.on(s2, i3);
  }
  once(s2, i3) {
    this.events.once(s2, i3);
  }
  removeListener(s2, i3) {
    this.events.removeListener(s2, i3);
  }
  off(s2, i3) {
    this.events.off(s2, i3);
  }
  get isWalletConnect() {
    return true;
  }
  async pair(s2) {
    this.shouldAbortPairingAttempt = false;
    let i3 = 0;
    do {
      if (this.shouldAbortPairingAttempt) throw new Error("Pairing aborted");
      if (i3 >= this.maxPairingAttempts) throw new Error("Max auto pairing attempts reached");
      const { uri: p3, approval: w4 } = await this.client.connect({ pairingTopic: s2, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
      p3 && (this.uri = p3, this.events.emit("display_uri", p3)), await w4().then((I3) => {
        this.session = I3;
        const y6 = Ha(I3.namespaces);
        this.namespaces = Fi(this.namespaces, y6), this.persist("namespaces", this.namespaces);
      }).catch((I3) => {
        if (I3.message !== it2) throw I3;
        i3++;
      });
    } while (!this.session);
    return this.onConnect(), this.session;
  }
  setDefaultChain(s2, i3) {
    try {
      if (!this.session) return;
      const [p3, w4] = this.validateChain(s2), I3 = this.getProvider(p3);
      I3.name === ze ? I3.setDefaultChain(`${p3}:${w4}`, i3) : I3.setDefaultChain(w4, i3);
    } catch (p3) {
      if (!/Please call connect/.test(p3.message)) throw p3;
    }
  }
  async cleanupPendingPairings(s2 = {}) {
    this.logger.info("Cleaning up inactive pairings...");
    const i3 = this.client.pairing.getAll();
    if (Nr(i3)) {
      for (const p3 of i3) s2.deletePairings ? this.client.core.expirer.set(p3.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(p3.topic);
      this.logger.info(`Inactive pairings cleared: ${i3.length}`);
    }
  }
  abortPairingAttempt() {
    this.shouldAbortPairingAttempt = true;
  }
  async checkStorage() {
    if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
      const s2 = this.client.session.keys.length - 1;
      this.session = this.client.session.get(this.client.session.keys[s2]), this.createProviders();
    }
  }
  async initialize() {
    this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
  }
  async createClient() {
    this.client = this.providerOpts.client || await _e2.init({ core: this.providerOpts.core, logger: this.providerOpts.logger || ya, relayUrl: this.providerOpts.relayUrl || Yg, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name, customStoragePrefix: this.providerOpts.customStoragePrefix, telemetryEnabled: this.providerOpts.telemetryEnabled }), this.logger.trace("SignClient Initialized");
  }
  createProviders() {
    if (!this.client) throw new Error("Sign Client not initialized");
    if (!this.session) throw new Error("Session not initialized. Please call connect() before enable()");
    const s2 = [...new Set(Object.keys(this.session.namespaces).map((i3) => xo(i3)))];
    Mi2("client", this.client), Mi2("events", this.events), Mi2("disableProviderPing", this.disableProviderPing), s2.forEach((i3) => {
      if (!this.session) return;
      const p3 = rv(i3, this.session), w4 = Ta(p3), I3 = Fi(this.namespaces, this.optionalNamespaces), y6 = Bi(pr3({}, I3[i3]), { accounts: p3, chains: w4 });
      switch (i3) {
        case "eip155":
          this.rpcProviders[i3] = new hv({ namespace: y6 });
          break;
        case "algorand":
          this.rpcProviders[i3] = new dv({ namespace: y6 });
          break;
        case "solana":
          this.rpcProviders[i3] = new lv({ namespace: y6 });
          break;
        case "cosmos":
          this.rpcProviders[i3] = new pv({ namespace: y6 });
          break;
        case "polkadot":
          this.rpcProviders[i3] = new sv({ namespace: y6 });
          break;
        case "cip34":
          this.rpcProviders[i3] = new gv({ namespace: y6 });
          break;
        case "elrond":
          this.rpcProviders[i3] = new vv({ namespace: y6 });
          break;
        case "multiversx":
          this.rpcProviders[i3] = new _v({ namespace: y6 });
          break;
        case "near":
          this.rpcProviders[i3] = new mv({ namespace: y6 });
          break;
        default:
          this.rpcProviders[ze] ? this.rpcProviders[ze].updateNamespace(y6) : this.rpcProviders[ze] = new wv({ namespace: y6 });
      }
    });
  }
  registerEventListeners() {
    if (typeof this.client > "u") throw new Error("Sign Client is not initialized");
    this.client.on("session_ping", (s2) => {
      this.events.emit("session_ping", s2);
    }), this.client.on("session_event", (s2) => {
      const { params: i3 } = s2, { event: p3 } = i3;
      if (p3.name === "accountsChanged") {
        const w4 = p3.data;
        w4 && Nr(w4) && this.events.emit("accountsChanged", w4.map(iv));
      } else if (p3.name === "chainChanged") {
        const w4 = i3.chainId, I3 = i3.event.data, y6 = xo(w4), J = Wi(w4) !== Wi(I3) ? `${y6}:${Wi(I3)}` : w4;
        this.onChainChanged(J);
      } else this.events.emit(p3.name, p3.data);
      this.events.emit("session_event", s2);
    }), this.client.on("session_update", ({ topic: s2, params: i3 }) => {
      var p3;
      const { namespaces: w4 } = i3, I3 = (p3 = this.client) == null ? void 0 : p3.session.get(s2);
      this.session = Bi(pr3({}, I3), { namespaces: w4 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: s2, params: i3 });
    }), this.client.on("session_delete", async (s2) => {
      await this.cleanup(), this.events.emit("session_delete", s2), this.events.emit("disconnect", Bi(pr3({}, er("USER_DISCONNECTED")), { data: s2.topic }));
    }), this.on(Tt2.DEFAULT_CHAIN_CHANGED, (s2) => {
      this.onChainChanged(s2, true);
    });
  }
  getProvider(s2) {
    return this.rpcProviders[s2] || this.rpcProviders[ze];
  }
  onSessionUpdate() {
    Object.keys(this.rpcProviders).forEach((s2) => {
      var i3;
      this.getProvider(s2).updateNamespace((i3 = this.session) == null ? void 0 : i3.namespaces[s2]);
    });
  }
  setNamespaces(s2) {
    const { namespaces: i3, optionalNamespaces: p3, sessionProperties: w4 } = s2;
    i3 && Object.keys(i3).length && (this.namespaces = i3), p3 && Object.keys(p3).length && (this.optionalNamespaces = p3), this.sessionProperties = w4, this.persist("namespaces", i3), this.persist("optionalNamespaces", p3);
  }
  validateChain(s2) {
    const [i3, p3] = (s2 == null ? void 0 : s2.split(":")) || ["", ""];
    if (!this.namespaces || !Object.keys(this.namespaces).length) return [i3, p3];
    if (i3 && !Object.keys(this.namespaces || {}).map((y6) => xo(y6)).includes(i3)) throw new Error(`Namespace '${i3}' is not configured. Please call connect() first with namespace config.`);
    if (i3 && p3) return [i3, p3];
    const w4 = xo(Object.keys(this.namespaces)[0]), I3 = this.rpcProviders[w4].getDefaultChain();
    return [w4, I3];
  }
  async requestAccounts() {
    const [s2] = this.validateChain();
    return await this.getProvider(s2).requestAccounts();
  }
  onChainChanged(s2, i3 = false) {
    if (!this.namespaces) return;
    const [p3, w4] = this.validateChain(s2);
    w4 && (i3 || this.getProvider(p3).setDefaultChain(w4), this.namespaces[p3] ? this.namespaces[p3].defaultChain = w4 : this.namespaces[`${p3}:${w4}`] ? this.namespaces[`${p3}:${w4}`].defaultChain = w4 : this.namespaces[`${p3}:${w4}`] = { defaultChain: w4 }, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", w4));
  }
  onConnect() {
    this.createProviders(), this.events.emit("connect", { session: this.session });
  }
  async cleanup() {
    this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
  }
  persist(s2, i3) {
    this.client.core.storage.setItem(`${Sa}/${s2}`, i3);
  }
  async getFromStore(s2) {
    return await this.client.core.storage.getItem(`${Sa}/${s2}`);
  }
};
var Ev = dr2;

export {
  dr2 as dr,
  Ev
};
/*! Bundled license information:

@walletconnect/universal-provider/dist/index.es.js:
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)
*/
//# sourceMappingURL=chunk-3F7IWAT5.js.map
